(function (global) {
  // Auto-generated bundle. Do not edit directly.
  var Platformer = global.AnimePlatformer || (global.AnimePlatformer = {});

  /* >>> core/constants.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.Config = {
  GAME_WIDTH: 960,
  GAME_HEIGHT: 540,
  TILE: 8,
  WIN_COIN_TARGET: 10,
  PLAYER: {
    maxSpeed: 164,
    acceleration: 1080,
    drag: 3200,
    jumpVelocity: 420,
    maxJumps: 1,
    gravity: 1100,
    coyoteTimeMs: 110,
    jumpBufferMs: 130,
    hurtInvulnMs: 900,
    dashSpeed: 460,
    dashDurationMs: 140,
    dashCooldownMs: 900,
    attackRange: 44,
    attackCooldownMs: 320,
    // Hard safety clamps for vertical velocity to avoid physics spikes.
    maxRiseSpeed: 520,
    maxFallSpeed: 760,
  },
  JETPACK: {
    // Fuel pool in seconds of continuous use.
    fuelCapacity: 1.25,
    // Fuel seconds consumed per second while thrusting.
    drainRate: 1.0,
    // Fuel seconds regenerated per second while grounded.
    regenRate: 0.72,
    // Gravity-like control knobs.
    hoverAccelFactor: 0.95,
    liftAccelFactor: 1.34,
    // Extra upward thrust acceleration (in addition to anti-gravity).
    thrustAccelFactor: 0.52,
    // Small extra assist while still moving upward after jump.
    jumpAssistAccelFactor: 0.34,
    rampUpTime: 0.16,
    rampDownTime: 0.22,
    minHoldToLift: 0.2,
    liftThresholdSpeed: 56,
    // Keep ascent intentionally slow vs jump.
    maxUpSpeed: 220,
    // Preserve/extend existing upward momentum when jetpack is activated mid-air.
    momentumBoostSpeed: 72,
    activationKickSpeed: 34,
    // Safety caps.
    maxAccel: 1320,
    maxThrustAccel: 1300,
    brakeDecelMax: 760,
  },
};

/*
How to tune gravity-like jetpack:
- hoverAccelFactor: 0.90-1.05. Near 1.0 feels like hover / soft fall braking.
- liftAccelFactor: 1.05-1.25. Slightly above 1 for gentle upward climb.
- thrustAccelFactor: 0.12-0.35 for extra upward push while held.
- jumpAssistAccelFactor: 0.08-0.22 to slightly extend jump when thrust starts mid-air.
- rampUpTime: 0.25-0.60 for smoother spool-up.
- rampDownTime: 0.15-0.40 for natural release dropoff.
- minHoldToLift: 0.15-0.30 to require commitment before ascent.
- liftThresholdSpeed: 30-80 so lift can start once fall is mostly canceled.
- maxUpSpeed: keep low (about 20-40% of jump velocity).
- momentumBoostSpeed / activationKickSpeed: increase for stronger mid-air activation momentum.
- maxAccel / maxThrustAccel / brakeDecelMax: lower values feel heavier and less snappy.
*/

// Keeps legacy world map available for fallback/debug.
Platformer.DEBUG_WORLD_MAP = false;
Platformer.DEBUG_JETPACK = false;
  /* <<< core/constants.js */

  /* >>> core/build-info.js */
// [bundle] namespace init removed; using local Platformer namespace.

// Auto-generated by scripts/write_build_info.py during packaging.
Platformer.BUILD_VERSION = "2026.02.16.1433";
Platformer.BUILD_TIME_UTC = "2026-02-16T14:33:48.190485Z";
Platformer.BUILD_UPDATE_REPO = "";
Platformer.BUILD_UPDATE_CHANNEL = "stable";
Platformer.BUILD_UPDATE_ENABLED = true;
Platformer.BUILD_DEBUG = false;
  /* <<< core/build-info.js */

  /* >>> core/settings.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.DEFAULT_SETTINGS = {
  settingsVersion: 6,
  gameplay: {
    difficulty: "normal",
  },
  controls: {
    left: "A",
    right: "D",
    jump: "W",
    dash: "SHIFT",
    attack: "J",
    interact: "E",
    pause: "ESC",
  },
  accessibility: {
    textSize: "medium",
    colorblindMode: "off",
    reduceScreenShake: 50,
    reducedMotion: false,
    flashReduction: false,
    subtitles: true,
    audioCues: true,
  },
  video: {
    fullscreen: false,
    displayMode: "windowed",
    resolutionPreset: "1920x1080",
    resolutionScale: 100,
    pixelPerfect: true,
    vsync: true,
    fpsCap: "60",
    cameraSmoothing: 35,
    brightness: 1.0,
  },
  audio: {
    master: 80,
    music: 60,
    sfx: 85,
    ui: 70,
    dynamicRange: "normal",
    muteWhenUnfocused: false,
  },
  convenience: {
    autoSave: true,
    checkpointFrequency: "standard",
    speedrunMode: false,
    introSeen: false,
  },
  updates: {
    enabled: true,
    autoUpdate: true,
    currentVersion: "1.0.0",
    source: "GitHub Releases",
    manifestUrl: "",
    downloadUrl: "",
  },
  debug: {
    hitboxesEnabled: false,
    playerHitbox: { w: 9, h: 24, ox: 0, oy: -3 },
  },
};

Platformer.deepClone = function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
};

Platformer.deepMerge = function deepMerge(base, incoming) {
  const out = Platformer.deepClone(base);
  const mergeInto = (target, source) => {
    if (!source || typeof source !== "object") return;
    Object.keys(source).forEach((key) => {
      const src = source[key];
      if (src && typeof src === "object" && !Array.isArray(src)) {
        if (!target[key] || typeof target[key] !== "object") {
          target[key] = {};
        }
        mergeInto(target[key], src);
      } else {
        target[key] = src;
      }
    });
  };
  mergeInto(out, incoming);
  return out;
};

Platformer.Settings = {
  key: "anime_platformer_settings_v2",
  legacyKeys: ["anime_platformer_settings_v1"],
  prefix: "anime_platformer_settings_",
  current: Platformer.deepClone(Platformer.DEFAULT_SETTINGS),
  _bootstrapped: false,

  waitForBridgeReady(timeoutMs = 2500) {
    return new Promise((resolve) => {
      const isReady = () => !!(window.pywebview && window.pywebview.api);
      if (isReady()) {
        resolve(true);
        return;
      }
      let done = false;
      const finish = (ok) => {
        if (done) return;
        done = true;
        try { window.removeEventListener("pywebviewready", onReady); } catch (_e) {}
        clearInterval(timer);
        clearTimeout(expire);
        resolve(ok);
      };
      const onReady = () => finish(true);
      try { window.addEventListener("pywebviewready", onReady, { once: true }); } catch (_e) {}
      const timer = setInterval(() => {
        if (isReady()) finish(true);
      }, 100);
      const expire = setTimeout(() => finish(isReady()), Math.max(200, Number(timeoutMs) || 2500));
    });
  },

  migrate(parsed) {
    const input = parsed && typeof parsed === "object" ? Platformer.deepClone(parsed) : {};
    const ver = Number(input.settingsVersion || 1);
    const out = input;

    if (ver < 2) {
      // v2: deprecate player-editable update URLs and lock source label.
      if (!out.updates || typeof out.updates !== "object") out.updates = {};
      out.updates.source = "GitHub Releases";
      out.updates.manifestUrl = "";
      out.updates.downloadUrl = "";
      out.settingsVersion = 2;
    }
    if (ver < 3) {
      if (!out.video || typeof out.video !== "object") out.video = {};
      if (!out.video.displayMode) {
        out.video.displayMode = out.video.fullscreen ? "fullscreen" : "windowed";
      }
      out.settingsVersion = 3;
    }
    if (ver < 4) {
      if (!out.video || typeof out.video !== "object") out.video = {};
      if (!out.video.resolutionPreset) out.video.resolutionPreset = "1920x1080";
      out.settingsVersion = 4;
    }
    if (ver < 5) {
      if (!out.debug || typeof out.debug !== "object") out.debug = {};
      if (!out.debug.playerHitbox || typeof out.debug.playerHitbox !== "object") {
        out.debug.playerHitbox = { w: 9, h: 24, ox: 0, oy: -3 };
      }
      if (typeof out.debug.hitboxesEnabled !== "boolean") out.debug.hitboxesEnabled = false;
      out.settingsVersion = 5;
    }
    if (ver < 6) {
      if (!out.debug || typeof out.debug !== "object") out.debug = {};
      // New global standard hitbox for all installs.
      out.debug.playerHitbox = { w: 9, h: 24, ox: 0, oy: -3 };
      if (typeof out.debug.hitboxesEnabled !== "boolean") out.debug.hitboxesEnabled = false;
      out.settingsVersion = 6;
    }
    out.settingsVersion = 6;
    return out;
  },

  archiveLegacySnapshot(raw) {
    if (!raw || !window.indexedDB) return;
    try {
      const req = window.indexedDB.open("anime_platformer_archive", 1);
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains("settings")) {
          db.createObjectStore("settings", { keyPath: "id", autoIncrement: true });
        }
      };
      req.onsuccess = () => {
        try {
          const db = req.result;
          const tx = db.transaction("settings", "readwrite");
          tx.objectStore("settings").add({ at: Date.now(), payload: String(raw).slice(0, 2048) });
          tx.oncomplete = () => db.close();
          tx.onerror = () => db.close();
        } catch (_e) {
          // best effort
        }
      };
    } catch (_e) {
      // best effort
    }
  },

  cleanupObsoleteStorage() {
    try {
      const keep = new Set([this.key, ...this.legacyKeys]);
      Object.keys(localStorage).forEach((k) => {
        if (k && k.startsWith(this.prefix) && !keep.has(k)) {
          localStorage.removeItem(k);
        }
      });
    } catch (_e) {
      // ignore
    }
  },

  load() {
    try {
      const buildVersion = (Platformer.BUILD_VERSION && String(Platformer.BUILD_VERSION).trim()) || "1.0.0";
      const buildUpdateEnabled = Platformer.BUILD_UPDATE_ENABLED !== false;
      let raw = localStorage.getItem(this.key);
      if (!raw) {
        for (const legacy of this.legacyKeys) {
          raw = localStorage.getItem(legacy);
          if (raw) break;
        }
      }
      if (!raw) {
        this.current = Platformer.deepClone(Platformer.DEFAULT_SETTINGS);
        this.current.updates.currentVersion = buildVersion;
        this.current.updates.enabled = buildUpdateEnabled;
        this.current.updates.source = "GitHub Releases";
        return this.current;
      }
      this.archiveLegacySnapshot(raw);
      const parsed = this.migrate(JSON.parse(raw));
      this.current = Platformer.deepMerge(Platformer.DEFAULT_SETTINGS, parsed);
      // Session-only flag: always reset on full page refresh.
      this.current.convenience.introSeen = false;
      // Always bind current version to packaged build, not stale localStorage.
      this.current.updates.currentVersion = buildVersion;
      // Build config is authoritative for whether updates are enabled.
      this.current.updates.enabled = buildUpdateEnabled;
      this.current.updates.source = "GitHub Releases";
      this.cleanupObsoleteStorage();
      this.persistLocal();
      return this.current;
    } catch (_e) {
      const buildVersion = (Platformer.BUILD_VERSION && String(Platformer.BUILD_VERSION).trim()) || "1.0.0";
      const buildUpdateEnabled = Platformer.BUILD_UPDATE_ENABLED !== false;
      this.current = Platformer.deepClone(Platformer.DEFAULT_SETTINGS);
      this.current.convenience.introSeen = false;
      this.current.updates.currentVersion = buildVersion;
      this.current.updates.enabled = buildUpdateEnabled;
      this.current.updates.source = "GitHub Releases";
      return this.current;
    }
  },

  persistLocal() {
    // Do not persist introSeen; keep it session-only.
    const toSave = Platformer.deepClone(this.current);
    toSave.convenience.introSeen = false;
    toSave.updates.currentVersion = (Platformer.BUILD_VERSION && String(Platformer.BUILD_VERSION).trim()) || "1.0.0";
    toSave.updates.source = "GitHub Releases";
    // Legacy player-editable URLs are intentionally not persisted anymore.
    toSave.updates.manifestUrl = "";
    toSave.updates.downloadUrl = "";
    this.current.updates.currentVersion = toSave.updates.currentVersion;
    this.current.updates.source = toSave.updates.source;
    this.current.updates.manifestUrl = "";
    this.current.updates.downloadUrl = "";
    const compact = JSON.stringify(toSave);
    localStorage.setItem(this.key, compact);
    this.legacyKeys.forEach((k) => localStorage.removeItem(k));
    this.cleanupObsoleteStorage();
  },

  async save() {
    this.persistLocal();
    await this.persistHost();
  },

  async persistHost() {
    try {
      await this.waitForBridgeReady(2000);
      if (!(window.pywebview && window.pywebview.api && typeof window.pywebview.api.write_settings_blob === "function")) {
        return;
      }
      const payload = JSON.stringify(this.current);
      const res = await window.pywebview.api.write_settings_blob(payload);
      if (Platformer.Debug && (!res || !res.ok)) {
        Platformer.Debug.warn("Settings.host", (res && res.message) || "Failed writing host settings.");
      }
    } catch (e) {
      if (Platformer.Debug) Platformer.Debug.warn("Settings.host", `write failed: ${e && e.message ? e.message : e}`);
    }
  },

  async bootstrap() {
    this.load();
    if (this._bootstrapped) return this.current;
    this._bootstrapped = true;
    try {
      await this.waitForBridgeReady(3000);
      if (!(window.pywebview && window.pywebview.api && typeof window.pywebview.api.read_settings_blob === "function")) {
        return this.current;
      }
      const res = await window.pywebview.api.read_settings_blob();
      if (!res || !res.ok || !res.data) return this.current;
      const parsed = this.migrate(JSON.parse(String(res.data)));
      this.current = Platformer.deepMerge(Platformer.DEFAULT_SETTINGS, parsed);
      this.current.convenience.introSeen = false;
      this.current.updates.currentVersion = (Platformer.BUILD_VERSION && String(Platformer.BUILD_VERSION).trim()) || "1.0.0";
      this.current.updates.enabled = Platformer.BUILD_UPDATE_ENABLED !== false;
      this.current.updates.source = "GitHub Releases";
      this.persistLocal();
      if (Platformer.Debug) Platformer.Debug.log("Settings.host", "Loaded persisted settings from desktop host.");
    } catch (e) {
      if (Platformer.Debug) Platformer.Debug.warn("Settings.host", `bootstrap failed: ${e && e.message ? e.message : e}`);
    }
    return this.current;
  },

  reset() {
    this.current = Platformer.deepClone(Platformer.DEFAULT_SETTINGS);
    this.current.convenience.introSeen = false;
    this.current.updates.currentVersion = (Platformer.BUILD_VERSION && String(Platformer.BUILD_VERSION).trim()) || "1.0.0";
    this.current.updates.enabled = Platformer.BUILD_UPDATE_ENABLED !== false;
    this.current.updates.source = "GitHub Releases";
    this.current.updates.manifestUrl = "";
    this.current.updates.downloadUrl = "";
    this.save();
    return this.current;
  },

  textScale() {
    const size = this.current.accessibility.textSize;
    if (size === "small") return 0.9;
    if (size === "large") return 1.2;
    return 1;
  },
};

Platformer.Settings.load();
  /* <<< core/settings.js */

  /* >>> core/debug.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.Debug = {
  initialized: false,
  enabled: false,
  lines: [],
  maxLines: 300,
  panel: null,
  logEl: null,
  statusEl: null,
  copyBtn: null,
  latestErrorBlock: "",
  _monitorsAttached: false,
  _nativeLogInFlight: 0,
  _nativeLogDropped: 0,
  _lastMismatchKey: "",
  _lastMismatchAt: 0,
  hitboxesEnabled: false,
  playerHitboxProfile: { w: 9, h: 24, ox: 0, oy: -3 },

  init() {
    if (this.initialized) return;
    this.initialized = true;
    this.enabled = true;
    const settingsDebug = (Platformer.Settings && Platformer.Settings.current && Platformer.Settings.current.debug) || null;
    if (settingsDebug) {
      this.hitboxesEnabled = !!settingsDebug.hitboxesEnabled;
      this.playerHitboxProfile = {
        w: this.clampNum(settingsDebug.playerHitbox && settingsDebug.playerHitbox.w, 4, 64, 9),
        h: this.clampNum(settingsDebug.playerHitbox && settingsDebug.playerHitbox.h, 4, 64, 24),
        ox: this.clampNum(settingsDebug.playerHitbox && settingsDebug.playerHitbox.ox, -24, 24, 0),
        oy: this.clampNum(settingsDebug.playerHitbox && settingsDebug.playerHitbox.oy, -24, 24, -3),
      };
    } else {
      try {
        this.hitboxesEnabled = localStorage.getItem("platformer_hitboxes_enabled") === "1";
      } catch (_e) {
        this.hitboxesEnabled = false;
      }
      this.loadPlayerHitboxProfile();
    }

    const root = document.createElement("div");
    root.style.position = "fixed";
    root.style.right = "12px";
    root.style.bottom = "12px";
    root.style.zIndex = "999999";
    root.style.fontFamily = "Consolas, monospace";

    const toggle = document.createElement("button");
    toggle.textContent = "DEBUG";
    toggle.style.padding = "8px 10px";
    toggle.style.background = "#111827";
    toggle.style.color = "#e5e7eb";
    toggle.style.border = "1px solid #374151";
    toggle.style.cursor = "pointer";
    toggle.style.borderRadius = "6px";

    const panel = document.createElement("div");
    panel.style.display = "none";
    panel.style.marginTop = "8px";
    panel.style.width = "min(920px, 92vw)";
    panel.style.height = "min(46vh, 420px)";
    panel.style.background = "rgba(0,0,0,0.92)";
    panel.style.color = "#86efac";
    panel.style.border = "1px solid #374151";
    panel.style.borderRadius = "8px";
    panel.style.padding = "10px";
    panel.style.boxSizing = "border-box";
    panel.style.display = "none";

    const topBar = document.createElement("div");
    topBar.style.display = "flex";
    topBar.style.justifyContent = "space-between";
    topBar.style.alignItems = "center";
    topBar.style.marginBottom = "8px";

    const title = document.createElement("div");
    title.textContent = "Runtime Debug Console";
    title.style.color = "#f9fafb";

    const right = document.createElement("div");
    right.style.display = "flex";
    right.style.gap = "8px";

    const copyBtn = document.createElement("button");
    copyBtn.textContent = "Copy latest error";
    copyBtn.style.padding = "6px 8px";
    copyBtn.style.background = "#1f2937";
    copyBtn.style.color = "#f9fafb";
    copyBtn.style.border = "1px solid #4b5563";
    copyBtn.style.cursor = "pointer";

    const clearBtn = document.createElement("button");
    clearBtn.textContent = "Clear";
    clearBtn.style.padding = "6px 8px";
    clearBtn.style.background = "#1f2937";
    clearBtn.style.color = "#f9fafb";
    clearBtn.style.border = "1px solid #4b5563";
    clearBtn.style.cursor = "pointer";

    const hitboxBtn = document.createElement("button");
    hitboxBtn.style.padding = "6px 8px";
    hitboxBtn.style.background = "#1f2937";
    hitboxBtn.style.color = "#f9fafb";
    hitboxBtn.style.border = "1px solid #4b5563";
    hitboxBtn.style.cursor = "pointer";
    const refreshHitboxBtn = () => {
      hitboxBtn.textContent = this.hitboxesEnabled ? "Hitboxes: On" : "Hitboxes: Off";
    };
    refreshHitboxBtn();
    const makeMini = (label) => {
      const b = document.createElement("button");
      b.textContent = label;
      b.style.padding = "4px 6px";
      b.style.background = "#111827";
      b.style.color = "#cbd5e1";
      b.style.border = "1px solid #334155";
      b.style.cursor = "pointer";
      b.style.fontSize = "11px";
      return b;
    };
    const hbInfo = document.createElement("div");
    hbInfo.style.color = "#93c5fd";
    hbInfo.style.fontSize = "11px";
    hbInfo.style.marginBottom = "6px";
    const hbRow = document.createElement("div");
    hbRow.style.display = "flex";
    hbRow.style.flexWrap = "wrap";
    hbRow.style.gap = "4px";
    hbRow.style.marginBottom = "8px";
    const hbWm = makeMini("W-");
    const hbWp = makeMini("W+");
    const hbHm = makeMini("H-");
    const hbHp = makeMini("H+");
    const hbXm = makeMini("X-");
    const hbXp = makeMini("X+");
    const hbYm = makeMini("Y-");
    const hbYp = makeMini("Y+");
    const hbReset = makeMini("HB Reset");
    const refreshHbInfo = () => {
      const p = this.playerHitboxProfile;
      hbInfo.textContent = `Player HB w=${p.w} h=${p.h} ox=${p.ox} oy=${p.oy}`;
    };
    refreshHbInfo();

    right.appendChild(hitboxBtn);
    right.appendChild(copyBtn);
    right.appendChild(clearBtn);

    topBar.appendChild(title);
    topBar.appendChild(right);

    const status = document.createElement("div");
    status.style.marginBottom = "6px";
    status.style.color = "#93c5fd";
    status.textContent = "No errors yet.";

    const log = document.createElement("pre");
    log.style.margin = "0";
    log.style.height = "calc(100% - 58px)";
    log.style.overflow = "auto";
    log.style.whiteSpace = "pre-wrap";
    log.style.fontSize = "12px";
    log.style.lineHeight = "1.32";
    log.textContent = "Debug console ready.\n";

    panel.appendChild(topBar);
    panel.appendChild(status);
    panel.appendChild(hbInfo);
    panel.appendChild(hbRow);
    panel.appendChild(log);
    root.appendChild(toggle);
    root.appendChild(panel);
    document.body.appendChild(root);

    toggle.addEventListener("click", () => {
      panel.style.display = panel.style.display === "none" ? "block" : "none";
    });
    window.addEventListener("keydown", (e) => {
      if (e.key === "F1") {
        e.preventDefault();
        panel.style.display = panel.style.display === "none" ? "block" : "none";
      }
    });

    clearBtn.addEventListener("click", () => {
      this.lines = [];
      log.textContent = "";
      status.textContent = "Cleared.";
    });

    hitboxBtn.addEventListener("click", () => {
      this.setHitboxesEnabled(!this.hitboxesEnabled);
      refreshHitboxBtn();
      status.textContent = `Hitbox overlay ${this.hitboxesEnabled ? "enabled" : "disabled"}.`;
      status.style.color = "#93c5fd";
    });
    const bumpHb = (key, delta, min, max) => {
      const p = { ...this.playerHitboxProfile };
      p[key] = Math.max(min, Math.min(max, p[key] + delta));
      this.setPlayerHitboxProfile(p);
      refreshHbInfo();
      status.textContent = "Player hitbox updated.";
      status.style.color = "#93c5fd";
    };
    hbWm.addEventListener("click", () => bumpHb("w", -1, 4, 64));
    hbWp.addEventListener("click", () => bumpHb("w", 1, 4, 64));
    hbHm.addEventListener("click", () => bumpHb("h", -1, 4, 64));
    hbHp.addEventListener("click", () => bumpHb("h", 1, 4, 64));
    hbXm.addEventListener("click", () => bumpHb("ox", -1, -24, 24));
    hbXp.addEventListener("click", () => bumpHb("ox", 1, -24, 24));
    hbYm.addEventListener("click", () => bumpHb("oy", -1, -24, 24));
    hbYp.addEventListener("click", () => bumpHb("oy", 1, -24, 24));
    hbReset.addEventListener("click", () => {
      this.setPlayerHitboxProfile({ w: 9, h: 24, ox: 0, oy: -3 });
      refreshHbInfo();
      status.textContent = "Player hitbox reset.";
      status.style.color = "#93c5fd";
    });
    [hbWm, hbWp, hbHm, hbHp, hbXm, hbXp, hbYm, hbYp, hbReset].forEach((b) => hbRow.appendChild(b));

    copyBtn.addEventListener("click", async () => {
      const text = this.latestErrorBlock || "No captured error block yet.";
      try {
        await navigator.clipboard.writeText(text);
        status.textContent = "Latest error copied to clipboard.";
      } catch (_e) {
        status.textContent = "Copy failed. Select text manually from logs.";
      }
    });

    this.panel = panel;
    this.logEl = log;
    this.statusEl = status;
    this.copyBtn = copyBtn;

    window.addEventListener("error", (event) => {
      // Resource load failures (scripts, audio, images) come through error events too.
      if (event && event.target && event.target !== window) {
        const t = event.target;
        const tag = t.tagName || "UNKNOWN";
        const src = t.src || t.href || "(no src/href)";
        this.error("resource.error", `TAG: ${tag}\nSOURCE: ${src}`);
        return;
      }

      const msg = event.message || "Unknown window error";
      const file = event.filename || "(no filename)";
      const line = event.lineno || 0;
      const col = event.colno || 0;
      const stack = event.error && event.error.stack ? event.error.stack : "(no stack)";
      this.error("window.onerror", `MESSAGE: ${msg}\nFILE: ${file}:${line}:${col}\n${stack}`);
    }, true);

    window.addEventListener("unhandledrejection", (event) => {
      const reason = event.reason;
      const msg = reason && reason.message ? reason.message : String(reason);
      const stack = reason && reason.stack ? reason.stack : "(no stack)";
      this.error("unhandledrejection", `${msg}\n${stack}`);
    });

    this.patchConsole();
  },

  patchConsole() {
    if (console.__platformerDebugPatched) return;
    console.__platformerDebugPatched = true;

    const origLog = console.log.bind(console);
    const origWarn = console.warn.bind(console);
    const origErr = console.error.bind(console);

    console.log = (...args) => {
      this.log("console.log", this.stringifyArgs(args));
      origLog(...args);
    };
    console.warn = (...args) => {
      this.warn("console.warn", this.stringifyArgs(args));
      origWarn(...args);
    };
    console.error = (...args) => {
      this.error("console.error", this.stringifyArgs(args));
      origErr(...args);
    };
  },

  stringifyArgs(args) {
    return args.map((a) => {
      if (typeof a === "string") return a;
      try {
        return JSON.stringify(a);
      } catch (_e) {
        return String(a);
      }
    }).join(" ");
  },

  timestamp() {
    return new Date().toISOString().slice(11, 19);
  },

  append(type, label, message) {
    if (!this.enabled) return;
    const line = `[${this.timestamp()}] [${type}] ${label}: ${message}`;
    this.lines.push(line);
    if (this.lines.length > this.maxLines) {
      this.lines.shift();
    }
    if (this.logEl) {
      this.logEl.textContent = this.lines.join("\n");
      this.logEl.scrollTop = this.logEl.scrollHeight;
    }
    this.forwardToNativeConsole(type, label, message);
  },

  forwardToNativeConsole(type, label, message) {
    try {
      if (!(window.pywebview && window.pywebview.api && typeof window.pywebview.api.log_event === "function")) {
        return;
      }
      // Avoid flooding host bridge on high-frequency logs.
      if (this._nativeLogInFlight > 10) {
        this._nativeLogDropped += 1;
        if (this._nativeLogDropped % 25 === 0) {
          window.pywebview.api.log_event("WARN", "DebugBridge", `Dropped ${this._nativeLogDropped} log lines (bridge saturated)`).catch(() => {});
        }
        return;
      }
      this._nativeLogInFlight += 1;
      window.pywebview.api.log_event(type, label, String(message)).catch(() => {})
        .finally(() => {
          this._nativeLogInFlight = Math.max(0, this._nativeLogInFlight - 1);
        });
    } catch (_e) {
      // best effort
    }
  },

  log(label, message) {
    this.append("INFO", label, message);
  },

  warn(label, message) {
    this.append("WARN", label, message);
  },

  error(label, message) {
    this.append("ERROR", label, message);
    this.latestErrorBlock = [
      "=== COPY_THIS_TO_ASSISTANT ===",
      `TIME: ${new Date().toISOString()}`,
      `SOURCE: ${label}`,
      "DETAILS:",
      message,
      "=== END_COPY ===",
    ].join("\n");
    if (this.statusEl) {
      this.statusEl.textContent = "Error captured. Click 'Copy latest error'.";
      this.statusEl.style.color = "#fca5a5";
    }
  },

  attachGameMonitors(game) {
    if (!this.enabled) return;
    if (this._monitorsAttached || !game) return;
    this._monitorsAttached = true;

    try {
      const sm = game.scene && game.scene.events ? game.scene.events : null;
      if (sm) {
        const sceneEvent = (name) => (scene) => {
          const key = scene && scene.scene && scene.scene.key ? scene.scene.key : "unknown";
          this.log("Scene", `${name}: ${key}`);
        };
        sm.on("start", sceneEvent("start"));
        sm.on("ready", sceneEvent("ready"));
        sm.on("pause", sceneEvent("pause"));
        sm.on("resume", sceneEvent("resume"));
        sm.on("sleep", sceneEvent("sleep"));
        sm.on("wake", sceneEvent("wake"));
        sm.on("shutdown", sceneEvent("shutdown"));
        sm.on("destroy", sceneEvent("destroy"));
      }
    } catch (e) {
      this.warn("Debug.attachGameMonitors", `Scene monitor attach failed: ${e && e.message ? e.message : e}`);
    }

    try {
      if (game.scale && game.scale.on) {
        game.scale.on("resize", (sz) => {
          this.log("Scale.resize", `${Math.round(sz.width)}x${Math.round(sz.height)}`);
        });
      }
    } catch (e) {
      this.warn("Debug.attachGameMonitors", `Scale monitor attach failed: ${e && e.message ? e.message : e}`);
    }

    try {
      document.addEventListener("visibilitychange", () => {
        this.log("Visibility", document.hidden ? "hidden" : "visible");
      });
    } catch (_e) {
      // best effort
    }

    // Detect black bars / stale canvas sizing (common in desktop wrappers).
    setInterval(() => {
      try {
        if (!game.canvas) return;
        const root = document.getElementById("game-root");
        const vw = (root && root.clientWidth) || (document.documentElement && document.documentElement.clientWidth) || window.innerWidth || 0;
        const vh = (root && root.clientHeight) || (document.documentElement && document.documentElement.clientHeight) || window.innerHeight || 0;
        const cw = game.canvas.clientWidth || game.canvas.width || 0;
        const ch = game.canvas.clientHeight || game.canvas.height || 0;
        const dx = Math.abs(cw - vw);
        const dy = Math.abs(ch - vh);
        if (dx > 8 || dy > 8) {
          const now = Date.now();
          const key = `${vw}x${vh}|${cw}x${ch}`;
          if (key !== this._lastMismatchKey || now - this._lastMismatchAt > 5000) {
            this._lastMismatchKey = key;
            this._lastMismatchAt = now;
            this.warn("ViewportMismatch", `viewport=${vw}x${vh} canvas=${cw}x${ch} (dx=${dx},dy=${dy})`);
          }
        }
      } catch (_e) {
        // best effort
      }
    }, 1200);
  },

  safe(label, fn, ctx, args) {
    if (!this.enabled) {
      return fn.apply(ctx, args || []);
    }
    try {
      return fn.apply(ctx, args || []);
    } catch (err) {
      const stack = err && err.stack ? err.stack : String(err);
      this.error(label, stack);
      return undefined;
    }
  },

  setHitboxesEnabled(enabled) {
    this.hitboxesEnabled = !!enabled;
    if (Platformer.Settings && Platformer.Settings.current) {
      Platformer.Settings.current.debug = Platformer.Settings.current.debug || {};
      Platformer.Settings.current.debug.hitboxesEnabled = this.hitboxesEnabled;
      Platformer.Settings.save();
    } else {
      try {
        localStorage.setItem("platformer_hitboxes_enabled", this.hitboxesEnabled ? "1" : "0");
      } catch (_e) {
        // best effort
      }
    }
    try {
      window.dispatchEvent(new CustomEvent("platformer:hitboxes-toggle", { detail: { enabled: this.hitboxesEnabled } }));
    } catch (_e) {
      // best effort
    }
    this.log("Debug.hitboxes", `Hitboxes ${this.hitboxesEnabled ? "ON" : "OFF"}`);
  },

  loadPlayerHitboxProfile() {
    try {
      const raw = localStorage.getItem("platformer_player_hitbox");
      if (!raw) return;
      const p = JSON.parse(raw);
      this.playerHitboxProfile = {
        w: this.clampNum(p.w, 4, 64, 9),
        h: this.clampNum(p.h, 4, 64, 24),
        ox: this.clampNum(p.ox, -24, 24, 0),
        oy: this.clampNum(p.oy, -24, 24, -3),
      };
    } catch (_e) {
      // best effort
    }
  },

  setPlayerHitboxProfile(profile) {
    this.playerHitboxProfile = {
      w: this.clampNum(profile.w, 4, 64, 9),
      h: this.clampNum(profile.h, 4, 64, 24),
      ox: this.clampNum(profile.ox, -24, 24, 0),
      oy: this.clampNum(profile.oy, -24, 24, -3),
    };
    if (Platformer.Settings && Platformer.Settings.current) {
      Platformer.Settings.current.debug = Platformer.Settings.current.debug || {};
      Platformer.Settings.current.debug.playerHitbox = { ...this.playerHitboxProfile };
      Platformer.Settings.save();
    } else {
      try {
        localStorage.setItem("platformer_player_hitbox", JSON.stringify(this.playerHitboxProfile));
      } catch (_e) {
        // best effort
      }
    }
    try {
      window.dispatchEvent(new CustomEvent("platformer:player-hitbox-changed", { detail: { ...this.playerHitboxProfile } }));
    } catch (_e) {
      // best effort
    }
    this.log("Debug.hitboxProfile", `w=${this.playerHitboxProfile.w} h=${this.playerHitboxProfile.h} ox=${this.playerHitboxProfile.ox} oy=${this.playerHitboxProfile.oy}`);
  },

  getPlayerHitboxProfile() {
    return { ...this.playerHitboxProfile };
  },

  clampNum(v, min, max, fallback) {
    const n = Number(v);
    if (!Number.isFinite(n)) return fallback;
    return Math.max(min, Math.min(max, n));
  },
};

Platformer.wrapSceneSafety = function wrapSceneSafety(SceneClass, sceneName) {
  if (!SceneClass || SceneClass.__safeWrapped) return SceneClass;

  class SafeScene extends SceneClass {
    preload(...args) {
      const fn = SceneClass.prototype.preload;
      if (typeof fn !== "function") return undefined;
      return Platformer.Debug.safe(`${sceneName}.preload`, fn, this, args);
    }

    init(...args) {
      const fn = SceneClass.prototype.init;
      if (typeof fn !== "function") return undefined;
      return Platformer.Debug.safe(`${sceneName}.init`, fn, this, args);
    }

    create(...args) {
      const fn = SceneClass.prototype.create;
      if (typeof fn !== "function") return undefined;
      return Platformer.Debug.safe(`${sceneName}.create`, fn, this, args);
    }

    update(...args) {
      const fn = SceneClass.prototype.update;
      if (typeof fn !== "function") return undefined;
      return Platformer.Debug.safe(`${sceneName}.update`, fn, this, args);
    }

    shutdown(...args) {
      const fn = SceneClass.prototype.shutdown;
      if (typeof fn !== "function") return undefined;
      return Platformer.Debug.safe(`${sceneName}.shutdown`, fn, this, args);
    }
  }

  SafeScene.__safeWrapped = true;
  return SafeScene;
};
  /* <<< core/debug.js */

  /* >>> core/updater.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.Updater = {
  resolveSource() {
    const cfg = Platformer.Settings.current.updates || {};
    const defaultRepo = "zyynx-hub/Platformer";
    const buildRepo = String(Platformer.BUILD_UPDATE_REPO || "").trim().replace(/^\/+|\/+$/g, "");
    const buildChannel = String(Platformer.BUILD_UPDATE_CHANNEL || "stable").trim() || "stable";
    const buildEnabled = Platformer.BUILD_UPDATE_ENABLED !== false;
    const repo = buildRepo || defaultRepo;
    return {
      enabled: buildEnabled && cfg.enabled !== false,
      kind: "github",
      repo,
      channel: buildChannel,
      currentVersion: cfg.currentVersion || "0.0.0",
      fallbackDownloadUrl: cfg.downloadUrl || "",
    };
  },

  friendlyError(message) {
    const raw = String(message || "").toLowerCase();
    if (!raw) return "Update check failed.";
    if (raw.includes("no public release")) {
      return "No public release found yet.";
    }
    if (raw.includes("winerror 87") || raw.includes("parameter is incorrect")) {
      return "Network/proxy config issue. Retry or disable proxy/VPN.";
    }
    if (raw.includes("timed out") || raw.includes("network") || raw.includes("offline") || raw.includes("failed to fetch")) {
      return "Offline, retrying later.";
    }
    if (raw.includes("rate limit") || raw.includes("403")) {
      return "Update server busy, try later.";
    }
    if (raw.includes("404")) {
      return "No public release found yet.";
    }
    return "Can't reach update server.";
  },

  wait(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  },

  compareVersions(a, b) {
    const norm = (v) => String(v || "0")
      .split(".")
      .map((p) => parseInt(p, 10))
      .map((n) => (Number.isFinite(n) ? n : 0));

    const aa = norm(a);
    const bb = norm(b);
    const len = Math.max(aa.length, bb.length);
    for (let i = 0; i < len; i += 1) {
      const av = aa[i] || 0;
      const bv = bb[i] || 0;
      if (av > bv) return 1;
      if (av < bv) return -1;
    }
    return 0;
  },

  async check() {
    const source = this.resolveSource();
    if (!source.enabled) {
      return { ok: true, enabled: false, message: "Auto updates are off." };
    }

    if (source.kind === "github" && window.pywebview && window.pywebview.api) {
      if (typeof window.pywebview.api.check_update_github !== "function") {
        return { ok: false, enabled: true, transient: true, message: "Update bridge not ready yet." };
      }
      try {
        const res = await window.pywebview.api.check_update_github(
          source.repo,
          source.currentVersion,
          source.channel,
        );
        if (res && res.ok) {
          const hasUpdate = !!res.hasUpdate;
          const downloadUrl = res.downloadUrl || source.fallbackDownloadUrl || "";
          if (hasUpdate && !downloadUrl) {
            return {
              ok: false,
              enabled: true,
              transient: true,
              latestVersion: res.latestVersion || source.currentVersion,
              releaseNotes: res.releaseNotes || "",
              releasePublishedAt: res.releasePublishedAt || "",
              message: "Update found, but package is not published yet. Retry in a moment.",
            };
          }
          return {
            ok: true,
            enabled: true,
            hasUpdate,
            latestVersion: res.latestVersion || source.currentVersion,
            downloadUrl,
            checksumSha256: res.checksumSha256 || "",
            releaseNotes: res.releaseNotes || "",
            releasePublishedAt: res.releasePublishedAt || "",
            message: res.message || (hasUpdate ? "Update found." : "You're up to date."),
          };
        }
        return {
          ok: false,
          enabled: true,
          message: this.friendlyError((res && res.message) || "Can't reach update server."),
        };
      } catch (e) {
        return { ok: false, enabled: true, message: this.friendlyError(e && e.message ? e.message : e) };
      }
    }

    return { ok: false, enabled: true, message: "Update service not ready in this runtime." };
  },

  openDownload(url) {
    if (!url) return false;
    if (window.pywebview && window.pywebview.api && typeof window.pywebview.api.open_url === "function") {
      window.pywebview.api.open_url(url);
      return true;
    }
    try {
      window.open(url, "_blank", "noopener,noreferrer");
      return true;
    } catch (_e) {
      return false;
    }
  },

  canInAppApply() {
    return !!(
      window.pywebview
      && window.pywebview.api
      && typeof window.pywebview.api.start_update_download === "function"
      && typeof window.pywebview.api.get_update_progress === "function"
      && typeof window.pywebview.api.apply_downloaded_update === "function"
    );
  },

  async updateAndRestart(downloadUrl, onProgress) {
    if (!this.canInAppApply()) {
      return { ok: false, message: "In-app updater API unavailable." };
    }
    if (!downloadUrl) {
      return { ok: false, message: "Update package URL missing." };
    }

    const sendProgress = (payload) => {
      if (typeof onProgress === "function") onProgress(payload);
    };

    try {
      if (Platformer.Debug) Platformer.Debug.log("Updater", `Starting in-app update: ${downloadUrl}`);
      const start = await window.pywebview.api.start_update_download(
        downloadUrl,
        Platformer.Updater.latestChecksumSha256 || "",
      );
      if (!start || !start.ok) {
        const msg = (start && start.message) || "Failed to start update download.";
        if (Platformer.Debug) Platformer.Debug.error("Updater", msg);
        return { ok: false, message: msg };
      }

      sendProgress({ stage: "downloading", progress: 0, message: "Downloading update..." });

      for (let i = 0; i < 1200; i += 1) {
        const status = await window.pywebview.api.get_update_progress();
        if (!status || !status.ok) {
          const msg = (status && status.message) || "Failed to read update progress.";
          if (Platformer.Debug) Platformer.Debug.error("Updater", msg);
          return { ok: false, message: msg };
        }

        sendProgress(status);

        if (status.stage === "error") {
          const msg = status.message || "Update download failed.";
          if (Platformer.Debug) Platformer.Debug.error("Updater", msg);
          return { ok: false, message: msg };
        }
        if (status.stage === "downloaded") {
          break;
        }
        await this.wait(250);
      }

      sendProgress({ stage: "applying", progress: 100, message: "Restarting to finish update..." });
      if (Platformer.Debug) Platformer.Debug.log("Updater", "Download complete. Applying update.");
      const applied = await window.pywebview.api.apply_downloaded_update();
      if (!applied || !applied.ok) {
        const msg = (applied && applied.message) || "Failed to apply update.";
        if (Platformer.Debug) Platformer.Debug.error("Updater", msg);
        return { ok: false, message: msg };
      }

      if (Platformer.Debug) Platformer.Debug.log("Updater", "Updater helper launched; app is restarting.");
      return { ok: true, message: applied.message || "Restarting to finish update..." };
    } catch (e) {
      const msg = `Update flow failed: ${e && e.message ? e.message : e}`;
      if (Platformer.Debug) Platformer.Debug.error("Updater", msg);
      return { ok: false, message: msg };
    }
  },
};
  /* <<< core/updater.js */

  /* >>> systems/update-manager.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.UpdateManager = class {
  constructor(scene) {
    this.scene = scene;
    this.pendingUpdateUrl = "";
    this.updateInProgress = false;
    this.statusLockUntil = 0;
    this.lastManualUpdateAt = 0;
    this.latestChecksumSha256 = "";
  }

  log(level, msg) {
    if (!Platformer.Debug) return;
    if (level === "error") Platformer.Debug.error("UpdateManager", msg);
    else if (level === "warn") Platformer.Debug.warn("UpdateManager", msg);
    else Platformer.Debug.log("UpdateManager", msg);
  }

  now() {
    return this.scene && this.scene.time ? this.scene.time.now : Date.now();
  }

  syncSceneState() {
    this.scene.pendingUpdateUrl = this.pendingUpdateUrl;
    this.scene.updateInProgress = this.updateInProgress;
    this.scene.updateStatusLockUntil = this.statusLockUntil;
    this.scene.lastManualUpdateAt = this.lastManualUpdateAt;
  }

  setStatus(text, sticky = false, ms = 8000) {
    const scene = this.scene;
    if (!scene || !scene.sys || !scene.sys.settings || !scene.sys.settings.active) return;
    const now = this.now();
    if (!sticky && now < this.statusLockUntil) return;
    if (sticky) this.statusLockUntil = now + Math.max(500, ms);
    scene.setBottomLeftUpdateStatus(text, true);
    this.syncSceneState();
  }

  setButtonText(text) {
    const scene = this.scene;
    if (!scene || !scene.updateButtonText) return;
    scene.safeSetText(scene.updateButtonText, text, "updateButtonText");
  }

  async startInAppUpdate(downloadUrl, startMessage = "Preparing update...") {
    const scene = this.scene;
    this.updateInProgress = true;
    this.statusLockUntil = this.now() + 30000;
    this.syncSceneState();

    if (scene.updateButton) scene.updateButton.disableInteractive();
    this.setButtonText("Updating...");
    this.setStatus(startMessage, true, 30000);
    this.log("info", `startInAppUpdate: ${startMessage}`);

    const result = await Platformer.Updater.updateAndRestart(downloadUrl, (status) => {
      const pct = Number(status.progress || 0);
      const msg = status.message || status.stage || "Updating...";
      const compact = status.stage === "downloading" && Number.isFinite(pct)
        ? `${msg} (${pct.toFixed(1)}%)`
        : msg;
      this.setStatus(compact, true, 15000);
    });

    if (!result.ok) {
      this.updateInProgress = false;
      this.statusLockUntil = this.now() + 15000;
      this.syncSceneState();
      if (scene.updateButton) scene.updateButton.setInteractive({ useHandCursor: true });
      this.setButtonText("Update + Restart");
      this.setStatus(result.message || "Update failed.", true, 15000);
      this.log("error", `startInAppUpdate failed: ${result.message || "unknown"}`);
      return { ok: false, message: result.message || "Update failed." };
    }

    this.setStatus(result.message || "Restarting to finish update...", true, 30000);
    this.log("info", "startInAppUpdate succeeded; helper should relaunch app.");
    return { ok: true, message: result.message || "Restarting to finish update..." };
  }

  async handleUpdateClick() {
    const scene = this.scene;
    this.lastManualUpdateAt = this.now();
    this.statusLockUntil = this.now() + 12000;
    this.syncSceneState();

    this.log("info", "Update button clicked.");
    if (this.updateInProgress) {
      this.log("warn", "Ignored click: update already in progress.");
      this.setStatus("Update already in progress...", true, 10000);
      return;
    }

    if (this.pendingUpdateUrl) {
      if (Platformer.Updater.canInAppApply()) {
        const result = await this.startInAppUpdate(this.pendingUpdateUrl, "Updating game...");
        if (!result.ok) this.log("error", result.message || "Update failed.");
        return;
      }
      this.log("info", `In-app updater unavailable; opening URL: ${this.pendingUpdateUrl}`);
      const opened = Platformer.Updater.openDownload(this.pendingUpdateUrl);
      this.setStatus(opened ? "Downloading update..." : "Update download failed", true, 12000);
      return;
    }

    this.setStatus("Checking for updates...", true, 12000);
    this.log("info", "Manual update check requested.");
    const result = await Platformer.Updater.check();
    if (!result.ok) {
      this.log("warn", `Check failed: ${result.message || "unknown"}`);
      this.setStatus(result.message || "Can't reach update server.", true, 12000);
      return;
    }

    if (scene.setLatestChangesFromResult) scene.setLatestChangesFromResult(result);
    if (!result.enabled) {
      this.setStatus("Auto updates are off.", true, 12000);
      return;
    }

    if (result.hasUpdate) {
      this.pendingUpdateUrl = result.downloadUrl || "";
      this.latestChecksumSha256 = result.checksumSha256 || "";
      Platformer.Updater.latestChecksumSha256 = this.latestChecksumSha256;
      this.syncSceneState();

      if (!this.pendingUpdateUrl) {
        this.setButtonText("Update");
        this.setStatus("Update found, package not ready yet. Retry soon.", true, 12000);
        this.log("warn", `Update ${result.latestVersion || "(unknown)"} available without download URL.`);
        return;
      }

      const v = result.latestVersion ? `v${result.latestVersion}` : "new";
      this.setButtonText("Update + Restart");
      this.setStatus(`Update found (${v}). Starting now...`, true, 12000);
      this.log("warn", `Update available: ${v}`);

      if (Platformer.Updater.canInAppApply()) {
        const autoStart = await this.startInAppUpdate(this.pendingUpdateUrl, "Updating game...");
        if (!autoStart.ok) this.log("error", autoStart.message || "Update failed.");
      }
      return;
    }

    this.pendingUpdateUrl = "";
    this.latestChecksumSha256 = "";
    Platformer.Updater.latestChecksumSha256 = "";
    this.syncSceneState();
    this.setButtonText("Update");
    this.setStatus("You're up to date.", true, 8000);
    this.log("info", "No update available.");
  }

  async autoCheck() {
    const scene = this.scene;
    if (!scene || !scene.sys || !scene.sys.settings || !scene.sys.settings.active) return;
    if (this.updateInProgress) return;
    if (this.now() - this.lastManualUpdateAt < 10000) {
      this.log("info", "Auto-check skipped: recent manual update action.");
      return;
    }

    const cfg = Platformer.Settings.current.updates || {};
    if (!cfg.enabled) {
      this.setStatus("Auto updates are off.");
      return;
    }

    this.setStatus("Checking for updates...");
    const result = await Platformer.Updater.check();
    if (!scene.sys || !scene.sys.settings || !scene.sys.settings.active) return;
    if (!scene.scene || !scene.scene.isActive || !scene.scene.isActive("MenuScene")) return;

    if (!result.ok) {
      if (result.transient) {
        this.log("warn", `Transient check state: ${result.message || "pending"}`);
        this.setStatus("Checking for updates...");
        if (scene.time && scene.sys && scene.sys.settings && scene.sys.settings.active) {
          scene.time.delayedCall(1200, () => this.autoCheck());
        }
        return;
      }
      this.setStatus(result.message || "Can't reach update server.");
      return;
    }
    if (!result.enabled) {
      this.setStatus("Auto updates are off.");
      return;
    }

    if (scene.setLatestChangesFromResult) scene.setLatestChangesFromResult(result);
    if (result.hasUpdate) {
      const v = result.latestVersion ? `v${result.latestVersion}` : "new version";
      this.pendingUpdateUrl = result.downloadUrl || "";
      this.latestChecksumSha256 = result.checksumSha256 || "";
      Platformer.Updater.latestChecksumSha256 = this.latestChecksumSha256;
      this.syncSceneState();
      if (!this.pendingUpdateUrl) {
        this.setButtonText("Update");
        this.setStatus("Update found, package not ready yet. Retry soon.");
        this.log("warn", `Auto-check found update ${result.latestVersion || "(unknown)"} without download URL.`);
        return;
      }
      this.setButtonText("Update + Restart");
      this.setStatus(`Update found (${v}). Press Update.`);
    } else {
      this.pendingUpdateUrl = "";
      this.latestChecksumSha256 = "";
      Platformer.Updater.latestChecksumSha256 = "";
      this.syncSceneState();
      this.setButtonText("Update");
      this.setStatus("You're up to date.");
    }
  }
};

  /* <<< systems/update-manager.js */

  /* >>> worldmap/WorldMapManager.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.WorldMapManager = {
  registry: {},
  cache: {},
  shopCache: {},
  activeWorldId: null,
  defaultWorldId: "world_tutorial",
  embeddedDefaults: {
    world_tutorial: {
      id: "world_tutorial",
      name: "Tutorial World",
      orderIndex: 0,
      theme: {},
      backgroundLayers: [],
      lineStyle: {},
      defaultNodeStyle: {},
      startNodeId: "start",
      nodes: [
        { id: "start", type: "start", pos: { x: 180, y: 640 }, gameLevel: 5, ui: { title: "Rooftop Start", hint: "WASD / Arrow keys to move" } },
        { id: "teach_move", type: "tutorial", pos: { x: 430, y: 560 }, gameLevel: 5, ui: { title: "Movement Basics", hint: "Press Enter/E to confirm" } },
        { id: "junction_1", type: "junction", pos: { x: 700, y: 640 }, ui: { title: "Route Split", hint: "Left = Shop, Up = Continue" } },
        { id: "shop_01", type: "shop", pos: { x: 930, y: 640 }, ui: { title: "Supply Kiosk", hint: "Press Enter/E to confirm" } },
        { id: "teach_jump", type: "tutorial", pos: { x: 700, y: 430 }, ui: { title: "Jump Timing", hint: "WASD / Arrow keys to move" } },
        { id: "teach_hazards", type: "level", pos: { x: 980, y: 360 }, ui: { title: "Hazard Control", hint: "Press Enter/E to confirm" } },
        { id: "boss_approach", type: "level", pos: { x: 1260, y: 360 }, ui: { title: "Boss Approach", hint: "Press Enter/E to confirm" } },
        { id: "boss_tutorial", type: "boss", pos: { x: 1460, y: 280 }, ui: { title: "Boss Tutorial", hint: "Press Enter/E to confirm" } },
      ],
      edges: [
        { from: "start", to: "teach_move", kind: "straight" },
        { from: "teach_move", to: "junction_1", kind: "straight" },
        { from: "junction_1", to: "shop_01", kind: "straight" },
        { from: "junction_1", to: "teach_jump", kind: "straight" },
        { from: "teach_jump", to: "teach_hazards", kind: "straight" },
        { from: "teach_hazards", to: "boss_approach", kind: "straight" },
        { from: "boss_approach", to: "boss_tutorial", kind: "straight" },
      ],
      raw: { config: {}, nodes: {} },
    },
  },
  embeddedShops: {
    world_tutorial: {
      shop_01: {
        id: "shop_01",
        name: "Supply Kiosk",
        items: [
          { id: "hp_up_1", label: "Health Up", cost: 10, stat: "health", delta: 1 },
          { id: "speed_up_1", label: "Speed Up", cost: 8, stat: "speed", delta: 0.1 },
          { id: "dash_cd_1", label: "Dash Cooldown", cost: 12, stat: "dashCooldown", delta: -0.08 },
        ],
      },
    },
  },

  registerWorld(def) {
    if (!def || !def.id) return;
    const id = String(def.id);
    this.registry[id] = {
      id,
      basePath: String(def.basePath || "").replace(/\\/g, "/").replace(/\/$/, ""),
    };
  },

  registerDefaults() {
    if (!this.registry.world_tutorial) {
      this.registerWorld({
        id: "world_tutorial",
        basePath: "js/level/world_tutorial",
      });
    }
  },

  getWorldDef(worldId) {
    this.registerDefaults();
    return this.registry[String(worldId || this.defaultWorldId)] || null;
  },

  getCached(worldId) {
    return this.cache[String(worldId || this.defaultWorldId)] || null;
  },

  getActiveWorld() {
    return this.getCached(this.activeWorldId || this.defaultWorldId);
  },

  getNodeById(world, nodeId) {
    if (!world || !Array.isArray(world.nodes)) return null;
    const id = String(nodeId || "");
    return world.nodes.find((n) => n && String(n.id) === id) || null;
  },

  resolveGameLevelRef(levelRef) {
    if (typeof levelRef === "number" && Number.isFinite(levelRef)) return Number(levelRef);
    const ref = String(levelRef || "");
    const m = ref.match(/(\d+)/);
    if (m) return Number(m[1]);
    return 1;
  },

  async fetchJson(path) {
    const normalized = String(path || "").replace(/\\/g, "/");
    const response = await fetch(normalized, { cache: "no-store" });
    if (!response.ok) {
      throw new Error(`HTTP ${response.status} while loading ${normalized}`);
    }
    return response.json();
  },

  normalize(worldId, config, nodes) {
    const cfg = config && typeof config === "object" ? config : {};
    const nd = nodes && typeof nodes === "object" ? nodes : {};

    return {
      id: String(cfg.id || worldId),
      name: String(cfg.name || worldId),
      orderIndex: Number(cfg.orderIndex || 0),
      theme: cfg.theme || {},
      backgroundLayers: Array.isArray(cfg.backgroundLayers) ? cfg.backgroundLayers : [],
      lineStyle: cfg.lineStyle || {},
      defaultNodeStyle: cfg.defaultNodeStyle || {},
      startNodeId: nd.startNodeId || null,
      nodes: Array.isArray(nd.nodes) ? nd.nodes : [],
      edges: Array.isArray(nd.edges) ? nd.edges : [],
      raw: {
        config: cfg,
        nodes: nd,
      },
    };
  },

  async loadWorld(worldId, opts = {}) {
    const id = String(worldId || this.defaultWorldId);
    if (!opts.force && this.cache[id]) {
      return this.cache[id];
    }

    const def = this.getWorldDef(id);
    if (!def) {
      throw new Error(`World not registered: ${id}`);
    }

    const configPath = `${def.basePath}/world.config.json`;
    const nodesPath = `${def.basePath}/nodes.json`;

    let world = null;
    try {
      const [config, nodes] = await Promise.all([
        this.fetchJson(configPath),
        this.fetchJson(nodesPath),
      ]);
      world = this.normalize(id, config, nodes);
    } catch (err) {
      const embedded = this.embeddedDefaults[id] || null;
      if (!embedded) throw err;
      world = this.normalize(id, embedded, embedded);
      if (Platformer.Debug) {
        Platformer.Debug.warn("WorldMapManager", `Using embedded fallback for ${id}: ${err && err.message ? err.message : err}`);
      }
    }
    this.cache[id] = world;
    this.activeWorldId = id;

    if (Platformer.Debug) {
      Platformer.Debug.log("WorldMapManager", `Loaded world=${id} nodes=${world.nodes.length} edges=${world.edges.length}`);
    }

    return world;
  },

  async warmupDefault() {
    try {
      return await this.loadWorld(this.defaultWorldId);
    } catch (err) {
      if (Platformer.Debug) {
        Platformer.Debug.warn("WorldMapManager", `Warmup failed: ${err && err.message ? err.message : err}`);
      }
      return null;
    }
  },

  async loadShop(worldId, shopRef, opts = {}) {
    const wid = String(worldId || this.defaultWorldId);
    const sid = String(shopRef || "");
    if (!sid) throw new Error("Missing shopRef");
    const cacheKey = `${wid}:${sid}`;
    if (!opts.force && this.shopCache[cacheKey]) return this.shopCache[cacheKey];

    const def = this.getWorldDef(wid);
    if (!def) throw new Error(`World not registered: ${wid}`);
    const shopPath = `${def.basePath}/shop/${sid}.json`;
    let shop = null;
    try {
      shop = await this.fetchJson(shopPath);
    } catch (err) {
      const fallback = this.embeddedShops[wid] && this.embeddedShops[wid][sid] ? this.embeddedShops[wid][sid] : null;
      if (!fallback) throw err;
      shop = fallback;
      if (Platformer.Debug) {
        Platformer.Debug.warn("WorldMapManager.shop", `Using embedded fallback for ${cacheKey}: ${err && err.message ? err.message : err}`);
      }
    }

    const normalized = {
      id: String(shop.id || sid),
      name: String(shop.name || sid),
      items: Array.isArray(shop.items) ? shop.items.map((it) => ({
        id: String(it.id || ""),
        label: String(it.label || it.id || "Upgrade"),
        cost: Math.max(0, Number(it.cost || 0)),
        stat: String(it.stat || ""),
        delta: Number(it.delta || 0),
        max: Math.max(1, Number(it.max || 1)),
      })).filter((it) => !!it.id) : [],
    };
    this.shopCache[cacheKey] = normalized;
    if (Platformer.Debug) {
      Platformer.Debug.log("WorldMapManager.shop", `Loaded shop=${cacheKey} items=${normalized.items.length}`);
    }
    return normalized;
  },
};
  /* <<< worldmap/WorldMapManager.js */

  /* >>> worldmap/WorldMapView.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.WorldMapView = class WorldMapView {
  constructor(scene, worldData) {
    this.scene = scene;
    this.world = worldData || null;
    this.root = scene.add.container(0, 0).setDepth(10);
    this.nodeById = {};
    this.nodeViews = {};
    this.selectedNodeId = null;
    this.availableNodeIds = [];
    this.pendingNodeId = null;
    this.avatar = null;

    this.bgSky = null;
    this.bgBandA = null;
    this.bgBandB = null;
    this.scanlines = null;
    this.bgLayers = [];
    this.bgOrbs = [];
    this.layerKeys = [];
    this.pathGraphics = null;
    this.pathLines = [];
    this.particles = null;

    this.infoPanel = null;
    this.infoTitle = null;
    this.infoBody = null;
    this.infoHint = null;
    this.debugText = null;
  }

  render() {
    this.ensureNodeIndex();
    this.safeRun("drawBackground", () => this.drawBackground());
    this.safeRun("drawPaths", () => this.drawPaths());
    this.safeRun("drawNodes", () => this.drawNodes());
    this.safeRun("createInfoPanel", () => this.createInfoPanel());
    this.safeRun("resize", () => this.resize());

    const startId = this.world && this.world.startNodeId ? this.world.startNodeId : null;
    if (startId && this.nodeById[startId]) {
      this.selectNode(startId);
    }
  }

  drawBackground() {
    const vp = this.getViewport();
    const colors = (this.world && this.world.theme && this.world.theme.colors) ? this.world.theme.colors : {};
    const cTop = this.parseColor(colors.bgTop, 0x050b1f);
    const cBottom = this.parseColor(colors.bgBottom, 0x0a183c);
    const cMidA = this.parseColor(colors.bgBandA, 0x11285b);
    const cMidB = this.parseColor(colors.bgBandB, 0x0f2a5e);
    this.bgSky = this.scene.add.rectangle(0, 0, vp.w, vp.h, cTop, 1).setOrigin(0, 0).setDepth(0).setScrollFactor(0);
    this.bgBandA = this.scene.add.rectangle(0, vp.h * 0.14, vp.w, vp.h * 0.26, cMidA, 0.22).setOrigin(0, 0).setDepth(1).setScrollFactor(0);
    this.bgBandB = this.scene.add.rectangle(0, vp.h * 0.58, vp.w, vp.h * 0.22, cMidB, 0.18).setOrigin(0, 0).setDepth(1).setScrollFactor(0);
    this.bgOrbs = [
      this.scene.add.circle(vp.w * 0.18, vp.h * 0.23, Math.max(90, Math.round(vp.h * 0.11)), 0x7c3aed, 0.1).setDepth(1.3).setScrollFactor(0),
      this.scene.add.circle(vp.w * 0.8, vp.h * 0.18, Math.max(110, Math.round(vp.h * 0.14)), 0x22d3ee, 0.08).setDepth(1.35).setScrollFactor(0),
    ];

    this.scanlines = this.scene.add.graphics().setDepth(2).setScrollFactor(0);
    this.redrawScanlines(vp.w, vp.h, cBottom, colors);
    this.createParallaxLayers(vp.w, vp.h);

    this.particles = this.scene.add.particles(0, 0, this.textureOr("coin", "__WHITE"), {
      x: { min: 0, max: vp.w },
      y: { min: 0, max: vp.h },
      lifespan: { min: 3000, max: 5200 },
      speedY: { min: -20, max: -7 },
      speedX: { min: -7, max: 7 },
      scale: { start: 0.06, end: 0 },
      alpha: { start: 0.24, end: 0 },
      quantity: 1,
      frequency: 160,
    }).setDepth(3).setScrollFactor(0);
  }

  createParallaxLayers(w, h) {
    this.bgLayers = [];
    const layers = Array.isArray(this.world && this.world.backgroundLayers) ? this.world.backgroundLayers : [];
    layers.forEach((layer, idx) => {
      const key = `wm-bg-${String(this.world && this.world.id ? this.world.id : "world")}-${idx}`;
      const alpha = Phaser.Math.Clamp(Number(layer && layer.alpha != null ? layer.alpha : 0.8), 0, 1);
      const parallax = Number(layer && layer.parallax != null ? layer.parallax : 0.2);
      const depth = 1.2 + idx * 0.35;
      const fallbackTint = [0x1e3a8a, 0x1d4ed8, 0x0ea5e9][idx % 3];
      const ts = this.scene.add.tileSprite(0, 0, w, h, "__WHITE")
        .setOrigin(0, 0)
        .setDepth(depth)
        .setScrollFactor(0)
        .setAlpha(alpha)
        .setTint(fallbackTint);
      this.bgLayers.push({ sprite: ts, parallax, key, src: layer && layer.src ? String(layer.src) : "" });

      const src = layer && layer.src ? String(layer.src) : "";
      if (!src) return;
      if (this.scene.textures.exists(key)) {
        ts.setTexture(key).clearTint();
        return;
      }
      this.safeRun("bgLayer.load", () => {
        this.scene.load.image(key, src);
        this.scene.load.once(`filecomplete-image-${key}`, () => {
          if (!this.scene || !this.scene.sys || !this.scene.sys.settings || !this.scene.sys.settings.active) return;
          if (!ts || !ts.active) return;
          ts.setTexture(key).clearTint();
          if (Platformer.Debug) Platformer.Debug.log("WorldMapView.theme", `Loaded background layer ${idx + 1}: ${src}`);
        });
        this.scene.load.once("loaderror", (fileObj) => {
          if (!fileObj || String(fileObj.key) !== key) return;
          if (Platformer.Debug) Platformer.Debug.warn("WorldMapView.theme", `Background layer missing: ${src} (fallback tint used)`);
        });
        this.scene.load.start();
      });
    });
  }

  redrawScanlines(w, h, bottomColor, colors) {
    if (!this.scanlines) return;
    this.scanlines.clear();
    const lineColor = this.parseColor(colors && colors.gridLine, 0x67e8f9);
    const orbA = this.parseColor(colors && colors.orbA, 0x7c3aed);
    const orbB = this.parseColor(colors && colors.orbB, 0x38bdf8);

    this.scanlines.fillStyle(bottomColor, 0.16);
    this.scanlines.fillCircle(w * 0.18, h * 0.26, Math.max(120, Math.round(h * 0.16)));
    this.scanlines.fillStyle(bottomColor, 0.12);
    this.scanlines.fillCircle(w * 0.82, h * 0.18, Math.max(140, Math.round(h * 0.2)));

    this.scanlines.fillStyle(orbA, 0.09);
    this.scanlines.fillCircle(w * 0.24, h * 0.24, Math.max(90, Math.round(h * 0.12)));
    this.scanlines.fillStyle(orbB, 0.08);
    this.scanlines.fillCircle(w * 0.78, h * 0.2, Math.max(110, Math.round(h * 0.14)));

    this.scanlines.lineStyle(1, lineColor, 0.08);
    for (let y = 0; y <= h; y += 84) {
      this.scanlines.beginPath();
      this.scanlines.moveTo(0, y);
      this.scanlines.lineTo(w, y);
      this.scanlines.strokePath();
    }

    this.scanlines.lineStyle(2, lineColor, 0.14);
    for (let i = 0; i < 10; i += 1) {
      const x = (i * 137) % (w + 200) - 80;
      const y = 40 + ((i * 97) % (h - 80));
      this.scanlines.beginPath();
      this.scanlines.moveTo(x, y);
      this.scanlines.lineTo(x + 170, y - 44);
      this.scanlines.strokePath();
    }
  }

  drawPaths() {
    this.ensureNodeIndex();
    this.clearPathLines();
    const edges = Array.isArray(this.world && this.world.edges) ? this.world.edges : [];
    if (!edges.length && Platformer.Debug) {
      Platformer.Debug.warn("WorldMapView", "No edges found to draw.");
    }
    let drawn = 0;
    edges.forEach((edge) => {
      const from = this.getNode(edge.from);
      const to = this.getNode(edge.to);
      if (!from || !to) return;
      try {
        const lineCfg = this.world && this.world.lineStyle ? this.world.lineStyle : {};
        const glowColor = this.parseColor(lineCfg.glowColor, 0x1e3a8a);
        const coreColor = this.parseColor(lineCfg.color, 0x67e8f9);
        const glowWidth = Math.max(1, Number(lineCfg.glowWidth || 10));
        const coreWidth = Math.max(1, Number(lineCfg.width || 4));
        const glow = this.scene.add.line(
          0, 0,
          from.pos.x, from.pos.y,
          to.pos.x, to.pos.y,
          glowColor,
          0.95
        ).setOrigin(0, 0).setLineWidth(glowWidth, glowWidth).setDepth(11);
        const core = this.scene.add.line(
          0, 0,
          from.pos.x, from.pos.y,
          to.pos.x, to.pos.y,
          coreColor,
          1
        ).setOrigin(0, 0).setLineWidth(coreWidth, coreWidth).setDepth(12);
        const dot = this.scene.add.circle(
          (from.pos.x + to.pos.x) * 0.5,
          (from.pos.y + to.pos.y) * 0.5,
          3.5,
          0x93c5fd,
          0.95
        ).setDepth(13);
        this.pathLines.push(glow, core, dot);
        this.root.add([glow, core, dot]);
        drawn += 1;
      } catch (err) {
        if (Platformer.Debug) {
          Platformer.Debug.error("WorldMapView.drawPaths", `edge ${edge.from}->${edge.to} failed: ${err && err.stack ? err.stack : err}`);
        }
      }
    });
    if (Platformer.Debug) {
      Platformer.Debug.log("WorldMapView.drawPaths", `edges total=${edges.length} drawn=${drawn}`);
      if (drawn === 0 && edges.length > 0) {
        Platformer.Debug.warn("WorldMapView.drawPaths", "Edges exist but none were drawn.");
      }
    }
  }

  drawNodes() {
    this.ensureNodeIndex();
    const nodes = Array.isArray(this.world && this.world.nodes) ? this.world.nodes : [];
    nodes.forEach((node) => {
      const style = this.resolveNodeStyle(node);
      const outer = this.scene.add.circle(node.pos.x, node.pos.y, 18, style.fill, 0.95)
        .setStrokeStyle(3, style.stroke, 0.92)
        .setDepth(20);
      const inner = this.scene.add.circle(node.pos.x, node.pos.y, 9, style.inner, 1)
        .setDepth(21);
      const label = this.scene.add.text(node.pos.x, node.pos.y - 30, this.nodeTitle(node), {
        fontFamily: "Consolas",
        fontSize: "16px",
        color: style.label,
        stroke: "#0f172a",
        strokeThickness: 4,
      }).setOrigin(0.5).setDepth(22);
      const badge = this.scene.add.text(node.pos.x, node.pos.y, this.nodeBadge(node), {
        fontFamily: "Consolas",
        fontSize: "15px",
        color: "#f8fafc",
        stroke: "#0f172a",
        strokeThickness: 3,
      }).setOrigin(0.5).setDepth(23);

      this.nodeViews[node.id] = { outer, inner, label, badge, style };
      this.root.add([outer, inner, label, badge]);
    });
  }

  resolveNodeStyle(node) {
    const type = String(node.type || "level");
    const state = String(node.state || "").toLowerCase();
    const isLocked = state === "locked";
    const isCompleted = state === "completed";
    if (isLocked) {
      return { fill: 0x475569, stroke: 0x64748b, inner: 0x334155, label: "#94a3b8" };
    }
    if (isCompleted) {
      return { fill: 0x16a34a, stroke: 0xbbf7d0, inner: 0xfef08a, label: "#dcfce7" };
    }
    if (type === "shop") return { fill: 0x22c55e, stroke: 0xbbf7d0, inner: 0xfef08a, label: "#dcfce7" };
    if (type === "boss") return { fill: 0xef4444, stroke: 0xfecaca, inner: 0xf97316, label: "#fee2e2" };
    if (type === "junction") return { fill: 0xa855f7, stroke: 0xe9d5ff, inner: 0xc4b5fd, label: "#f3e8ff" };
    if (type === "tutorial") return { fill: 0x38bdf8, stroke: 0xe0f2fe, inner: 0xfacc15, label: "#e2e8f0" };
    if (type === "start") return { fill: 0x0ea5e9, stroke: 0xbae6fd, inner: 0xfacc15, label: "#f8fafc" };
    return { fill: 0x38bdf8, stroke: 0xe0f2fe, inner: 0xfacc15, label: "#e2e8f0" };
  }

  createInfoPanel() {
    this.infoPanel = this.scene.add.rectangle(20, 20, 360, 220, 0x0f172a, 0.84)
      .setOrigin(0, 0)
      .setStrokeStyle(2, 0x7dd3fc, 0.78)
      .setDepth(70)
      .setScrollFactor(0);
    this.infoTitle = this.scene.add.text(34, 34, "Tutorial World", {
      fontFamily: "Consolas",
      fontSize: "26px",
      color: "#f8fafc",
      stroke: "#020617",
      strokeThickness: 4,
    }).setDepth(71).setScrollFactor(0);
    this.infoBody = this.scene.add.text(34, 74, "Walk to a node to inspect.", {
      fontFamily: "Consolas",
      fontSize: "18px",
      color: "#cbd5e1",
      lineSpacing: 4,
      wordWrap: { width: 330 },
    }).setDepth(71).setScrollFactor(0);
    this.infoHint = this.scene.add.text(30, 252, "Press E / ENTER to play this level", {
      fontFamily: "Consolas",
      fontSize: "22px",
      color: "#fef3c7",
      stroke: "#0f172a",
      strokeThickness: 5,
    }).setDepth(72).setScrollFactor(0);
    this.infoHint.setText("Use WASD / Arrow keys to move on the map");

    this.debugText = this.scene.add.text(this.getViewport().w - 20, this.getViewport().h - 18, "", {
      fontFamily: "Consolas",
      fontSize: "16px",
      color: "#93c5fd",
      stroke: "#0f172a",
      strokeThickness: 4,
      align: "right",
    }).setOrigin(1, 1).setDepth(72).setScrollFactor(0);
  }

  selectNode(nodeId) {
    const node = this.getNode(nodeId);
    if (!node) return;
    this.selectedNodeId = nodeId;

    Object.keys(this.nodeViews).forEach((id) => {
      const view = this.nodeViews[id];
      if (!view) return;
      if (id === nodeId) {
        view.outer.setScale(1.15).setFillStyle(0x22d3ee, 1);
        view.inner.setScale(1.2);
        if (view.badge) view.badge.setScale(1.1);
      } else {
        view.outer.setScale(1).setFillStyle(view.style.fill, 0.95);
        view.inner.setScale(1);
        if (view.badge) view.badge.setScale(1);
      }
    });

    this.infoTitle.setText(`${this.nodeTitle(node)} (${node.id})`);
    const type = String(node.type || "level");
    const state = String(node.state || "unlocked");
    const hint = (node.ui && node.ui.hint) ? node.ui.hint : "Press Enter/E to confirm";
    this.infoBody.setText([
      `Type: ${type}`,
      `State: ${state}`,
      "",
      hint,
    ].join("\n"));

    this.reflowInfoPanel();
  }

  setDebug(text) {
    if (!this.debugText) return;
    this.debugText.setText(String(text || ""));
  }

  setPrompt(text) {
    if (!this.infoHint) return;
    this.infoHint.setText(String(text || ""));
  }

  setAvailableNodes(nodeIds, pendingNodeId) {
    this.availableNodeIds = Array.isArray(nodeIds) ? nodeIds.slice() : [];
    this.pendingNodeId = pendingNodeId || null;
    const available = new Set(this.availableNodeIds);
    Object.keys(this.nodeViews).forEach((id) => {
      const view = this.nodeViews[id];
      if (!view) return;
      const isSelected = id === this.selectedNodeId;
      const isAvailable = available.has(id);
      const isPending = id === this.pendingNodeId;
      if (isPending) {
        view.outer.setStrokeStyle(4, 0xfef08a, 1);
      } else if (isAvailable) {
        view.outer.setStrokeStyle(3, 0x67e8f9, 1);
      } else {
        view.outer.setStrokeStyle(3, view.style.stroke, 0.92);
      }
      if (!isSelected) {
        view.outer.setFillStyle(view.style.fill, 0.95);
      }
    });
  }

  setNodeState(nodeId, state) {
    const node = this.getNode(nodeId);
    const view = this.nodeViews[String(nodeId)];
    if (!node || !view) return;
    node.state = String(state || "locked");
    const style = this.resolveNodeStyle(node);
    view.style = style;
    view.outer.setFillStyle(style.fill, 0.95).setStrokeStyle(3, style.stroke, 0.92);
    view.inner.setFillStyle(style.inner, 1);
    view.label.setColor(style.label);
    if (view.badge) view.badge.setColor("#f8fafc");
  }

  createAvatar() {
    if (this.avatar && this.avatar.active) return this.avatar;
    this.avatar = this.scene.add.sprite(0, 0, this.textureOr("player-run-1", "player-idle-1")).setDepth(30);
    this.avatar.setDisplaySize(42, 56);
    this.root.add(this.avatar);
    return this.avatar;
  }

  setAvatarPosition(x, y) {
    if (!this.avatar) this.createAvatar();
    if (!this.avatar) return;
    this.avatar.setPosition(Number(x) || 0, Number(y) || 0);
  }

  setAvatarFacing(dirX) {
    if (!this.avatar) return;
    if (Math.abs(dirX) < 0.01) return;
    this.avatar.setFlipX(dirX < 0);
  }

  setAvatarMoving(isMoving, tickNow) {
    if (!this.avatar) return;
    const t = Number(tickNow || 0);
    if (isMoving) {
      const frame = Math.floor(t / 120) % 2 === 0 ? "player-run-1" : "player-run-2";
      this.avatar.setTexture(this.textureOr(frame, "player-idle-1"));
    } else {
      this.avatar.setTexture(this.textureOr("player-idle-1", "player-run-1"));
    }
  }

  reflowInfoPanel() {
    if (!this.infoPanel || !this.infoBody || !this.infoHint) return;
    const panelHeight = Math.max(220, Math.ceil(84 + this.infoBody.height + 20));
    this.infoPanel.setSize(360, panelHeight);
    this.infoHint.setPosition(this.infoPanel.x + 8, this.infoPanel.y + panelHeight + 10);
  }

  resize() {
    this.safeRun("resize.exec", () => {
      const vp = this.getViewport();
      this.safeRect(this.bgSky, vp.w, vp.h, 0, 0);
      this.safeRect(this.bgBandA, vp.w, vp.h * 0.22, 0, vp.h * 0.2);
      this.safeRect(this.bgBandB, vp.w, vp.h * 0.24, 0, vp.h * 0.62);
      if (this.bgOrbs[0]) this.bgOrbs[0].setPosition(vp.w * 0.18, vp.h * 0.23);
      if (this.bgOrbs[1]) this.bgOrbs[1].setPosition(vp.w * 0.8, vp.h * 0.18);
      const colors = (this.world && this.world.theme && this.world.theme.colors) ? this.world.theme.colors : {};
      this.redrawScanlines(vp.w, vp.h, this.parseColor(colors.bgBottom, 0x0a183c), colors);
      this.bgLayers.forEach((entry) => {
        if (!entry || !entry.sprite || !entry.sprite.active || typeof entry.sprite.setSize !== "function") return;
        entry.sprite.setSize(vp.w, vp.h).setPosition(0, 0);
      });

      if (this.particles) {
        this.particles.setConfig({
          x: { min: 0, max: vp.w },
          y: { min: 0, max: vp.h },
        });
      }

      this.layoutMapRootToViewport();

      if (this.debugText) {
        this.debugText.setPosition(vp.w - 20, vp.h - 18);
      }
    });
  }

  updateAmbient(timeMs) {
    const t = Number(timeMs || 0) * 0.001;
    this.bgLayers.forEach((entry, idx) => {
      if (!entry || !entry.sprite || !entry.sprite.active) return;
      if (typeof entry.sprite.tilePositionX !== "number") return;
      const p = Number(entry.parallax || 0.2);
      entry.sprite.tilePositionX = (t * 40 * p) + idx * 7;
      entry.sprite.tilePositionY = Math.sin(t * (0.2 + p * 0.3)) * (2 + idx);
    });
    if (this.bgOrbs[0]) this.bgOrbs[0].x += Math.cos(t * 0.8) * 0.22;
    if (this.bgOrbs[1]) this.bgOrbs[1].x += Math.sin(t * 0.7) * 0.25;
  }

  layoutMapRootToViewport() {
    if (!this.root || !this.world) return;
    const vp = this.getViewport();
    const b = this.deriveBounds();
    const margin = Math.max(24, Math.round(Math.min(vp.w, vp.h) * 0.04));
    const sx = (vp.w - margin * 2) / Math.max(1, b.width);
    const sy = (vp.h - margin * 2) / Math.max(1, b.height);
    const scale = Phaser.Math.Clamp(Math.min(sx, sy), 0.35, 2.2);
    const fittedW = b.width * scale;
    const fittedH = b.height * scale;
    const offsetX = (vp.w - fittedW) * 0.5 - b.x * scale;
    const offsetY = (vp.h - fittedH) * 0.5 - b.y * scale;

    this.root.setScale(scale);
    this.root.setPosition(offsetX, offsetY);

    const cam = this.scene.cameras && this.scene.cameras.main;
    if (cam) {
      cam.setViewport(0, 0, vp.w, vp.h);
      cam.setZoom(1);
      cam.scrollX = 0;
      cam.scrollY = 0;
      cam.roundPixels = true;
    }
  }

  deriveBounds() {
    const nodes = Array.isArray(this.world && this.world.nodes) ? this.world.nodes : [];
    if (!nodes.length) return { x: 0, y: 0, width: 1000, height: 700 };
    let minX = Number.POSITIVE_INFINITY;
    let minY = Number.POSITIVE_INFINITY;
    let maxX = Number.NEGATIVE_INFINITY;
    let maxY = Number.NEGATIVE_INFINITY;
    nodes.forEach((n) => {
      const x = Number(n.pos && n.pos.x);
      const y = Number(n.pos && n.pos.y);
      if (!Number.isFinite(x) || !Number.isFinite(y)) return;
      minX = Math.min(minX, x);
      minY = Math.min(minY, y);
      maxX = Math.max(maxX, x);
      maxY = Math.max(maxY, y);
    });
    if (!Number.isFinite(minX) || !Number.isFinite(minY)) return { x: 0, y: 0, width: 1000, height: 700 };
    return {
      x: minX - 120,
      y: minY - 120,
      width: (maxX - minX) + 240,
      height: (maxY - minY) + 240,
    };
  }

  nodeTitle(node) {
    if (!node) return "Node";
    if (node.ui && node.ui.title) return String(node.ui.title);
    return String(node.id || "Node");
  }

  nodeBadge(node) {
    const t = String((node && node.type) || "level");
    if (t === "start") return "S";
    if (t === "shop") return "$";
    if (t === "boss") return "B";
    if (t === "junction") return "+";
    if (t === "tutorial") return "T";
    return "L";
  }

  getNode(id) {
    return this.nodeById[String(id)] || null;
  }

  ensureNodeIndex() {
    this.nodeById = {};
    const nodes = Array.isArray(this.world && this.world.nodes) ? this.world.nodes : [];
    nodes.forEach((n) => {
      if (!n || !n.id || !n.pos) return;
      this.nodeById[n.id] = n;
    });
  }

  getViewport() {
    const gs = this.scene.scale && this.scene.scale.gameSize ? this.scene.scale.gameSize : null;
    const bs = this.scene.scale && this.scene.scale.baseSize ? this.scene.scale.baseSize : null;
    const w = (gs && gs.width) || (bs && bs.width) || this.scene.scale.width || 960;
    const h = (gs && gs.height) || (bs && bs.height) || this.scene.scale.height || 540;
    return { w: Math.max(640, Math.round(w)), h: Math.max(360, Math.round(h)) };
  }

  safeRect(obj, width, height, x, y) {
    if (!obj || !obj.active || !obj.scene) return;
    obj.setSize(width, height).setPosition(x, y);
  }

  textureOr(key, fallback) {
    if (key && this.scene.textures.exists(key)) return key;
    if (fallback && this.scene.textures.exists(fallback)) return fallback;
    return "__WHITE";
  }

  parseColor(value, fallback) {
    if (typeof value === "number" && Number.isFinite(value)) return value;
    if (typeof value === "string") {
      const s = value.trim();
      if (/^#?[0-9a-fA-F]{6}$/.test(s)) {
        return Number.parseInt(s.replace("#", ""), 16);
      }
    }
    return fallback;
  }

  destroy() {
    this.clearPathLines();
    [
      this.bgSky,
      this.bgBandA,
      this.bgBandB,
      this.scanlines,
      this.particles,
      this.infoPanel,
      this.infoTitle,
      this.infoBody,
      this.infoHint,
      this.debugText,
      this.avatar,
      this.root,
    ].forEach((obj) => {
      if (obj && obj.destroy) obj.destroy();
    });
    this.bgOrbs.forEach((o) => {
      if (o && o.destroy) o.destroy();
    });
    this.bgOrbs = [];
    this.bgLayers = [];
  }

  clearPathLines() {
    if (!Array.isArray(this.pathLines)) this.pathLines = [];
    this.pathLines.forEach((obj) => {
      if (obj && obj.destroy) obj.destroy();
    });
    this.pathLines = [];
  }

  safeRun(label, fn) {
    try {
      return fn();
    } catch (err) {
      if (Platformer.Debug) {
        Platformer.Debug.error("WorldMapView", `${label} failed: ${err && err.stack ? err.stack : err}`);
      }
      return null;
    }
  }
};
  /* <<< worldmap/WorldMapView.js */

  /* >>> worldmap/data/world-map-data.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.WorldMapData = {
  id: "NeoTokyoRoute",
  bounds: { x: 40, y: 80, width: 1520, height: 760 },
  spawn: { x: 150, y: 700 },
  blockedRegions: [
    { x: 430, y: 270, width: 170, height: 95, label: "water" },
    { x: 860, y: 470, width: 200, height: 95, label: "water" },
    { x: 1200, y: 260, width: 150, height: 120, label: "cliff" },
  ],
  nodes: [
    {
      id: "Level_01",
      levelId: "Level_01",
      gameLevel: 1,
      displayName: "Rooftop Start",
      difficulty: "Easy",
      x: 180,
      y: 680,
      requires: [],
      next: ["Level_02"],
      tutorial: "Collect 10 coins to clear. Use checkpoints and watch turret shots.",
    },
    {
      id: "Level_02",
      levelId: "Level_02",
      gameLevel: 2,
      displayName: "Metro Drift",
      difficulty: "Normal",
      x: 460,
      y: 540,
      requires: ["Level_01"],
      next: ["Level_03"],
      tutorial: "Enemy pressure increases when close. Use dash to break contact.",
    },
    {
      id: "Level_03",
      levelId: "Level_03",
      gameLevel: 3,
      displayName: "Neon Ward",
      difficulty: "Normal",
      x: 780,
      y: 640,
      requires: ["Level_02"],
      next: ["Level_04"],
      tutorial: "Projectiles are the main threat. Keep moving and route for coins.",
    },
    {
      id: "Level_04",
      levelId: "Level_04",
      gameLevel: 4,
      displayName: "Skyline Core",
      difficulty: "Hard",
      x: 1100,
      y: 500,
      requires: ["Level_03"],
      next: ["Boss_01"],
      tutorial: "Hard mode spacing: fewer safe zones and faster enemy reactions.",
    },
    {
      id: "Boss_01",
      levelId: "Boss_01",
      gameLevel: 4,
      displayName: "Boss Approach",
      difficulty: "Very Hard",
      x: 1390,
      y: 360,
      requires: ["Level_04"],
      next: [],
      tutorial: "Boss node currently uses level 4 ruleset as a challenge endpoint.",
    },
  ],
};

Platformer.WorldMapData.getNodeById = function getNodeById(id) {
  return this.nodes.find((n) => n.id === id) || null;
};

Platformer.WorldMapData.getNodeForGameLevel = function getNodeForGameLevel(level) {
  return this.nodes.find((n) => Number(n.gameLevel) === Number(level)) || null;
};
  /* <<< worldmap/data/world-map-data.js */

  /* >>> worldmap/progress/progress-manager.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.Progress = {
  key: "anime_platformer_progress_v1",
  data: null,

  defaultData() {
    return {
      unlockedNodes: { Level_01: true },
      completedNodes: {},
      bestByNode: {},
      tutorialSeenByNode: {},
      lastSelectedNodeId: "Level_01",
      lastMapPosition: null,
      lastCompletedNodeId: null,
      worlds: {},
      walletCoins: 0,
      upgradesOwned: {},
      playerStats: { health: 0, speed: 1, dashCooldown: 1 },
      version: 2,
    };
  },

  ensureLoaded() {
    if (!this.data) this.load();
    return this.data;
  },

  load() {
    try {
      const raw = localStorage.getItem(this.key);
      if (!raw) {
        this.data = this.defaultData();
        return this.data;
      }
      const parsed = JSON.parse(raw);
      this.data = Object.assign(this.defaultData(), parsed || {});
      this.data.unlockedNodes = Object.assign({ Level_01: true }, this.data.unlockedNodes || {});
      this.data.completedNodes = Object.assign({}, this.data.completedNodes || {});
      this.data.bestByNode = Object.assign({}, this.data.bestByNode || {});
      this.data.tutorialSeenByNode = Object.assign({}, this.data.tutorialSeenByNode || {});
      this.data.worlds = Object.assign({}, this.data.worlds || {});
      this.data.walletCoins = Math.max(0, Number(this.data.walletCoins || 0));
      this.data.upgradesOwned = Object.assign({}, this.data.upgradesOwned || {});
      const ps = this.data.playerStats && typeof this.data.playerStats === "object" ? this.data.playerStats : {};
      this.data.playerStats = {
        health: Number(ps.health || 0),
        speed: Number(ps.speed || 1),
        dashCooldown: Number(ps.dashCooldown || 1),
      };
      return this.data;
    } catch (_e) {
      this.data = this.defaultData();
      return this.data;
    }
  },

  save() {
    try {
      this.ensureLoaded();
      localStorage.setItem(this.key, JSON.stringify(this.data));
    } catch (_e) {
      // best effort local persistence
    }
  },

  isUnlocked(nodeId) {
    const d = this.ensureLoaded();
    return !!d.unlockedNodes[nodeId];
  },

  setUnlocked(nodeId, unlocked = true) {
    const d = this.ensureLoaded();
    d.unlockedNodes[nodeId] = !!unlocked;
    this.save();
  },

  markTutorialSeen(nodeId) {
    const d = this.ensureLoaded();
    d.tutorialSeenByNode[nodeId] = true;
    this.save();
  },

  hasSeenTutorial(nodeId) {
    const d = this.ensureLoaded();
    return !!d.tutorialSeenByNode[nodeId];
  },

  updateMapPosition(pos) {
    const d = this.ensureLoaded();
    d.lastMapPosition = pos ? { x: Number(pos.x) || 0, y: Number(pos.y) || 0 } : null;
    this.save();
  },

  ensureWorldState(world) {
    const d = this.ensureLoaded();
    const worldId = world && world.id ? String(world.id) : "world_tutorial";
    if (!d.worlds[worldId]) {
      d.worlds[worldId] = {
        unlockedNodes: {},
        completedNodes: {},
        bestByNode: {},
        tutorialSeenByNode: {},
        lastSelectedNodeId: null,
        lastCompletedNodeId: null,
      };
    }
    const ws = d.worlds[worldId];
    ws.unlockedNodes = Object.assign({}, ws.unlockedNodes || {});
    ws.completedNodes = Object.assign({}, ws.completedNodes || {});
    ws.bestByNode = Object.assign({}, ws.bestByNode || {});
    ws.tutorialSeenByNode = Object.assign({}, ws.tutorialSeenByNode || {});

    const startNodeId = world && world.startNodeId ? String(world.startNodeId) : null;
    if (startNodeId && !ws.unlockedNodes[startNodeId]) ws.unlockedNodes[startNodeId] = true;
    const edges = Array.isArray(world && world.edges) ? world.edges : [];
    edges.forEach((edge) => {
      if (!edge || String(edge.from) !== String(startNodeId)) return;
      if (!edge.unlockRule && edge.to) ws.unlockedNodes[String(edge.to)] = true;
    });
    this.propagateWorldUnlocks(world, ws);
    if (!ws.lastSelectedNodeId) ws.lastSelectedNodeId = startNodeId;
    return ws;
  },

  isWorldNodeUnlocked(world, nodeId) {
    const ws = this.ensureWorldState(world);
    return !!ws.unlockedNodes[String(nodeId)];
  },

  isWorldNodeCompleted(world, nodeId) {
    const ws = this.ensureWorldState(world);
    return !!ws.completedNodes[String(nodeId)];
  },

  getWorldNodeBest(world, nodeId) {
    const ws = this.ensureWorldState(world);
    return ws.bestByNode[String(nodeId)] || null;
  },

  setWorldSelectedNode(world, nodeId) {
    const ws = this.ensureWorldState(world);
    ws.lastSelectedNodeId = String(nodeId || "");
    this.save();
  },

  hasSeenWorldTutorial(world, nodeId) {
    const ws = this.ensureWorldState(world);
    return !!ws.tutorialSeenByNode[String(nodeId)];
  },

  markWorldTutorialSeen(world, nodeId) {
    const ws = this.ensureWorldState(world);
    ws.tutorialSeenByNode[String(nodeId)] = true;
    this.save();
  },

  evaluateUnlockRule(rule, completedMap) {
    if (!rule) return true;
    const s = String(rule);
    if (s.startsWith("complete:")) {
      const id = s.slice("complete:".length);
      return !!completedMap[id];
    }
    return true;
  },

  propagateWorldUnlocks(world, ws) {
    const startNodeId = world && world.startNodeId ? String(world.startNodeId) : null;
    const edges = Array.isArray(world && world.edges) ? world.edges : [];
    const prevUnlocked = Object.assign({}, ws.unlockedNodes || {});
    const rebuiltUnlocked = {};
    if (startNodeId) rebuiltUnlocked[startNodeId] = true;
    Object.keys(ws.completedNodes || {}).forEach((id) => {
      if (ws.completedNodes[id]) rebuiltUnlocked[String(id)] = true;
    });

    let changed = true;
    let guard = 0;
    while (changed && guard < 64) {
      guard += 1;
      changed = false;
      edges.forEach((edge) => {
        if (!edge || !edge.from || !edge.to) return;
        const fromId = String(edge.from);
        const toId = String(edge.to);
        if (!rebuiltUnlocked[fromId]) return;
        const canUnlock = this.evaluateUnlockRule(edge.unlockRule, ws.completedNodes);
        if (!canUnlock) return;
        if (!rebuiltUnlocked[toId]) {
          rebuiltUnlocked[toId] = true;
          changed = true;
        }
      });
    }

    ws.unlockedNodes = rebuiltUnlocked;
    const prevKeys = Object.keys(prevUnlocked).filter((k) => prevUnlocked[k]);
    const nextKeys = Object.keys(rebuiltUnlocked).filter((k) => rebuiltUnlocked[k]);
    const pruned = prevKeys.filter((k) => !rebuiltUnlocked[k]).length;
    const added = nextKeys.filter((k) => !prevUnlocked[k]).length;
    if ((added > 0 || pruned > 0) && Platformer.Debug) {
      Platformer.Debug.log(
        "Progress.world",
        `Reconciled unlocks in ${world && world.id ? world.id : "world"}: +${added}, -${pruned}, total=${nextKeys.length}.`
      );
    }
  },

  applyWorldUnlockGraph(world, completedNodeId) {
    const ws = this.ensureWorldState(world);
    const completed = ws.completedNodes;
    const unlocked = ws.unlockedNodes;
    const edges = Array.isArray(world && world.edges) ? world.edges : [];
    edges.forEach((edge) => {
      if (!edge || String(edge.from) !== String(completedNodeId)) return;
      const canUnlock = this.evaluateUnlockRule(edge.unlockRule, completed);
      if (canUnlock && edge.to) unlocked[String(edge.to)] = true;
    });
    this.propagateWorldUnlocks(world, ws);
  },

  markWorldLevelCompleted(world, payload) {
    const ws = this.ensureWorldState(world);
    const nodeId = payload && payload.nodeId ? String(payload.nodeId) : null;
    if (!nodeId) return null;
    const firstClear = !ws.completedNodes[nodeId];

    ws.completedNodes[nodeId] = true;
    ws.unlockedNodes[nodeId] = true;
    ws.lastCompletedNodeId = nodeId;
    ws.lastSelectedNodeId = nodeId;

    const coins = Number(payload && payload.coins ? payload.coins : 0);
    const timeLeft = Number(payload && payload.timeLeft ? payload.timeLeft : 0);
    const prev = ws.bestByNode[nodeId] || { bestCoins: 0, bestTimeLeft: 0 };
    ws.bestByNode[nodeId] = {
      bestCoins: Math.max(prev.bestCoins || 0, coins),
      bestTimeLeft: Math.max(prev.bestTimeLeft || 0, timeLeft),
    };

    if (firstClear && coins > 0) {
      const d = this.ensureLoaded();
      d.walletCoins = Math.max(0, Number(d.walletCoins || 0) + coins);
      if (Platformer.Debug) Platformer.Debug.log("Progress.shop", `Awarded ${coins} coins for first clear of ${nodeId}. Wallet=${d.walletCoins}`);
    }

    this.applyWorldUnlockGraph(world, nodeId);
    this.save();
    return nodeId;
  },

  getWalletCoins() {
    const d = this.ensureLoaded();
    return Math.max(0, Number(d.walletCoins || 0));
  },

  getOwnedUpgradeCount(upgradeId) {
    const d = this.ensureLoaded();
    return Math.max(0, Number((d.upgradesOwned || {})[String(upgradeId || "")] || 0));
  },

  getPlayerStats() {
    const d = this.ensureLoaded();
    const ps = d.playerStats || {};
    return {
      health: Number(ps.health || 0),
      speed: Number(ps.speed || 1),
      dashCooldown: Number(ps.dashCooldown || 1),
    };
  },

  purchaseUpgrade(item) {
    const d = this.ensureLoaded();
    if (!item || !item.id) return { ok: false, message: "Invalid item." };
    const itemId = String(item.id);
    const cost = Math.max(0, Number(item.cost || 0));
    const max = Math.max(1, Number(item.max || 1));
    const owned = this.getOwnedUpgradeCount(itemId);
    if (owned >= max) return { ok: false, message: "Already maxed." };
    const coins = this.getWalletCoins();
    if (coins < cost) return { ok: false, message: "Not enough coins." };

    d.walletCoins = coins - cost;
    d.upgradesOwned[itemId] = owned + 1;
    d.playerStats = d.playerStats || { health: 0, speed: 1, dashCooldown: 1 };
    const stat = String(item.stat || "");
    const delta = Number(item.delta || 0);
    if (stat === "health") {
      d.playerStats.health = Number(d.playerStats.health || 0) + delta;
    } else if (stat === "speed") {
      d.playerStats.speed = Number(d.playerStats.speed || 1) + delta;
    } else if (stat === "dashCooldown") {
      d.playerStats.dashCooldown = Number(d.playerStats.dashCooldown || 1) + delta;
    }
    this.save();
    if (Platformer.Debug) {
      Platformer.Debug.log("Progress.shop", `Purchased ${itemId} cost=${cost} owned=${d.upgradesOwned[itemId]} wallet=${d.walletCoins}`);
    }
    return { ok: true, walletCoins: d.walletCoins, owned: d.upgradesOwned[itemId], stats: this.getPlayerStats() };
  },

  markLevelCompleted(payload) {
    const manager = Platformer.WorldMapManager || null;
    const targetWorldId = payload && payload.worldId ? String(payload.worldId) : null;
    const activeWorld = manager && typeof manager.getCached === "function" && targetWorldId
      ? manager.getCached(targetWorldId)
      : (manager && typeof manager.getActiveWorld === "function" ? manager.getActiveWorld() : null);
    const incomingNodeId = payload && payload.nodeId ? String(payload.nodeId) : null;
    if (activeWorld && incomingNodeId && manager && typeof manager.getNodeById === "function" && manager.getNodeById(activeWorld, incomingNodeId)) {
      return this.markWorldLevelCompleted(activeWorld, payload);
    }

    const fallbackActiveWorld = manager && typeof manager.getActiveWorld === "function"
      ? manager.getActiveWorld()
      : null;
    if (fallbackActiveWorld && incomingNodeId && manager && typeof manager.getNodeById === "function" && manager.getNodeById(fallbackActiveWorld, incomingNodeId)) {
      return this.markWorldLevelCompleted(fallbackActiveWorld, payload);
    }

    const d = this.ensureLoaded();
    const nodeId = payload && payload.nodeId ? payload.nodeId : null;
    const levelNum = payload && payload.level ? Number(payload.level) : 1;
    const mapNode = nodeId ? Platformer.WorldMapData.getNodeById(nodeId) : Platformer.WorldMapData.getNodeForGameLevel(levelNum);
    const resolvedNodeId = mapNode ? mapNode.id : `Level_${String(levelNum).padStart(2, "0")}`;

    d.completedNodes[resolvedNodeId] = true;
    d.lastCompletedNodeId = resolvedNodeId;

    const coins = Number(payload && payload.coins ? payload.coins : 0);
    const timeLeft = Number(payload && payload.timeLeft ? payload.timeLeft : 0);
    const prev = d.bestByNode[resolvedNodeId] || { bestCoins: 0, bestTimeLeft: 0 };
    d.bestByNode[resolvedNodeId] = {
      bestCoins: Math.max(prev.bestCoins || 0, coins),
      bestTimeLeft: Math.max(prev.bestTimeLeft || 0, timeLeft),
    };

    this.setUnlocked(resolvedNodeId, true);
    this.applyUnlockGraph(resolvedNodeId);
    this.save();
    return resolvedNodeId;
  },

  applyUnlockGraph(completedNodeId) {
    const d = this.ensureLoaded();
    const completed = d.completedNodes;
    const unlocked = d.unlockedNodes;

    const node = Platformer.WorldMapData.getNodeById(completedNodeId);
    if (!node || !Array.isArray(node.next)) return;

    node.next.forEach((nextId) => {
      const nextNode = Platformer.WorldMapData.getNodeById(nextId);
      if (!nextNode) return;
      const req = Array.isArray(nextNode.requires) ? nextNode.requires : [];
      const ok = req.every((id) => !!completed[id]);
      if (ok) unlocked[nextId] = true;
    });
  },
};
  /* <<< worldmap/progress/progress-manager.js */

  /* >>> worldmap/nodes/level-node.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.LevelNode = class LevelNode {
  constructor(scene, data, progress, rootContainer) {
    this.scene = scene;
    this.data = data;
    this.progress = progress;
    this.id = data.id;
    this.unlocked = !!progress.isUnlocked(this.id);
    this.selected = false;
    this.radius = data.triggerRadius || 40;

    this.pathGlow = null;
    this.node = scene.add.circle(data.x, data.y, 18, this.unlocked ? 0x38bdf8 : 0x475569, 0.92)
      .setStrokeStyle(3, this.unlocked ? 0xe0f2fe : 0x64748b, 0.9)
      .setDepth(20);
    this.inner = scene.add.circle(data.x, data.y, 9, this.unlocked ? 0xfacc15 : 0x334155, this.unlocked ? 1 : 0.85)
      .setDepth(21);
    this.label = scene.add.text(data.x, data.y - 30, data.displayName || data.id, {
      fontFamily: "Consolas",
      fontSize: "16px",
      color: this.unlocked ? "#e2e8f0" : "#94a3b8",
      stroke: "#0f172a",
      strokeThickness: 4,
      align: "center",
    }).setOrigin(0.5).setDepth(22);

    if (rootContainer && rootContainer.add) {
      rootContainer.add([this.node, this.inner, this.label]);
    }
  }

  refreshUnlock() {
    this.unlocked = !!this.progress.isUnlocked(this.id);
    this.node.setFillStyle(this.unlocked ? 0x38bdf8 : 0x475569, 0.92);
    this.node.setStrokeStyle(3, this.unlocked ? 0xe0f2fe : 0x64748b, 0.9);
    this.inner.setFillStyle(this.unlocked ? 0xfacc15 : 0x334155, this.unlocked ? 1 : 0.85);
    this.label.setColor(this.unlocked ? "#e2e8f0" : "#94a3b8");
  }

  setSelected(active) {
    if (this.selected === active) return;
    this.selected = active;
    if (active) {
      this.node.setScale(1.15);
      this.inner.setScale(1.2);
      this.node.setFillStyle(this.unlocked ? 0x22d3ee : 0x64748b, 1);
    } else {
      this.node.setScale(1);
      this.inner.setScale(1);
      this.refreshUnlock();
    }
  }

  inRange(x, y) {
    const dx = x - this.data.x;
    const dy = y - this.data.y;
    return Math.sqrt(dx * dx + dy * dy) <= this.radius;
  }

  destroy() {
    if (this.node) this.node.destroy();
    if (this.inner) this.inner.destroy();
    if (this.label) this.label.destroy();
    if (this.pathGlow) this.pathGlow.destroy();
  }
};
  /* <<< worldmap/nodes/level-node.js */

  /* >>> worldmap/controller/player-map-controller.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.PlayerMapController = class PlayerMapController {
  constructor(scene, sprite, bounds, blockedRegions) {
    this.scene = scene;
    this.sprite = sprite;
    this.bounds = bounds;
    this.blockedRegions = blockedRegions || [];
    this.velocity = new Phaser.Math.Vector2(0, 0);
    this.maxSpeed = 220;
    this.accel = 980;
    this.drag = 1100;
  }

  isBlocked(nextX, nextY) {
    return this.blockedRegions.some((r) => {
      return nextX >= r.x && nextX <= (r.x + r.width) && nextY >= r.y && nextY <= (r.y + r.height);
    });
  }

  update(input, deltaMs) {
    const dt = Math.max(0.001, deltaMs / 1000);
    const dir = new Phaser.Math.Vector2(
      (input.left ? -1 : 0) + (input.right ? 1 : 0),
      (input.up ? -1 : 0) + (input.down ? 1 : 0)
    );
    if (dir.lengthSq() > 0) dir.normalize();

    const targetVX = dir.x * this.maxSpeed;
    const targetVY = dir.y * this.maxSpeed;

    this.velocity.x = Phaser.Math.Linear(this.velocity.x, targetVX, Phaser.Math.Clamp(this.accel * dt / this.maxSpeed, 0, 1));
    this.velocity.y = Phaser.Math.Linear(this.velocity.y, targetVY, Phaser.Math.Clamp(this.accel * dt / this.maxSpeed, 0, 1));

    if (dir.lengthSq() === 0) {
      const dragStep = this.drag * dt;
      this.velocity.x = Math.abs(this.velocity.x) <= dragStep ? 0 : this.velocity.x - Math.sign(this.velocity.x) * dragStep;
      this.velocity.y = Math.abs(this.velocity.y) <= dragStep ? 0 : this.velocity.y - Math.sign(this.velocity.y) * dragStep;
    }

    let nx = this.sprite.x + this.velocity.x * dt;
    let ny = this.sprite.y + this.velocity.y * dt;

    nx = Phaser.Math.Clamp(nx, this.bounds.x + 14, this.bounds.x + this.bounds.width - 14);
    ny = Phaser.Math.Clamp(ny, this.bounds.y + 14, this.bounds.y + this.bounds.height - 14);

    if (!this.isBlocked(nx, this.sprite.y)) {
      this.sprite.x = nx;
    } else {
      this.velocity.x = 0;
    }
    if (!this.isBlocked(this.sprite.x, ny)) {
      this.sprite.y = ny;
    } else {
      this.velocity.y = 0;
    }

    if (Math.abs(this.velocity.x) > 8) {
      this.sprite.setFlipX(this.velocity.x < 0);
    }

    return {
      speed: this.velocity.length(),
      moving: Math.abs(this.velocity.x) > 8 || Math.abs(this.velocity.y) > 8,
    };
  }
};
  /* <<< worldmap/controller/player-map-controller.js */

  /* >>> worldmap/ui/world-map-ui.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.WorldMapUI = class WorldMapUI {
  constructor(scene) {
    this.scene = scene;
    this.infoPanel = null;
    this.infoTitle = null;
    this.infoBody = null;
    this.hintText = null;
    this.backText = null;
    this.helpButton = null;
    this.helpButtonText = null;
    this.helpPanel = null;
    this.helpPanelText = null;
    this.helpOpen = false;
    this.debugText = null;
    this.resize();
  }

  buildIfMissing() {
    if (this.infoPanel) return;
    this.infoPanel = this.scene.add.rectangle(18, 18, 340, 220, 0x0f172a, 0.82)
      .setOrigin(0, 0)
      .setStrokeStyle(2, 0x7dd3fc, 0.75)
      .setScrollFactor(0)
      .setDepth(70);
    this.infoTitle = this.scene.add.text(30, 30, "Map Node", {
      fontFamily: "Consolas",
      fontSize: "22px",
      color: "#f8fafc",
      stroke: "#020617",
      strokeThickness: 4,
    }).setDepth(71);
    this.infoTitle.setScrollFactor(0);
    this.infoBody = this.scene.add.text(30, 62, "Walk onto a node.", {
      fontFamily: "Consolas",
      fontSize: "16px",
      color: "#cbd5e1",
      lineSpacing: 4,
      wordWrap: { width: 315 },
    }).setDepth(71);
    this.infoBody.setScrollFactor(0);

    this.hintText = this.scene.add.text(24, 252, "", {
      fontFamily: "Consolas",
      fontSize: "18px",
      color: "#fef3c7",
      stroke: "#0f172a",
      strokeThickness: 4,
    }).setDepth(71);
    this.hintText.setScrollFactor(0);

    this.backText = this.scene.add.text(24, this.scene.scale.height - 34, "ESC: Back to Menu", {
      fontFamily: "Consolas",
      fontSize: "18px",
      color: "#e2e8f0",
      stroke: "#0f172a",
      strokeThickness: 4,
    }).setDepth(71);
    this.backText.setScrollFactor(0);

    this.helpButton = this.scene.add.rectangle(this.scene.scale.width - 85, 34, 132, 34, 0x1d4ed8, 0.96)
      .setStrokeStyle(2, 0x93c5fd, 0.85)
      .setScrollFactor(0)
      .setDepth(72)
      .setInteractive({ useHandCursor: true });
    this.helpButtonText = this.scene.add.text(this.scene.scale.width - 85, 34, "Info (H)", {
      fontFamily: "Consolas",
      fontSize: "18px",
      color: "#f8fafc",
    }).setOrigin(0.5).setDepth(73);
    this.helpButtonText.setScrollFactor(0);
    this.helpButton.on("pointerdown", () => this.toggleHelp());

    this.helpPanel = this.scene.add.rectangle(this.scene.scale.width / 2, this.scene.scale.height / 2, 620, 300, 0x020617, 0.9)
      .setStrokeStyle(2, 0x67e8f9, 0.9)
      .setScrollFactor(0)
      .setDepth(90)
      .setVisible(false)
      .setInteractive();
    this.helpPanelText = this.scene.add.text(this.scene.scale.width / 2 - 290, this.scene.scale.height / 2 - 130,
      "World Map Help\n\n- Move: WASD / Arrow Keys\n- Select node by walking onto it\n- Enter level: E or Enter\n- Back to menu: ESC\n\nNode tips appear per-level when first selected.\nThis panel is optional and never blocks map movement.", {
        fontFamily: "Consolas",
        fontSize: "20px",
        color: "#e2e8f0",
        lineSpacing: 6,
        wordWrap: { width: 570 },
      }).setDepth(91).setVisible(false);
    this.helpPanelText.setScrollFactor(0);
    this.helpPanel.on("pointerdown", () => this.toggleHelp(false));

    this.debugText = this.scene.add.text(this.scene.scale.width - 14, this.scene.scale.height - 14, "", {
      fontFamily: "Consolas",
      fontSize: "14px",
      color: "#93c5fd",
      stroke: "#0f172a",
      strokeThickness: 4,
      align: "right",
    }).setOrigin(1, 1).setDepth(71);
    this.debugText.setScrollFactor(0);
  }

  updateNodeInfo(node, best, unlocked, showInteractHint, tutorialHint) {
    this.buildIfMissing();
    if (!node) {
      this.infoTitle.setText("Map Node");
      this.infoBody.setText("Walk onto a node.");
      this.hintText.setText("");
      return;
    }

    const bestCoins = best && Number.isFinite(best.bestCoins) ? best.bestCoins : 0;
    const bestTime = best && Number.isFinite(best.bestTimeLeft) ? best.bestTimeLeft : 0;
    this.infoTitle.setText(`${node.displayName} (${node.levelId})`);
    this.infoBody.setText([
      `Difficulty: ${node.difficulty || "Unknown"}`,
      `State: ${unlocked ? "Unlocked" : "Locked"}`,
      `Best Coins: ${bestCoins}`,
      `Best Time Left: ${bestTime}s`,
      "",
      tutorialHint || "",
    ].join("\n").trim());
    this.reflowInfoPanel();

    if (showInteractHint && unlocked) {
      this.hintText.setText("Press E / ENTER to play this level");
    } else if (!unlocked) {
      this.hintText.setText("Locked: clear required previous node(s)");
    } else {
      this.hintText.setText("");
    }
  }

  setDebug(text) {
    this.buildIfMissing();
    this.debugText.setText(String(text || ""));
  }

  toggleHelp(force) {
    this.buildIfMissing();
    if (typeof force === "boolean") this.helpOpen = force;
    else this.helpOpen = !this.helpOpen;
    this.helpPanel.setVisible(this.helpOpen);
    this.helpPanelText.setVisible(this.helpOpen);
  }

  resize() {
    this.buildIfMissing();
    const w = this.scene.scale.width;
    const h = this.scene.scale.height;
    this.backText.setPosition(24, h - 34);
    this.helpButton.setPosition(w - 85, 34);
    this.helpButtonText.setPosition(w - 85, 34);
    this.helpPanel.setPosition(w / 2, h / 2);
    this.helpPanelText.setPosition(w / 2 - 290, h / 2 - 130);
    this.debugText.setPosition(w - 14, h - 14);
    this.reflowInfoPanel();
  }

  reflowInfoPanel() {
    if (!this.infoPanel || !this.infoBody || !this.infoTitle || !this.hintText) return;
    const minHeight = 220;
    const padTop = 12;
    const bodyTop = 62;
    const bottomPad = 16;
    const contentBottom = bodyTop + this.infoBody.height + bottomPad;
    const panelHeight = Math.max(minHeight, Math.ceil(contentBottom + padTop));
    this.infoPanel.setSize(this.infoPanel.width, panelHeight);
    this.hintText.setPosition(this.infoPanel.x + 6, this.infoPanel.y + panelHeight + 10);
  }

  destroy() {
    [
      this.infoPanel,
      this.infoTitle,
      this.infoBody,
      this.hintText,
      this.backText,
      this.helpButton,
      this.helpButtonText,
      this.helpPanel,
      this.helpPanelText,
      this.debugText,
    ].forEach((el) => {
      if (el && el.destroy) el.destroy();
    });
  }
};
  /* <<< worldmap/ui/world-map-ui.js */

  /* >>> worldmap/ui/shop-panel.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.WorldMapShopPanel = class WorldMapShopPanel {
  constructor(scene) {
    this.scene = scene;
    this.root = null;
    this.title = null;
    this.wallet = null;
    this.body = null;
    this.footer = null;
    this.visible = false;
    this.shop = null;
    this.selected = 0;
    this.onClose = null;
  }

  build() {
    if (this.root) return;
    const w = this.scene.scale.width;
    const h = this.scene.scale.height;
    this.root = this.scene.add.container(w / 2, h / 2).setDepth(120).setVisible(false);

    const bg = this.scene.add.rectangle(0, 0, 620, 360, 0x020617, 0.92)
      .setStrokeStyle(2, 0x7dd3fc, 0.9);
    this.title = this.scene.add.text(-292, -160, "SHOP", {
      fontFamily: "Consolas",
      fontSize: "30px",
      color: "#f8fafc",
      stroke: "#0f172a",
      strokeThickness: 4,
    });
    this.wallet = this.scene.add.text(292, -160, "Coins: 0", {
      fontFamily: "Consolas",
      fontSize: "20px",
      color: "#fcd34d",
      stroke: "#0f172a",
      strokeThickness: 4,
      align: "right",
    }).setOrigin(1, 0);
    this.body = this.scene.add.text(-292, -112, "", {
      fontFamily: "Consolas",
      fontSize: "22px",
      color: "#e2e8f0",
      lineSpacing: 8,
      wordWrap: { width: 584 },
    });
    this.footer = this.scene.add.text(-292, 136, "UP/DOWN choose  ENTER buy  ESC close", {
      fontFamily: "Consolas",
      fontSize: "18px",
      color: "#93c5fd",
      stroke: "#0f172a",
      strokeThickness: 4,
    });

    this.root.add([bg, this.title, this.wallet, this.body, this.footer]);
  }

  open(shop, onClose) {
    this.build();
    this.shop = shop || { id: "shop", name: "Shop", items: [] };
    this.selected = 0;
    this.onClose = typeof onClose === "function" ? onClose : null;
    this.visible = true;
    this.root.setVisible(true);
    this.resize();
    this.refresh();
    if (Platformer.Debug) Platformer.Debug.log("WorldMap.shop", `Opened shop=${this.shop.id} items=${(this.shop.items || []).length}`);
  }

  close() {
    if (!this.visible) return;
    this.visible = false;
    if (this.root) this.root.setVisible(false);
    const cb = this.onClose;
    this.onClose = null;
    this.shop = null;
    if (cb) cb();
    if (Platformer.Debug) Platformer.Debug.log("WorldMap.shop", "Closed shop panel.");
  }

  moveSelection(dir) {
    if (!this.visible || !this.shop || !Array.isArray(this.shop.items) || this.shop.items.length === 0) return;
    const n = this.shop.items.length;
    this.selected = (this.selected + dir + n) % n;
    this.refresh();
  }

  tryBuySelected() {
    if (!this.visible || !this.shop || !Array.isArray(this.shop.items) || this.shop.items.length === 0) return;
    const item = this.shop.items[this.selected];
    const res = Platformer.Progress.purchaseUpgrade(item);
    if (!res || !res.ok) {
      Platformer.beeper.damage();
      if (Platformer.Debug) Platformer.Debug.warn("WorldMap.shop", `Purchase denied: ${res && res.message ? res.message : "unknown"}`);
    } else {
      Platformer.beeper.coin();
    }
    this.refresh();
  }

  refresh() {
    if (!this.visible || !this.shop) return;
    const coins = Platformer.Progress.getWalletCoins();
    this.title.setText(this.shop.name || "Shop");
    this.wallet.setText(`Coins: ${coins}`);
    const items = Array.isArray(this.shop.items) ? this.shop.items : [];
    if (!items.length) {
      this.body.setText("No items available.");
      return;
    }
    const lines = [];
    items.forEach((it, idx) => {
      const owned = Platformer.Progress.getOwnedUpgradeCount(it.id);
      const max = Math.max(1, Number(it.max || 1));
      const soldOut = owned >= max;
      const afford = coins >= Number(it.cost || 0);
      const marker = idx === this.selected ? "> " : "  ";
      const state = soldOut ? "MAX" : (afford ? "BUY" : "LOCK");
      lines.push(`${marker}${it.label}  [${it.cost}]  (${owned}/${max})  ${state}`);
      if (idx === this.selected) {
        lines.push(`   ${it.stat} ${Number(it.delta) >= 0 ? "+" : ""}${it.delta}`);
      }
    });
    this.body.setText(lines.join("\n"));
  }

  handleInput(justInput) {
    if (!this.visible) return false;
    if (justInput.up) {
      this.moveSelection(-1);
      return true;
    }
    if (justInput.down) {
      this.moveSelection(1);
      return true;
    }
    if (justInput.interact) {
      this.tryBuySelected();
      return true;
    }
    return true;
  }

  resize() {
    if (!this.root) return;
    this.root.setPosition(this.scene.scale.width / 2, this.scene.scale.height / 2);
  }

  destroy() {
    if (this.root) this.root.destroy(true);
    this.root = null;
  }
};

  /* <<< worldmap/ui/shop-panel.js */

  /* >>> systems/beeper.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.Beeper = class {
  constructor() {
    this.ctx = null;
    this.enabled = true;
  }

  unlock() {
    if (!this.enabled) return;
    if (!this.ctx) {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) {
        this.enabled = false;
        return;
      }
      this.ctx = new AudioCtx();
    }
    if (this.ctx.state === "suspended") {
      this.ctx.resume();
    }
  }

  tone(freq, duration, type = "square", gainValue = 0.05) {
    if (!this.ctx || !this.enabled) return;
    const settings = Platformer.Settings ? Platformer.Settings.current : null;
    if (settings && !settings.accessibility.audioCues) return;

    let mix = 1;
    if (settings) {
      mix = (settings.audio.master / 100) * (settings.audio.sfx / 100);
      if (settings.audio.muteWhenUnfocused && document.hidden) {
        mix = 0;
      }
    }
    if (mix <= 0) return;

    const now = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, now);
    gain.gain.setValueAtTime(gainValue * mix, now);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start(now);
    osc.stop(now + duration);
  }

  jump() {
    this.tone(420, 0.08, "square", 0.05);
  }

  coin() {
    this.tone(880, 0.06, "triangle", 0.06);
    this.tone(1320, 0.08, "triangle", 0.045);
  }

  damage() {
    this.tone(180, 0.14, "sawtooth", 0.06);
  }

  stomp() {
    this.tone(240, 0.09, "square", 0.055);
  }

  dash() {
    this.tone(520, 0.05, "triangle", 0.05);
    this.tone(340, 0.06, "square", 0.035);
  }

  attack() {
    this.tone(300, 0.04, "sawtooth", 0.045);
    this.tone(220, 0.05, "square", 0.03);
  }

  land() {
    this.tone(140, 0.05, "square", 0.03);
  }
};

Platformer.beeper = new Platformer.Beeper();
  /* <<< systems/beeper.js */

  /* >>> systems/jetpack.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.JetpackController = class {
  constructor(config, hooks) {
    const defaults = Platformer.Config.JETPACK || {};
    this.cfg = Object.assign({}, defaults, config || {});
    this.hooks = Object.assign({
      onJetpackStart: null,
      onJetpackStop: null,
    }, hooks || {});

    this.fuel = this.cfg.fuelCapacity;
    this.isThrusting = false;
    this.airborne = false;
    this.armedAfterTakeoff = false;
    this.holdTime = 0;
    this.currentAccel = 0;
    this.currentThrustAccel = 0;
    this.rampAlpha = 0;
    this.phase = "OFF";
    this.currentMaxUpSpeed = -Math.abs(this.cfg.maxUpSpeed || 150);
    this.lastDebugAt = -9999;
  }

  reset(fullFuel = true) {
    this.isThrusting = false;
    this.airborne = false;
    this.armedAfterTakeoff = false;
    this.holdTime = 0;
    this.currentAccel = 0;
    this.currentThrustAccel = 0;
    this.rampAlpha = 0;
    this.phase = "OFF";
    this.currentMaxUpSpeed = -Math.abs(this.cfg.maxUpSpeed || 150);
    if (fullFuel) this.fuel = this.cfg.fuelCapacity;
  }

  get fuelPercent() {
    if (!this.cfg.fuelCapacity) return 0;
    return Phaser.Math.Clamp((this.fuel / this.cfg.fuelCapacity) * 100, 0, 100);
  }

  canUseInState(scene) {
    if (!scene) return false;
    if (scene.isDead || scene.levelComplete || scene.isDashing) return false;
    // Guard rails for future state machines.
    if (scene.isOnLadder || scene.isClimbing) return false;
    if (scene.isInWater || scene.isSwimming) return false;
    if (scene.isWallSliding || scene.isWallClinging) return false;
    return true;
  }

  emitStart(scene) {
    if (this.hooks.onJetpackStart) this.hooks.onJetpackStart(scene, this);
    if (scene && scene.events && scene.events.emit) scene.events.emit("jetpack-start", { fuelPercent: this.fuelPercent });
  }

  emitStop(scene, reason) {
    if (this.hooks.onJetpackStop) this.hooks.onJetpackStop(scene, this, reason);
    if (scene && scene.events && scene.events.emit) scene.events.emit("jetpack-stop", { fuelPercent: this.fuelPercent, reason });
  }

  update(ctx) {
    const {
      scene,
      player,
      now,
      dt,
      grounded,
      jumpHeld,
      thrustHeld,
      worldGravity,
      jumpVelocity,
    } = ctx;

    if (!player || !player.body) {
      return { isThrusting: false, fuelPercent: this.fuelPercent, accelApplied: 0, rampAlpha: 0, phase: "OFF" };
    }

    const body = player.body;
    const prevThrust = this.isThrusting;
    const maxAccel = Math.max(0, Number(this.cfg.maxAccel || worldGravity));
    const rampUp = Math.max(0.001, Number(this.cfg.rampUpTime || 0.3));
    const rampUpRate = maxAccel / rampUp;

    if (grounded) {
      this.airborne = false;
      this.armedAfterTakeoff = false;
      this.isThrusting = false;
      this.holdTime = 0;
      this.currentAccel = 0;
      this.currentThrustAccel = 0;
      this.rampAlpha = 0;
      this.phase = "OFF";
      this.fuel = Math.min(this.cfg.fuelCapacity, this.fuel + this.cfg.regenRate * dt);
      player.setAccelerationY(0);
      body.setGravityY(0);
      if (prevThrust) this.emitStop(scene, "landed");
      return { isThrusting: false, fuelPercent: this.fuelPercent, accelApplied: 0, rampAlpha: 0, phase: this.phase };
    }

    if (!this.airborne) {
      this.airborne = true;
      // Prevent accidental thrust from same press as takeoff jump.
      this.armedAfterTakeoff = !jumpHeld;
    } else if (!this.armedAfterTakeoff && !jumpHeld) {
      this.armedAfterTakeoff = true;
    }

    const canUse = this.canUseInState(scene);
    const wantsThrust = canUse && this.armedAfterTakeoff && thrustHeld && this.fuel > 0;

    if (wantsThrust) {
      this.holdTime += dt;
      const vy = Number(body.velocity.y || 0);
      const enteringThrust = !prevThrust;
      const liftThreshold = Math.abs(Number(this.cfg.liftThresholdSpeed || 56));
      const minHoldToLift = Math.max(0, Number(this.cfg.minHoldToLift || 0.2));
      const isNearHover = vy <= liftThreshold;
      const canLift = isNearHover || this.holdTime >= minHoldToLift;
      this.phase = canLift ? "LIFT" : "BRAKE";

      const hoverAccel = worldGravity * Number(this.cfg.hoverAccelFactor || 0.95);
      const liftAccel = worldGravity * Number(this.cfg.liftAccelFactor || 1.1);
      let targetAccel = canLift ? liftAccel : hoverAccel;
      const maxThrustAccel = Math.max(0, Number(this.cfg.maxThrustAccel || maxAccel * 0.35));
      const thrustFactor = Math.max(0, Number(this.cfg.thrustAccelFactor || 0.22));
      const jumpAssistFactor = Math.max(0, Number(this.cfg.jumpAssistAccelFactor || 0.14));

      // While braking a fast fall, cap upward anti-gravity so cancellation feels weighty.
      if (!canLift && vy > 0) {
        const brakeCap = Math.max(0, Number(this.cfg.brakeDecelMax || maxAccel));
        targetAccel = Math.min(targetAccel, brakeCap);
      }

      targetAccel = Phaser.Math.Clamp(targetAccel, 0, maxAccel);
      this.currentAccel = Phaser.Math.Clamp(
        this.currentAccel + rampUpRate * dt,
        0,
        targetAccel
      );
      // Keep a dedicated thrust channel so gravity + thrust work together.
      const phaseMult = canLift ? 1.0 : 0.35;
      let targetThrustAccel = worldGravity * thrustFactor * phaseMult;
      if (vy < 0) {
        // Slight jump extension when thrusting while still rising.
        targetThrustAccel += worldGravity * jumpAssistFactor;
      }
      targetThrustAccel = Phaser.Math.Clamp(targetThrustAccel, 0, maxThrustAccel);
      this.currentThrustAccel = Phaser.Math.Clamp(
        this.currentThrustAccel + (maxThrustAccel / rampUp) * dt,
        0,
        targetThrustAccel
      );
      this.rampAlpha = maxAccel > 0 ? Phaser.Math.Clamp(this.currentAccel / maxAccel, 0, 1) : 0;
      this.isThrusting = this.currentAccel > 1;

      this.fuel = Math.max(0, this.fuel - this.cfg.drainRate * dt);
      if (enteringThrust) {
        const baseMaxUp = -Math.abs(Number(this.cfg.maxUpSpeed || 150));
        const momentumBoost = Math.max(0, Number(this.cfg.momentumBoostSpeed || 72));
        const activationKick = Math.max(0, Number(this.cfg.activationKickSpeed || 34));
        if (vy < 0) {
          // Preserve upward momentum and allow a little extra lift.
          this.currentMaxUpSpeed = Math.min(baseMaxUp, vy - momentumBoost);
          player.setVelocityY(vy - activationKick);
        } else {
          this.currentMaxUpSpeed = baseMaxUp;
        }
      }
      if (!prevThrust && this.isThrusting) this.emitStart(scene);

      player.setAccelerationY(-this.currentThrustAccel);
      // Anti-gravity offset: engine gravity (down) + this offset (up).
      body.setGravityY(-this.currentAccel);

      // Keep upward lift intentionally slow.
      const maxUp = this.currentMaxUpSpeed;
      if (body.velocity.y < maxUp) player.setVelocityY(maxUp);

      if (this.fuel <= 0) {
        this.holdTime = 0;
        this.isThrusting = false;
        this.phase = "OFF";
        this.currentAccel = 0;
        this.currentThrustAccel = 0;
        this.currentMaxUpSpeed = -Math.abs(Number(this.cfg.maxUpSpeed || 150));
        this.rampAlpha = 0;
        player.setAccelerationY(0);
        body.setGravityY(0);
        this.emitStop(scene, "fuel_empty");
      }
    } else {
      this.holdTime = 0;
      this.phase = "OFF";
      this.isThrusting = false;
      this.currentMaxUpSpeed = -Math.abs(Number(this.cfg.maxUpSpeed || 150));
      this.currentAccel = 0;
      this.currentThrustAccel = 0;
      this.rampAlpha = 0;
      player.setAccelerationY(0);
      body.setGravityY(0);
      if (prevThrust) this.emitStop(scene, canUse ? "released" : "state_blocked");
    }

    if (Platformer.DEBUG_JETPACK && Platformer.Debug && now - this.lastDebugAt > 220) {
      this.lastDebugAt = now;
      Platformer.Debug.log(
        "Jetpack.debug",
        `grounded=${grounded} fuel=${this.fuelPercent.toFixed(0)} thrust=${this.isThrusting} vy=${Math.round(body.velocity.y)} accel=${Math.round(this.currentAccel + this.currentThrustAccel)} ramp=${this.rampAlpha.toFixed(2)} phase=${this.phase} maxUp=${Math.round(this.currentMaxUpSpeed)}`
      );
    }

    return {
      isThrusting: this.isThrusting,
      fuelPercent: this.fuelPercent,
      accelApplied: this.currentAccel + this.currentThrustAccel,
      rampAlpha: this.rampAlpha,
      phase: this.phase,
    };
  }
};
  /* <<< systems/jetpack.js */

  /* >>> level/level-1.js */
// [bundle] namespace init removed; using local Platformer namespace.
Platformer.LevelBuilders = Platformer.LevelBuilders || {};

Platformer.LevelBuilders[1] = function buildLevel1(api) {
  const { line, rect, many, manyEnemies } = api;

  // Ground with wide, readable gaps.
  line(12, 15, 17, ".");
  line(34, 37, 17, ".");
  line(58, 61, 17, ".");
  line(78, 81, 17, ".");

  // Broad patrol islands.
  rect(0, 16, 7, 16, "#");
  rect(18, 16, 25, 16, "#");
  rect(40, 16, 47, 16, "#");
  rect(64, 16, 71, 16, "#");
  rect(84, 16, 89, 16, "#");

  // Platforms.
  line(8, 13, 12, "=");
  line(23, 29, 11, "=");
  line(44, 50, 10, "=");
  line(66, 73, 9, "=");

  many([[3, 16]], "S");
  many([[27, 10], [69, 8]], "K");
  many([[10, 11], [24, 10], [28, 10], [45, 9], [49, 9], [67, 8], [72, 8], [86, 15], [88, 15], [20, 15]], "C");
  many([[25, 10], [46, 9], [68, 8], [86, 15]], "^");
  manyEnemies([[20, 16, "E"], [43, 16, "E"], [66, 16, "E"], [86, 16, "E"]]);
};

  /* <<< level/level-1.js */

  /* >>> level/level-2.js */
// [bundle] namespace init removed; using local Platformer namespace.
Platformer.LevelBuilders = Platformer.LevelBuilders || {};

Platformer.LevelBuilders[2] = function buildLevel2(api) {
  const { line, rect, many, manyEnemies } = api;

  // Vertical rooftop style with wide landing zones.
  line(14, 18, 17, ".");
  line(38, 42, 17, ".");
  line(62, 66, 17, ".");

  rect(0, 16, 10, 16, "#");
  rect(22, 16, 30, 16, "#");
  rect(46, 16, 54, 16, "#");
  rect(70, 16, 89, 16, "#");

  rect(14, 14, 18, 14, "#");
  rect(38, 13, 42, 13, "#");
  rect(62, 12, 66, 12, "#");

  line(9, 15, 12, "=");
  line(27, 34, 10, "=");
  line(49, 56, 8, "=");
  line(71, 79, 7, "=");

  many([[4, 16]], "S");
  many([[33, 9], [74, 6]], "K");
  many([[12, 11], [29, 9], [33, 9], [50, 7], [55, 7], [72, 6], [78, 6], [86, 15], [25, 15], [47, 15]], "C");
  many([[31, 9], [53, 7], [75, 6], [85, 15]], "^");
  manyEnemies([[24, 16, "F"], [48, 16, "F"], [72, 16, "F"], [84, 16, "F"]]);
};

  /* <<< level/level-2.js */

  /* >>> level/level-3.js */
// [bundle] namespace init removed; using local Platformer namespace.
Platformer.LevelBuilders = Platformer.LevelBuilders || {};

Platformer.LevelBuilders[3] = function buildLevel3(api) {
  const { line, rect, many, manyEnemies } = api;

  // Dash-pressure lanes, but no trap cracks for enemies.
  line(10, 13, 17, ".");
  line(28, 31, 17, ".");
  line(46, 49, 17, ".");
  line(64, 67, 17, ".");
  line(80, 83, 17, ".");

  rect(0, 16, 6, 16, "#");
  rect(16, 16, 23, 16, "#");
  rect(34, 16, 41, 16, "#");
  rect(52, 16, 59, 16, "#");
  rect(70, 16, 77, 16, "#");
  rect(86, 16, 89, 16, "#");

  line(7, 12, 13, "=");
  line(21, 27, 12, "=");
  line(39, 45, 11, "=");
  line(57, 63, 10, "=");
  line(75, 82, 9, "=");

  many([[2, 16]], "S");
  many([[27, 11], [77, 8]], "K");
  many([[9, 12], [23, 11], [26, 11], [40, 10], [44, 10], [58, 9], [62, 9], [76, 8], [81, 8], [88, 15]], "C");
  many([[24, 11], [42, 10], [60, 9], [78, 8]], "^");
  manyEnemies([[18, 16, "G"], [36, 16, "G"], [54, 16, "G"], [72, 16, "G"]]);
};

  /* <<< level/level-3.js */

  /* >>> level/level-4.js */
// [bundle] namespace init removed; using local Platformer namespace.
Platformer.LevelBuilders = Platformer.LevelBuilders || {};

Platformer.LevelBuilders[4] = function buildLevel4(api) {
  const { line, rect, many, manyEnemies } = api;

  // Fortress layout: layered routes, tank enemies, clean patrol lanes.
  line(12, 16, 17, ".");
  line(36, 40, 17, ".");
  line(60, 64, 17, ".");

  rect(0, 16, 8, 16, "#");
  rect(20, 16, 28, 16, "#");
  rect(44, 16, 52, 16, "#");
  rect(68, 16, 76, 16, "#");
  rect(84, 16, 89, 16, "#");

  rect(30, 14, 34, 14, "#");
  rect(54, 13, 58, 13, "#");
  rect(78, 12, 82, 12, "#");

  line(9, 16, 12, "=");
  line(26, 34, 10, "=");
  line(48, 57, 8, "=");
  line(70, 80, 7, "=");

  many([[3, 16]], "S");
  many([[32, 9], [74, 6]], "K");
  many([[11, 11], [28, 9], [33, 9], [49, 7], [56, 7], [71, 6], [79, 6], [86, 15], [22, 15], [45, 15]], "C");
  many([[30, 9], [52, 7], [75, 6], [86, 15]], "^");
  manyEnemies([[22, 16, "H"], [46, 16, "H"], [70, 16, "H"], [85, 16, "H"]]);
};

  /* <<< level/level-4.js */

  /* >>> level/level-data.js */
// [bundle] namespace init removed; using local Platformer namespace.
Platformer.LevelBuilders = Platformer.LevelBuilders || {};
Platformer.LevelJsonCache = Platformer.LevelJsonCache || {};

Platformer.createLevelData = function createLevelData(level = 1) {
  const jsonLevel = Platformer.LevelJsonCache[level] || null;
  const width = Number((jsonLevel && jsonLevel.width) || 90);
  const height = Number((jsonLevel && jsonLevel.height) || 18);
  const rows = Array.from({ length: height }, () => Array.from({ length: width }, () => "."));

  const inBounds = (x, y) => x >= 0 && x < width && y >= 0 && y < height;
  const put = (x, y, ch) => {
    if (inBounds(x, y)) rows[y][x] = ch;
  };
  const line = (x1, x2, y, ch) => {
    for (let x = x1; x <= x2; x += 1) put(x, y, ch);
  };
  const rect = (x1, y1, x2, y2, ch) => {
    for (let y = y1; y <= y2; y += 1) {
      for (let x = x1; x <= x2; x += 1) put(x, y, ch);
    }
  };
  const many = (items, ch) => items.forEach(([x, y]) => put(x, y, ch));
  const manyEnemies = (items) => items.forEach(([x, y, ch]) => put(x, y, ch));

  // Base floor.
  line(0, width - 1, height - 1, "#");

  if (jsonLevel && Array.isArray(jsonLevel.commands)) {
    jsonLevel.commands.forEach((cmd) => {
      const op = String((cmd && cmd.op) || "");
      if (op === "line") line(Number(cmd.x1), Number(cmd.x2), Number(cmd.y), String(cmd.ch || "."));
      if (op === "rect") rect(Number(cmd.x1), Number(cmd.y1), Number(cmd.x2), Number(cmd.y2), String(cmd.ch || "."));
      if (op === "many") many(Array.isArray(cmd.items) ? cmd.items : [], String(cmd.ch || "."));
      if (op === "manyEnemies") manyEnemies(Array.isArray(cmd.items) ? cmd.items : []);
    });
  } else {
    const builder = Platformer.LevelBuilders[level] || Platformer.LevelBuilders[1];
    if (builder) {
      builder({
        width,
        height,
        put,
        line,
        rect,
        many,
        manyEnemies,
      });
    }
  }

  return rows.map((r) => r.join(""));
};
  /* <<< level/level-data.js */

  /* >>> scenes/boot-scene.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.BootScene = class extends Phaser.Scene {
  constructor() {
    super("BootScene");
    this.playerIdleLoadFailed = false;
    this.playerIdleWarned = false;
  }

  preload() {
    this.load.audio("game-bgm", "assets/Slaughter to Prevail - K (mp3cut.net).mp3");
    this.load.audio("pause-bgm", "assets/Elevator Music - So Chill (mp3cut.net).mp3");
    this.load.image("player-idle-raw", "assets/IFFY_IDLE.png");
    this.load.json("ldtk-test", "assets/test.ldtk");
    this.load.spritesheet("ldtk-cavernas", "assets/Cavernas_by_Adam_Saltsman.png", {
      frameWidth: 8,
      frameHeight: 8,
    });
    this.load.json("level-1", "assets/levels/level-1.json");
    this.load.json("level-2", "assets/levels/level-2.json");
    this.load.json("level-3", "assets/levels/level-3.json");
    this.load.json("level-4", "assets/levels/level-4.json");
    this.load.json("level-5", "assets/levels/level-ldtk-test.json");
    this.load.on("loaderror", (fileObj) => {
      if (fileObj && fileObj.key === "player-idle-raw") {
        this.playerIdleLoadFailed = true;
        if (Platformer.Debug && !this.playerIdleWarned) {
          this.playerIdleWarned = true;
          Platformer.Debug.warn("BootScene.playerIdle", "Optional asset missing: assets/IFFY_IDLE.png. Using built-in fallback character.");
        }
      }
      if (fileObj && /^level-\d+$/.test(fileObj.key || "")) {
        Platformer.Debug.warn("BootScene.levels", `Level JSON missing for ${fileObj.key}; using built-in fallback.`);
      }
    });
  }

  createRectTexture(key, width, height, fillColor, borderColor = null) {
    const g = this.add.graphics();
    g.fillStyle(fillColor, 1);
    g.fillRect(0, 0, width, height);
    if (borderColor !== null) {
      g.lineStyle(2, borderColor, 1);
      g.strokeRect(1, 1, width - 2, height - 2);
    }
    g.generateTexture(key, width, height);
    g.destroy();
  }

  createCircleTexture(key, diameter, fillColor, borderColor = null) {
    const g = this.add.graphics();
    g.fillStyle(fillColor, 1);
    g.fillCircle(diameter / 2, diameter / 2, diameter / 2);
    if (borderColor !== null) {
      g.lineStyle(2, borderColor, 1);
      g.strokeCircle(diameter / 2, diameter / 2, diameter / 2 - 1);
    }
    g.generateTexture(key, diameter, diameter);
    g.destroy();
  }

  createHazardTexture(key, size, baseColor, accentColor) {
    const g = this.add.graphics();
    const s = Math.max(12, size);
    const pad = Math.max(1, Math.round(s * 0.12));
    const bodyTop = Math.max(1, Math.round(s * 0.25));
    const bodyH = Math.max(4, s - bodyTop - pad);
    const bodyW = Math.max(4, s - pad * 2);
    const mountH = Math.max(2, Math.round(s * 0.25));
    const mountY = s - mountH - 1;
    const centerX = s / 2;
    const muzzleY = Math.max(2, Math.round(s * 0.2));
    const corner = Math.max(1, Math.round(s * 0.12));

    // Base mount
    g.fillStyle(0x111827, 1);
    g.fillRoundedRect(pad, mountY, s - pad * 2, mountH, corner);

    // Turret body
    g.fillStyle(baseColor, 1);
    g.fillRoundedRect(pad + 1, bodyTop, bodyW - 2, bodyH, corner);

    // Barrel and muzzle glow
    g.fillStyle(0x1f2937, 1);
    g.fillRect(centerX - Math.max(1, s * 0.08), 1, Math.max(2, s * 0.16), Math.max(2, s * 0.24));
    g.fillStyle(accentColor, 1);
    g.fillCircle(centerX, muzzleY, Math.max(1, s * 0.12));
    g.fillStyle(0xfef08a, 0.85);
    g.fillCircle(centerX, muzzleY, Math.max(1, s * 0.06));

    // Warning chevrons
    g.fillStyle(0x450a0a, 1);
    const triY = s - Math.max(2, s * 0.12);
    const triH = Math.max(2, s * 0.15);
    g.fillTriangle(pad + 1, triY, pad + 1 + s * 0.12, triY - triH, pad + 1 + s * 0.24, triY);
    g.fillTriangle(s - pad - 1 - s * 0.24, triY, s - pad - 1 - s * 0.12, triY - triH, s - pad - 1, triY);

    g.lineStyle(Math.max(1, Math.round(s * 0.08)), 0x0b1220, 1);
    g.strokeRoundedRect(pad + 1, bodyTop, bodyW - 2, bodyH, corner);
    g.lineStyle(1, 0xe2e8f0, 0.6);
    g.strokeCircle(centerX, muzzleY, Math.max(1, s * 0.12));
    g.generateTexture(key, s, s);
    g.destroy();
  }

  drawCreatureEnemy(g, size, palette) {
    const outline = palette.outline || 0x0f172a;
    const hood = palette.body || 0x6477ff;
    const hoodDark = palette.inner || 0x4652d9;
    const face = palette.face || 0xf8fafc;
    const skin = palette.skin || 0xf4cda6;
    const eye = palette.eye || 0x020617;

    // Hood/body.
    g.fillStyle(hood, 1);
    g.fillRoundedRect(3, 7, size - 6, size - 9, 8);
    g.fillEllipse(size * 0.50, size * 0.46, size * 0.86, size * 0.82);
    g.fillTriangle(size * 0.50, 1, size * 0.36, 9, size * 0.62, 9);

    // Face area.
    g.fillStyle(face, 1);
    g.fillEllipse(size * 0.50, size * 0.52, size * 0.54, size * 0.56);

    // Eyes.
    g.fillStyle(eye, 1);
    g.fillEllipse(size * 0.37, size * 0.51, size * 0.16, size * 0.24);
    g.fillEllipse(size * 0.63, size * 0.51, size * 0.16, size * 0.24);
    g.fillStyle(0xffffff, 0.95);
    g.fillCircle(size * 0.35, size * 0.45, 1.2);
    g.fillCircle(size * 0.61, size * 0.45, 1.2);

    // Mouth/muzzle area.
    g.fillStyle(skin, 1);
    g.fillRoundedRect(size * 0.41, size * 0.60, size * 0.18, size * 0.10, 2);

    // Legs.
    g.fillStyle(hoodDark, 1);
    g.fillRoundedRect(size * 0.30, size - 8, size * 0.14, 7, 2);
    g.fillRoundedRect(size * 0.56, size - 8, size * 0.14, 7, 2);

    // Outline.
    g.lineStyle(2, outline, 1);
    g.strokeRoundedRect(3, 7, size - 6, size - 9, 8);
    g.lineStyle(2, outline, 0.95);
    g.strokeEllipse(size * 0.50, size * 0.46, size * 0.86, size * 0.82);
    g.lineStyle(1.5, outline, 0.95);
    g.strokeEllipse(size * 0.50, size * 0.52, size * 0.54, size * 0.56);
  }

  createEnemyTexture(key, size, bodyColor, accentColor) {
    const g = this.add.graphics();
    this.drawCreatureEnemy(g, size, {
      body: bodyColor,
      inner: Phaser.Display.Color.IntegerToColor(bodyColor).darken(25).color,
      face: 0xf8fafc,
      skin: 0xf4cda6,
      eye: 0x020617,
      outline: accentColor || 0x0f172a,
    });
    g.generateTexture(key, size, size);
    g.destroy();
  }

  createEnemyTextureVariant(key, size, palette) {
    const g = this.add.graphics();
    this.drawCreatureEnemy(g, size, {
      body: palette.body,
      inner: palette.inner,
      face: 0xf8fafc,
      skin: 0xf4cda6,
      eye: 0x020617,
      outline: palette.horns || 0x0f172a,
    });
    g.generateTexture(key, size, size);
    g.destroy();
  }

  createProjectileTexture(key, size) {
    const g = this.add.graphics();
    g.fillStyle(0x7f1d1d, 1);
    g.fillCircle(size / 2, size / 2, size / 2);
    g.fillStyle(0xf97316, 1);
    g.fillCircle(size / 2, size / 2, size / 2 - 2);
    g.fillStyle(0xfef08a, 1);
    g.fillCircle(size / 2 + 1, size / 2 - 1, size / 2 - 5);
    g.lineStyle(1, 0x111827, 0.8);
    g.strokeCircle(size / 2, size / 2, size / 2 - 1);
    g.generateTexture(key, size, size);
    g.destroy();
  }

  createJetpackFlameTexture(key, width, height, coreColor, glowColor) {
    const g = this.add.graphics();
    g.fillStyle(glowColor, 0.5);
    g.fillEllipse(width / 2, height * 0.46, width * 0.92, height * 0.9);
    g.fillStyle(coreColor, 0.95);
    g.fillTriangle(width * 0.5, height, width * 0.2, height * 0.36, width * 0.8, height * 0.36);
    g.fillStyle(0xfef08a, 0.9);
    g.fillTriangle(width * 0.5, height * 0.8, width * 0.36, height * 0.4, width * 0.64, height * 0.4);
    g.generateTexture(key, width, height);
    g.destroy();
  }

  createAnimeGirlTexture(key, pose) {
    const g = this.add.graphics();
    const hairColor = pose.jump ? 0xf59e0b : 0xfbbf24;
    const dressColor = pose.jump ? 0x1d4ed8 : 0x2563eb;
    const skin = 0xffddc7;

    g.fillStyle(hairColor, 1);
    g.fillEllipse(14, 10, 20, 16);
    g.fillEllipse(8, 11, 8, 8);
    g.fillEllipse(20, 11, 8, 8);

    g.fillStyle(skin, 1);
    g.fillEllipse(14, 11, 13, 12);

    g.fillStyle(0x111827, 1);
    g.fillCircle(11, pose.blink ? 11 : 10, pose.blink ? 1 : 1.6);
    g.fillCircle(17, pose.blink ? 11 : 10, pose.blink ? 1 : 1.6);

    g.lineStyle(1.5, 0xe11d48, 1);
    g.beginPath();
    g.moveTo(12, 14);
    g.lineTo(16, 14);
    g.strokePath();

    g.fillStyle(dressColor, 1);
    g.fillRoundedRect(9, 17, 10, 10, 2);

    g.fillStyle(0xffffff, 1);
    g.fillRect(11, 19, 6, 3);

    const armLeftY = pose.armLeftY ?? 21;
    const armRightY = pose.armRightY ?? 21;
    g.fillStyle(skin, 1);
    g.fillRect(6, armLeftY, 3, 8);
    g.fillRect(19, armRightY, 3, 8);

    g.fillStyle(0x0f172a, 1);
    g.fillRect(8, 27, 12, 5);

    const legLeftY = pose.legLeftY ?? 32;
    const legRightY = pose.legRightY ?? 32;
    g.fillStyle(0x111827, 1);
    g.fillRect(10, legLeftY, 3, 6);
    g.fillRect(15, legRightY, 3, 6);

    g.fillStyle(0xec4899, 1);
    g.fillRect(6, 4, 4, 2);
    g.fillRect(18, 4, 4, 2);

    g.generateTexture(key, 28, 38);
    g.destroy();
  }

  createPlayerTextures() {
    this.createAnimeGirlTexture("player-idle-1", {
      armLeftY: 21, armRightY: 21, legLeftY: 32, legRightY: 32, blink: false, jump: false,
    });
    this.createAnimeGirlTexture("player-idle-2", {
      armLeftY: 22, armRightY: 22, legLeftY: 32, legRightY: 32, blink: true, jump: false,
    });
    this.createAnimeGirlTexture("player-run-1", {
      armLeftY: 19, armRightY: 23, legLeftY: 31, legRightY: 33, blink: false, jump: false,
    });
    this.createAnimeGirlTexture("player-run-2", {
      armLeftY: 23, armRightY: 19, legLeftY: 33, legRightY: 31, blink: false, jump: false,
    });
    this.createAnimeGirlTexture("player-jump", {
      armLeftY: 17, armRightY: 17, legLeftY: 30, legRightY: 30, blink: false, jump: true,
    });
  }

  create() {
    const { TILE } = Platformer.Config;
    const cbMode = Platformer.Settings.current.accessibility.colorblindMode;
    const hazardColor = cbMode === "off" ? 0xdc2626 : (cbMode === "tritanopia" ? 0xf59e0b : 0x2563eb);
    const laserAccent = cbMode === "off" ? 0xfca5a5 : 0xfef08a;
    const coinColor = cbMode === "deuteranopia" ? 0xf9a8d4 : 0xfacc15;
    const enemyColor = cbMode === "protanopia" ? 0x22d3ee : 0xfb923c;
    const enemyFangColor = cbMode === "protanopia" ? 0xfef08a : 0xffffff;

    this.createPlayerTextures();
    this.createRectTexture("ground", TILE, TILE, 0x8b5a2b, 0x5a3a1d);
    this.createRectTexture("platform", TILE, TILE, 0x6b7280, 0x374151);
    this.createRectTexture("oneway", TILE, Math.max(3, Math.round(TILE * 0.38)), 0x38bdf8, 0x0369a1);
    this.createHazardTexture("hazard", TILE, hazardColor, laserAccent);
    this.setupPlayerIdleAnimation();
    this.createCircleTexture("coin", 16, coinColor, 0xa16207);
    this.createEnemyTexture("enemy", 24, enemyColor, enemyFangColor);
    this.createEnemyTextureVariant("enemy-e", 24, { body: 0xfb923c, inner: 0x7f1d1d, accent: 0xffffff, horns: 0xfef08a });
    this.createEnemyTextureVariant("enemy-f", 24, { body: 0x22d3ee, inner: 0x164e63, accent: 0xfef08a, horns: 0xe2e8f0 });
    this.createEnemyTextureVariant("enemy-g", 24, { body: 0xf43f5e, inner: 0x4c0519, accent: 0xfef2f2, horns: 0xfda4af });
    this.createEnemyTextureVariant("enemy-h", 24, { body: 0xa855f7, inner: 0x3b0764, accent: 0xfef08a, horns: 0xd8b4fe });
    this.createProjectileTexture("hazard-projectile", 14);
    this.createJetpackFlameTexture("jetpack-flame-1", 18, 26, 0xf97316, 0xfb7185);
    this.createJetpackFlameTexture("jetpack-flame-2", 18, 24, 0xf59e0b, 0xfacc15);
    this.createRectTexture("checkpoint", 16, 40, 0xa855f7, 0x581c87);

    this.registry.set("coins", 0);
    this.registry.set("health", 3);
    this.registry.set("lives", 2);
    this.registry.set("level", 1);
    Platformer.LevelJsonCache = {};
    [1, 2, 3, 4, 5].forEach((n) => {
      const key = `level-${n}`;
      const json = this.cache.json.get(key);
      if (json && typeof json === "object") {
        Platformer.LevelJsonCache[n] = json;
      }
    });
    if (Platformer.WorldMapManager && typeof Platformer.WorldMapManager.warmupDefault === "function") {
      Platformer.WorldMapManager.warmupDefault();
    }

    this.scene.start("MenuScene");
  }

  setupPlayerIdleAnimation() {
    if (!this.textures.exists("player-idle-raw")) {
      if (Platformer.Debug && !this.playerIdleWarned) {
        this.playerIdleWarned = true;
        const msg = this.playerIdleLoadFailed
          ? "Player idle spritesheet failed to preload. Using built-in fallback character."
          : "Player idle spritesheet not found. Using built-in fallback character.";
        Platformer.Debug.warn("BootScene.playerIdle", msg);
      }
      return;
    }

    const source = this.textures.get("player-idle-raw").getSourceImage();
    if (!source || !source.width || !source.height) {
      if (Platformer.Debug) Platformer.Debug.warn("BootScene.playerIdle", "player-idle-raw source has invalid dimensions.");
      return;
    }

    const frames = 4;
    const frameWidth = Math.floor(source.width / frames);
    const frameHeight = source.height;
    if (frameWidth < 1 || frameHeight < 1) {
      if (Platformer.Debug) Platformer.Debug.warn("BootScene.playerIdle", `Invalid frame size: ${frameWidth}x${frameHeight}`);
      return;
    }

    if (this.textures.exists("player-idle-sheet")) {
      this.textures.remove("player-idle-sheet");
    }
    this.textures.addSpriteSheet("player-idle-sheet", source, {
      frameWidth,
      frameHeight,
      endFrame: frames - 1,
    });

    if (this.anims.exists("playerIdleAnim")) {
      this.anims.remove("playerIdleAnim");
    }
    this.anims.create({
      key: "playerIdleAnim",
      frames: this.anims.generateFrameNumbers("player-idle-sheet", { start: 0, end: frames - 1 }),
      frameRate: 6,
      repeat: -1,
    });
    if (Platformer.Debug) Platformer.Debug.log("BootScene.playerIdle", `Loaded IFFY idle sheet ${source.width}x${source.height}, frames=${frames}`);
  }
};
  /* <<< scenes/boot-scene.js */

  /* >>> scenes/menu-scene.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.MenuScene = class extends Phaser.Scene {
  constructor() {
    super("MenuScene");
    this.menuMusic = null;
    this.menuMusicHtml = null;
    this.updateButton = null;
    this.updateButtonText = null;
    this.versionInfoText = null;
    this.changeButton = null;
    this.changeButtonText = null;
    this.changePanel = null;
    this.changePanelTitle = null;
    this.changePanelBody = null;
    this.changePanelOpen = false;
    this.localBuildNotes = [
      "No update details yet.",
      "",
      "Recent changes:",
      "- Live animated menu lane (runner + enemy stomps)",
      "- Menu hit feedback (red blink + knockback, non-lethal)",
      "- Menu ambient state persists after Options return",
      "- Options opens as live overlay over animated menu",
      "- Reworked Options into standalone category cards",
      "- Resize-safe Options layout and anchored back button",
      "- Stable Options scrolling with fixed action footer",
      "- Save + Back / Reset defaults always visible",
      "",
      "If online notes are available, this panel auto-refreshes from GitHub Releases.",
    ].join("\n");
    this.latestReleaseNotes = this.localBuildNotes;
    this.latestReleaseTag = "";
    this.pendingUpdateUrl = "";
    this.updateInProgress = false;
    this.bgSky = null;
    this.bgMid = null;
    this.bgGround = null;
    this.bgAccentTop = null;
    this.bgAccentBottom = null;
    this.bgOrbs = [];
    this.menuCard = null;
    this.titleText = null;
    this.titleShadow = null;
    this.comingSoonText = null;
    this.menuButtons = {};
    this.onResize = null;
    this.menuUiElements = [];
    this.menuInteractive = false;
    this.introFx = null;
    this.introParticles = null;
    this.introLines = [];
    this.introGlow = null;
    this.menuIntroInProgress = false;
    this.menuIntroUiFadeCall = null;
    this.menuIntroDoneCall = null;
    this.menuStage = null;
    this.menuRunner = null;
    this.menuRunnerFace = 1;
    this.menuRunnerGroundY = 0;
    this.menuRunnerSpeed = 82;
    this.menuRunnerJumpVy = -270;
    this.menuRunnerVy = 0;
    this.menuRunnerGravity = 700;
    this.menuRunnerJumpCooldown = 0;
    this.menuRunnerActionTimer = 0;
    this.menuRunnerDamageCooldown = 0;
    this.menuRunnerDamageFlashUntil = 0;
    this.menuEnemies = [];
    this.onSettingsChanged = null;
    this.updateStatusLockUntil = 0;
    this.lastManualUpdateAt = 0;
    this.updateManager = null;
    this.introConfig = {
      totalMs: 1800,
      uiFadeMs: 260,
      titleRevealDelayMs: 80,
      titleRevealMs: 420,
      buttonStaggerMs: 90,
      buttonMovePx: 18,
      skyColor: 0x081336,
      midColor: 0x132a56,
      groundColor: 0x0b6f49,
      glowCyan: 0x53e0ff,
      glowPink: 0xff71c7,
    };
  }

  create() {
    const textScale = Platformer.Settings.textScale();

    this.bgSky = this.add.rectangle(0, 0, 10, 10, this.introConfig.skyColor, 1).setOrigin(0, 0);
    this.bgMid = this.add.rectangle(0, 0, 10, 10, this.introConfig.midColor, 1).setOrigin(0, 0);
    this.bgGround = this.add.rectangle(0, 0, 10, 10, this.introConfig.groundColor, 1).setOrigin(0, 0);
    this.bgAccentTop = this.add.rectangle(0, 0, 10, 10, 0x1e3a8a, 0.24).setOrigin(0, 0);
    this.bgAccentBottom = this.add.rectangle(0, 0, 10, 10, 0x34d399, 0.22).setOrigin(0, 0);
    this.createPrettyBackdrop();

    this.titleShadow = this.add.text(0, 74, "ANIME PLATFORMER", {
      fontFamily: "Verdana",
      fontSize: `${Math.round(46 * textScale)}px`,
      color: "#67e8f9",
      stroke: "#020617",
      strokeThickness: 12,
    }).setOrigin(0.5).setDepth(13).setAlpha(0.26);

    this.titleText = this.add.text(0, 72, "ANIME PLATFORMER", {
      fontFamily: "Verdana",
      fontSize: `${Math.round(46 * textScale)}px`,
      color: "#f8fafc",
      stroke: "#1e293b",
      strokeThickness: 7,
    }).setOrigin(0.5).setDepth(14);
    this.onSettingsChanged = (nextSettings) => this.applyRuntimeSettings(nextSettings);
    this.game.events.on("settings-changed", this.onSettingsChanged);
    this.updateManager = new Platformer.UpdateManager(this);
    this.setupMenuMusic();

    const makeButton = (id, y, label, onClick, opts = {}) => {
      const disabled = !!opts.disabled;
      const glow = this.add.rectangle(0, y, 286, 56, 0x22d3ee, disabled ? 0.08 : 0.14)
        .setDepth(9)
        .setBlendMode(Phaser.BlendModes.ADD);
      const box = this.add.rectangle(0, y, 280, 50, disabled ? 0x475569 : 0x243b67, 0.96)
        .setStrokeStyle(3, disabled ? 0x64748b : 0x7dd3fc, 0.95)
        .setDepth(10);
      const txt = this.add.text(0, y, label, {
        fontFamily: "Consolas",
        fontSize: `${Math.round(30 * textScale)}px`,
        color: disabled ? "#cbd5e1" : "#f8fafc",
        stroke: disabled ? "#334155" : "#0f172a",
        strokeThickness: 2,
      }).setOrigin(0.5).setDepth(11);

      if (!disabled) {
        box.setInteractive({ useHandCursor: true });
        box.on("pointerover", () => {
          box.setFillStyle(0x2f4f86, 1);
          glow.setAlpha(0.26);
          this.tweens.add({ targets: [box, txt, glow], scaleX: 1.03, scaleY: 1.03, duration: 120, ease: "Sine.Out" });
        });
        box.on("pointerout", () => {
          box.setFillStyle(0x243b67, 0.96);
          glow.setAlpha(0.14);
          this.tweens.add({ targets: [box, txt, glow], scaleX: 1, scaleY: 1, duration: 120, ease: "Sine.Out" });
        });
        box.on("pointerdown", onClick);
      }

      this.menuButtons[id] = { box, txt, glow };
      return this.menuButtons[id];
    };

    const launchWorldMap = () => {
      // Keep menu BGM flowing into world map; gameplay scene will take over music.
      if (this.scene.isActive("UIScene") || this.scene.isPaused("UIScene")) this.scene.stop("UIScene");
      if (this.scene.isActive("GameScene") || this.scene.isPaused("GameScene")) this.scene.stop("GameScene");
      if (Platformer.Progress && typeof Platformer.Progress.ensureLoaded === "function") {
        Platformer.Progress.ensureLoaded();
      }
      this.scene.start("WorldMapScene");
      if (Platformer.Debug) Platformer.Debug.log("MenuScene", "Play -> WorldMapScene launched.");
    };

    const startGame = () => {
      if (!this.menuInteractive) return;
      Platformer.beeper.unlock();
      if (Platformer.Debug) Platformer.Debug.log("MenuScene", "Play clicked.");
      if (this.sound && this.sound.context && this.sound.context.state === "suspended") {
        this.sound.context.resume().catch(() => {});
      }
      launchWorldMap();
    };

    makeButton("play", 0, "PLAY", startGame);
    makeButton("continue", 0, "CONTINUE", null, { disabled: true });
    this.comingSoonText = this.add.text(0, 0, "Coming soon ^^", {
      fontFamily: "Consolas",
      fontSize: `${Math.round(17 * textScale)}px`,
      color: "#fef3c7",
      stroke: "#78350f",
      strokeThickness: 3,
    }).setOrigin(0.5).setDepth(12);

    makeButton("options", 0, "OPTIONS", () => {
      if (Platformer.Debug) Platformer.Debug.log("MenuScene", "Opening OptionsScene from menu.");
      try {
        this.scene.start("OptionsScene", { returnTo: "menu" });
        if (Platformer.Debug) Platformer.Debug.log("MenuScene.options", "OptionsScene started in dedicated mode.");
      } catch (err) {
        if (Platformer.Debug) {
          Platformer.Debug.error("MenuScene.options", err && err.stack ? err.stack : String(err));
        }
      }
    });
    makeButton("extras", 0, "EXTRA'S", () => this.showExtras());
    makeButton("exit", 0, "EXIT", () => this.handleExit());
    this.createBottomLeftVersionInfo();
    this.createMenuUpdateWidget();
    this.createWhatsChangedWidget();
    this.createMenuMiniStage();
    this.menuCard = this.add.rectangle(0, 0, 360, 390, 0x0b1731, 0.46)
      .setStrokeStyle(2, 0x7dd3fc, 0.38)
      .setDepth(8.5);
    this.collectMenuUiElements();
    const shouldPlayMenuIntro = !Platformer._menuBootIntroPlayed;
    if (shouldPlayMenuIntro) {
      Platformer._menuBootIntroPlayed = true;
      this.setMenuUiVisible(false);
      this.setMenuInteractive(false);
    } else {
      this.setMenuUiVisible(true);
      this.setMenuInteractive(true);
    }
    this.createMenuIntroFx();
    this.layoutMenu();
    this.onResize = () => {
      if (!this.sys || !this.sys.settings || !this.sys.settings.active) return;
      this.handleResize();
    };
    this.scale.on("resize", this.onResize);
    if (shouldPlayMenuIntro) this.playMenuIntro();

    this.input.keyboard.on("keydown-ENTER", startGame);
  }

  layoutMenu() {
    if (!this.sys || !this.sys.settings || !this.sys.settings.active) return;
    if (!this.bgSky || !this.bgMid || !this.bgGround) return;
    if (!this.titleText || !this.titleShadow) return;
    const w = this.scale.width;
    const h = this.scale.height;
    const cx = w / 2;
    const cy = h / 2;

    const safeRectSizePos = (obj, width, height, x, y) => {
      if (!obj || !obj.active || !obj.scene) return;
      obj.setSize(width, height).setPosition(x, y);
    };
    const safePos = (obj, x, y) => {
      if (!obj || !obj.active || !obj.scene) return;
      obj.setPosition(x, y);
    };

    try {
      safeRectSizePos(this.bgSky, w, h, 0, 0);
      safeRectSizePos(this.bgMid, w, 220, 0, cy + 160);
      safeRectSizePos(this.bgGround, w, 120, 0, cy + 220);
      safeRectSizePos(this.bgAccentTop, w, Math.round(h * 0.42), 0, 0);
      safeRectSizePos(this.bgAccentBottom, w, Math.round(h * 0.2), 0, h - Math.round(h * 0.24));
      safePos(this.titleShadow, cx, 74);
      safePos(this.titleText, cx, 72);
    } catch (err) {
      if (Platformer.Debug) {
        Platformer.Debug.warn("MenuScene.layout", `Skipping stale resize pass: ${err && err.message ? err.message : err}`);
      }
      return;
    }

    const y0 = cy - 40;
    const spacing = 60;
    const p = this.menuButtons.play;
    const c = this.menuButtons.continue;
    const o = this.menuButtons.options;
    const cr = this.menuButtons.extras;
    const e = this.menuButtons.exit;
    const place = (item, y) => {
      if (!item) return;
      if (item.glow) item.glow.setPosition(cx, y);
      item.box.setPosition(cx, y);
      item.txt.setPosition(cx, y);
    };
    place(p, y0);
    place(c, y0 + spacing);
    place(o, y0 + spacing * 2);
    place(cr, y0 + spacing * 3);
    place(e, y0 + spacing * 4);
    if (this.menuCard) this.menuCard.setPosition(cx, y0 + spacing * 2).setSize(360, 356);
    if (this.comingSoonText) this.comingSoonText.setPosition(cx + 210, y0 + spacing);

    if (this.updateButton && this.updateButtonText) {
      const ux = w - 96;
      const uy = 38;
      this.updateButton.setPosition(ux, uy);
      this.updateButtonText.setPosition(ux, uy);
    }
    if (this.changeButton && this.changeButtonText) {
      const cxRight = w - 96;
      const cyTop = 84;
      this.changeButton.setPosition(cxRight, cyTop);
      this.changeButtonText.setPosition(cxRight, cyTop);
    }
    if (this.changePanel && this.changePanelTitle && this.changePanelBody) {
      const panelW = Math.min(560, Math.max(380, Math.round(w * 0.34)));
      const panelH = Math.min(430, Math.max(240, Math.round(h * 0.5)));
      const px = w - panelW / 2 - 20;
      const py = Math.min(116 + panelH / 2, h - panelH / 2 - 20);
      this.changePanel.setSize(panelW, panelH).setPosition(px, py);
      this.changePanelTitle.setPosition(px - panelW / 2 + 16, py - panelH / 2 + 12);
      this.changePanelBody
        .setPosition(px - panelW / 2 + 16, py - panelH / 2 + 44)
        .setWordWrapWidth(panelW - 32);
    }
    if (this.versionInfoText && this.versionInfoText.active && this.versionInfoText.scene) this.versionInfoText.setPosition(14, h - 12);
    this.layoutMenuMiniStage();
    this.layoutMenuIntroFx();
  }

  createMenuMiniStage() {
    this.menuStage = this.add.container(0, 0).setDepth(7.8);

    // Invisible logical lane: runner/enemies stay inside the existing green menu band.
    const lane = this.add.rectangle(0, 0, 10, 10, 0x12815f, 0).setOrigin(0, 0.5);
    const topStrip = this.add.rectangle(0, 0, 10, 8, 0x4ade80, 0).setOrigin(0, 1);
    const laneShade = this.add.rectangle(0, 0, 10, 10, 0x0c5e45, 0).setOrigin(0, 0.5);
    this.menuStage.add([lane, topStrip]);
    this.menuStage.lane = lane;
    this.menuStage.topStrip = topStrip;
    this.menuStage.laneShade = laneShade;
    this.menuStage.add(laneShade);

    this.menuRunner = this.add.sprite(0, 0, this.textureOr("player-run-1", "player")).setDepth(8.2);
    this.menuRunner.setDisplaySize(48, 64);
    this.menuStage.add(this.menuRunner);

    this.menuEnemies = [];
    for (let i = 0; i < 4; i += 1) {
      const enemy = this.add.sprite(0, 0, this.textureOr("enemy-e", "enemy")).setDepth(8.15);
      enemy.setDisplaySize(34, 34);
      enemy.menuX = 0;
      enemy.menuDir = i % 2 === 0 ? 1 : -1;
      enemy.menuSpeed = 30 + (i * 8);
      enemy.alive = true;
      enemy.respawnAt = 0;
      this.menuEnemies.push(enemy);
      this.menuStage.add(enemy);
    }
    this.restoreMenuMiniStageState();
  }

  layoutMenuMiniStage() {
    if (!this.menuStage || !this.menuStage.lane || !this.menuStage.topStrip) return;
    const w = this.scale.width;
    const h = this.scale.height;
    const baseGroundTop = this.bgGround ? this.bgGround.y : (h - 160);
    const baseGroundH = this.bgGround ? this.bgGround.height : 120;
    const laneY = baseGroundTop + Math.round(baseGroundH * 0.44);
    const laneH = Math.max(30, Math.round(baseGroundH * 0.34));
    const margin = 26;
    const laneX = margin;
    const laneW = Math.max(280, w - margin * 2);
    this.menuRunnerGroundY = laneY - 6;

    this.menuStage.lane.setPosition(laneX, laneY).setSize(laneW, laneH);
    this.menuStage.topStrip.setPosition(laneX, laneY).setSize(laneW, 8);
    this.menuStage.laneShade.setPosition(laneX, laneY + 12).setSize(laneW, laneH - 12);

    if (this.menuRunner) {
      if (!Number.isFinite(this.menuRunner.menuX)) {
        this.menuRunner.menuX = laneX + 60;
      }
      this.menuRunner.y = this.menuRunnerGroundY;
    }

    const slot = laneW / (this.menuEnemies.length + 1);
    this.menuEnemies.forEach((enemy, idx) => {
      if (!enemy) return;
      if (!enemy.alive && this.time.now < enemy.respawnAt) return;
      enemy.alive = true;
      enemy.menuX = laneX + slot * (idx + 1) + Phaser.Math.Between(-26, 26);
      enemy.y = this.menuRunnerGroundY + 2;
      enemy.setVisible(true);
      enemy.setAlpha(1);
    });
  }

  restoreMenuMiniStageState() {
    const s = Platformer._menuAmbientState;
    if (!s) return;
    if (this.menuRunner && Number.isFinite(s.runnerX)) {
      this.menuRunner.menuX = s.runnerX;
      this.menuRunner.y = Number.isFinite(s.runnerY) ? s.runnerY : this.menuRunnerGroundY;
      this.menuRunnerFace = s.runnerFace === -1 ? -1 : 1;
      this.menuRunnerVy = Number.isFinite(s.runnerVy) ? s.runnerVy : 0;
      this.menuRunnerJumpCooldown = Number.isFinite(s.runnerJumpCooldown) ? s.runnerJumpCooldown : 0;
      this.menuRunnerDamageCooldown = Number.isFinite(s.runnerDamageCooldown) ? s.runnerDamageCooldown : 0;
      this.menuRunnerActionTimer = Number.isFinite(s.runnerActionTimer) ? s.runnerActionTimer : 0;
    }
    if (Array.isArray(s.enemies) && this.menuEnemies && this.menuEnemies.length) {
      this.menuEnemies.forEach((enemy, idx) => {
        const se = s.enemies[idx];
        if (!enemy || !se) return;
        enemy.menuX = Number.isFinite(se.x) ? se.x : enemy.menuX;
        enemy.menuDir = se.dir === -1 ? -1 : 1;
        enemy.alive = se.alive !== false;
        enemy.respawnAt = Number.isFinite(se.respawnAt) ? se.respawnAt : 0;
        enemy.setVisible(enemy.alive);
        if (enemy.alive) {
          enemy.setAlpha(1);
          enemy.setScale(1, 1);
        }
      });
    }
  }

  saveMenuMiniStageState() {
    Platformer._menuAmbientState = {
      runnerX: this.menuRunner && Number.isFinite(this.menuRunner.menuX) ? this.menuRunner.menuX : null,
      runnerY: this.menuRunner ? this.menuRunner.y : null,
      runnerFace: this.menuRunnerFace,
      runnerVy: this.menuRunnerVy,
      runnerJumpCooldown: this.menuRunnerJumpCooldown,
      runnerDamageCooldown: this.menuRunnerDamageCooldown,
      runnerActionTimer: this.menuRunnerActionTimer,
      enemies: (this.menuEnemies || []).map((enemy) => ({
        x: enemy && Number.isFinite(enemy.menuX) ? enemy.menuX : null,
        dir: enemy && enemy.menuDir === -1 ? -1 : 1,
        alive: !!(enemy && enemy.alive),
        respawnAt: enemy && Number.isFinite(enemy.respawnAt) ? enemy.respawnAt : 0,
      })),
    };
  }

  handleResize() {
    if (!this.sys || !this.sys.settings || !this.sys.settings.active) return;
    this.layoutMenu();
    if (this.menuIntroInProgress) {
      this.forceCompleteMenuIntro();
    }
  }

  createMenuUpdateWidget() {
    const x = this.scale.width - 96;
    const y = 38;
    this.updateButton = this.add.rectangle(x, y, 160, 38, 0x334155, 0.95)
      .setStrokeStyle(2, 0x67e8f9, 0.95)
      .setDepth(20)
      .setInteractive({ useHandCursor: true });
    this.updateButtonText = this.add.text(x, y, "Update", {
      fontFamily: "Consolas",
      fontSize: "22px",
      color: "#f8fafc",
    }).setOrigin(0.5).setDepth(21);
    this.updateButton.on("pointerover", () => this.updateButton.setFillStyle(0x3b4f73, 0.98));
    this.updateButton.on("pointerout", () => this.updateButton.setFillStyle(0x334155, 0.95));
    this.updateButton.on("pointerdown", async () => {
      if (!this.updateManager) {
        if (Platformer.Debug) Platformer.Debug.error("MenuScene.update", "UpdateManager missing.");
        this.setBottomLeftUpdateStatus("Update system unavailable.", true);
        return;
      }
      await this.updateManager.handleUpdateClick();
    });

    this.time.delayedCall(100, () => this.autoCheckUpdatesForBottomLeft());
  }

  async startInAppUpdate(downloadUrl, startMessage = "Preparing update...") {
    if (!this.updateManager) {
      return { ok: false, message: "Update manager unavailable." };
    }
    return this.updateManager.startInAppUpdate(downloadUrl, startMessage);
  }

  createBottomLeftVersionInfo() {
    const currentVersion = ((Platformer.Settings.current.updates || {}).currentVersion || "1.0.0").trim();
    this.versionInfoStyle = {
      fontFamily: "Consolas",
      fontSize: "18px",
      color: "#e2e8f0",
      stroke: "#0f172a",
      strokeThickness: 4,
      align: "left",
    };
    this.ensureVersionInfoText();

    this.setBottomLeftUpdateStatus("Checking for updates...");
    this.safeSetText(this.versionInfoText, `Version: ${currentVersion}\nUpdate: Checking for updates...`, "versionInfoText");
  }

  ensureVersionInfoText() {
    if (this.versionInfoText && this.versionInfoText.active && this.versionInfoText.scene === this) {
      this.versionInfoText.setPosition(14, this.scale.height - 12);
      return this.versionInfoText;
    }
    if (!this.sys || !this.sys.settings || !this.sys.settings.active) return null;
    try {
      this.versionInfoText = this.add.text(14, this.scale.height - 12, "", this.versionInfoStyle || {
        fontFamily: "Consolas",
        fontSize: "18px",
        color: "#e2e8f0",
        stroke: "#0f172a",
        strokeThickness: 4,
        align: "left",
      }).setOrigin(0, 1).setDepth(25);
      return this.versionInfoText;
    } catch (err) {
      if (Platformer.Debug) {
        Platformer.Debug.warn("MenuScene.text", `ensureVersionInfoText failed: ${err && err.message ? err.message : err}`);
      }
      return null;
    }
  }

  safeSetText(target, text, label = "text") {
    if (!target || !target.active || !target.scene) return false;
    if (!this.sys || !this.sys.settings || !this.sys.settings.active) return false;
    try {
      target.setText(String(text));
      return true;
    } catch (err) {
      if (Platformer.Debug) {
        Platformer.Debug.warn("MenuScene.text", `setText failed (${label}): ${err && err.message ? err.message : err}`);
      }
      if (target === this.versionInfoText) {
        const rebuilt = this.ensureVersionInfoText();
        if (rebuilt && rebuilt !== target) {
          try {
            rebuilt.setText(String(text));
            return true;
          } catch (err2) {
            if (Platformer.Debug) {
              Platformer.Debug.warn("MenuScene.text", `setText retry failed (${label}): ${err2 && err2.message ? err2.message : err2}`);
            }
          }
        }
      }
      return false;
    }
  }

  setBottomLeftUpdateStatus(statusText, sticky = false) {
    if (!this.sys || !this.sys.settings || !this.sys.settings.active) return;
    if (!sticky && this.time && this.time.now < this.updateStatusLockUntil) return;
    if (sticky && this.time) this.updateStatusLockUntil = this.time.now + 8000;
    if (!this.ensureVersionInfoText()) return;
    const currentVersion = ((Platformer.Settings.current.updates || {}).currentVersion || "1.0.0").trim();
    const safeStatus = statusText || "Unknown";
    this.safeSetText(this.versionInfoText, `Version: ${currentVersion}\nUpdate: ${safeStatus}`, "bottomLeftStatus");
  }

  async autoCheckUpdatesForBottomLeft() {
    if (!this.updateManager) return;
    await this.updateManager.autoCheck();
  }

  createWhatsChangedWidget() {
    const x = this.scale.width - 96;
    const y = 84;
    this.changeButton = this.add.rectangle(x, y, 160, 34, 0x1e293b, 0.95)
      .setStrokeStyle(2, 0x67e8f9, 0.95)
      .setDepth(20)
      .setInteractive({ useHandCursor: true });
    this.changeButtonText = this.add.text(x, y, "What's Changed", {
      fontFamily: "Consolas",
      fontSize: "18px",
      color: "#e2e8f0",
    }).setOrigin(0.5).setDepth(21);

    this.changePanel = this.add.rectangle(0, 0, 480, 290, 0x0f172a, 0.92)
      .setStrokeStyle(2, 0x67e8f9)
      .setDepth(22)
      .setVisible(false);
    this.changePanelTitle = this.add.text(0, 0, "What's Changed", {
      fontFamily: "Consolas",
      fontSize: "20px",
      color: "#f8fafc",
    }).setOrigin(0, 0).setDepth(23).setVisible(false);
    this.changePanelBody = this.add.text(0, 0, this.latestReleaseNotes, {
      fontFamily: "Consolas",
      fontSize: "15px",
      color: "#cbd5e1",
      align: "left",
      wordWrap: { width: 440, useAdvancedWrap: true },
    }).setOrigin(0, 0).setDepth(23).setVisible(false);

    this.changeButton.on("pointerover", () => this.changeButton.setFillStyle(0x334155, 0.98));
    this.changeButton.on("pointerout", () => this.changeButton.setFillStyle(0x1e293b, 0.95));
    this.changeButton.on("pointerdown", () => {
      this.changePanelOpen = !this.changePanelOpen;
      const on = this.changePanelOpen;
      this.changePanel.setVisible(on);
      this.changePanelTitle.setVisible(on);
      this.changePanelBody.setVisible(on);
      if (on) {
        this.changeButtonText.setText("Hide Changes");
      } else {
        this.changeButtonText.setText("What's Changed");
      }
    });
  }

  collectMenuUiElements() {
    this.menuUiElements = [];
    if (this.titleText) this.menuUiElements.push(this.titleText);
    if (this.titleShadow) this.menuUiElements.push(this.titleShadow);
    if (this.menuCard) this.menuUiElements.push(this.menuCard);
    Object.values(this.menuButtons).forEach((b) => {
      if (b && b.glow) this.menuUiElements.push(b.glow);
      if (b && b.box) this.menuUiElements.push(b.box);
      if (b && b.txt) this.menuUiElements.push(b.txt);
    });
    if (this.comingSoonText) this.menuUiElements.push(this.comingSoonText);
    if (this.updateButton) this.menuUiElements.push(this.updateButton);
    if (this.updateButtonText) this.menuUiElements.push(this.updateButtonText);
    if (this.changeButton) this.menuUiElements.push(this.changeButton);
    if (this.changeButtonText) this.menuUiElements.push(this.changeButtonText);
    if (this.changePanel) this.menuUiElements.push(this.changePanel);
    if (this.changePanelTitle) this.menuUiElements.push(this.changePanelTitle);
    if (this.changePanelBody) this.menuUiElements.push(this.changePanelBody);
    if (this.versionInfoText) this.menuUiElements.push(this.versionInfoText);
  }

  setMenuUiVisible(visible) {
    const a = visible ? 1 : 0;
    this.menuUiElements.forEach((el) => {
      if (!el || !el.active) return;
      el.setAlpha(a);
      if (this.changePanelOpen && (el === this.changePanel || el === this.changePanelTitle || el === this.changePanelBody)) {
        el.setVisible(visible);
      }
    });
  }

  setMenuInteractive(enabled) {
    this.menuInteractive = !!enabled;
    const interactiveIds = ["play", "options", "extras", "exit"];
    interactiveIds.forEach((id) => {
      const b = this.menuButtons[id];
      if (!b || !b.box) return;
      if (enabled) b.box.setInteractive({ useHandCursor: true });
      else b.box.disableInteractive();
    });
    if (this.updateButton) {
      if (enabled) this.updateButton.setInteractive({ useHandCursor: true });
      else this.updateButton.disableInteractive();
    }
    if (this.changeButton) {
      if (enabled) this.changeButton.setInteractive({ useHandCursor: true });
      else this.changeButton.disableInteractive();
    }
  }

  ensureMenuIntroTextures() {
    if (!this.textures.exists("menu-intro-dot")) {
      const g = this.make.graphics({ x: 0, y: 0, add: false });
      g.fillStyle(0xffffff, 1);
      g.fillCircle(4, 4, 4);
      g.generateTexture("menu-intro-dot", 8, 8);
      g.destroy();
    }
    if (!this.textures.exists("menu-intro-line")) {
      const g = this.make.graphics({ x: 0, y: 0, add: false });
      g.fillStyle(0xffffff, 1);
      g.fillRect(0, 0, 140, 2);
      g.generateTexture("menu-intro-line", 140, 2);
      g.destroy();
    }
  }

  createMenuIntroFx() {
    this.ensureMenuIntroTextures();
    const w = this.scale.width;
    const h = this.scale.height;
    this.introFx = this.add.container(0, 0).setDepth(9);
    this.introLines = [];

    for (let i = 0; i < 12; i += 1) {
      const isPink = i % 3 === 0;
      const line = this.add.image(
        Phaser.Math.Between(0, w),
        Phaser.Math.Between(40, h - 80),
        "menu-intro-line"
      )
        .setOrigin(0, 0.5)
        .setTint(isPink ? this.introConfig.glowPink : this.introConfig.glowCyan)
        .setAlpha(isPink ? 0.18 : 0.24)
        .setBlendMode(Phaser.BlendModes.SCREEN);
      line.introSpeed = Phaser.Math.FloatBetween(38, 90);
      line.introParallax = Phaser.Math.FloatBetween(0.3, 1);
      this.introLines.push(line);
      this.introFx.add(line);
    }

    this.introParticles = this.add.particles(0, 0, "menu-intro-dot", {
      x: { min: 0, max: w },
      y: { min: 0, max: h * 0.72 },
      lifespan: { min: 1500, max: 3600 },
      speedX: { min: -8, max: 8 },
      speedY: { min: -36, max: -10 },
      scale: { start: 0.55, end: 0 },
      alpha: { start: 0.36, end: 0 },
      tint: [this.introConfig.glowCyan, this.introConfig.glowPink, 0xffffff],
      blendMode: "ADD",
      frequency: 90,
      quantity: 1,
    }).setDepth(10);
  }

  layoutMenuIntroFx() {
    if (!this.introParticles) return;
    const w = this.scale.width;
    const h = this.scale.height;
    this.introParticles.setConfig({
      x: { min: 0, max: w },
      y: { min: 0, max: h * 0.72 },
    });
  }

  playMenuIntro() {
    if (!this.titleText) return;
    this.menuIntroInProgress = true;

    this.titleText.setAlpha(0).setScale(0.94).setY(42);
    this.cameras.main.fadeIn(520, 0, 0, 0);

    this.tweens.add({
      targets: this.titleText,
      delay: this.introConfig.titleRevealDelayMs,
      y: 72,
      alpha: 1,
      scaleX: 1,
      scaleY: 1,
      ease: "Cubic.Out",
      duration: this.introConfig.titleRevealMs,
    });

    this.introGlow = this.add.circle(this.scale.width / 2, 86, 220, this.introConfig.glowCyan, 0.08)
      .setBlendMode(Phaser.BlendModes.ADD)
      .setDepth(13);
    this.tweens.add({
      targets: this.introGlow,
      alpha: { from: 0.15, to: 0.03 },
      scale: { from: 0.8, to: 1.14 },
      ease: "Sine.InOut",
      yoyo: true,
      repeat: -1,
      duration: 2200,
    });

    const orderedButtons = ["play", "continue", "options", "extras", "exit"]
      .map((id) => this.menuButtons[id])
      .filter((b) => !!b);
    const buttonTargets = [];
    orderedButtons.forEach((b) => {
      if (b.glow) buttonTargets.push(b.glow);
      if (b.box) buttonTargets.push(b.box);
      if (b.txt) buttonTargets.push(b.txt);
    });

    buttonTargets.forEach((obj) => {
      obj.y += this.introConfig.buttonMovePx;
      obj.setAlpha(0);
    });

    const titleEndAt = this.introConfig.titleRevealDelayMs + this.introConfig.titleRevealMs;
    orderedButtons.forEach((b, idx) => {
      const delay = titleEndAt + idx * this.introConfig.buttonStaggerMs;
      this.tweens.add({
        targets: [b.box, b.txt].filter(Boolean),
        y: `-=${this.introConfig.buttonMovePx}`,
        alpha: 1,
        duration: this.introConfig.uiFadeMs,
        ease: "Cubic.Out",
        delay,
      });
    });

    const remainingUi = this.menuUiElements.filter((el) => {
      if (el === this.titleText) return false;
      if (buttonTargets.includes(el)) return false;
      return true;
    });
    this.menuIntroUiFadeCall = this.time.delayedCall(titleEndAt + orderedButtons.length * this.introConfig.buttonStaggerMs - 40, () => {
      this.tweens.add({
        targets: remainingUi,
        alpha: 1,
        duration: this.introConfig.uiFadeMs,
        ease: "Sine.Out",
      });
    });

    this.menuIntroDoneCall = this.time.delayedCall(this.introConfig.totalMs, () => {
      this.menuIntroInProgress = false;
      this.setMenuInteractive(true);
      if (Platformer.Debug) Platformer.Debug.log("MenuScene", "Menu intro complete. UI interactive.");
    });
  }

  forceCompleteMenuIntro() {
    if (!this.menuIntroInProgress) return;
    this.menuIntroInProgress = false;

    if (this.menuIntroUiFadeCall) this.menuIntroUiFadeCall.remove(false);
    if (this.menuIntroDoneCall) this.menuIntroDoneCall.remove(false);
    this.menuIntroUiFadeCall = null;
    this.menuIntroDoneCall = null;

    const targets = [
      this.titleText,
      this.titleShadow,
      this.menuCard,
      this.comingSoonText,
      this.updateButton,
      this.updateButtonText,
      this.changeButton,
      this.changeButtonText,
      this.changePanel,
      this.changePanelTitle,
      this.changePanelBody,
      this.versionInfoText,
    ];
    Object.values(this.menuButtons).forEach((b) => {
      if (!b) return;
      targets.push(b.glow, b.box, b.txt);
    });
    this.tweens.killTweensOf(targets.filter(Boolean));
    if (this.introGlow) this.tweens.killTweensOf(this.introGlow);

    this.layoutMenu();
    this.setMenuUiVisible(true);
    this.setMenuInteractive(true);
    if (Platformer.Debug) Platformer.Debug.warn("MenuScene", "Intro auto-completed due to resize.");
  }

  createPrettyBackdrop() {
    const w = this.scale.width;
    const h = this.scale.height;
    const orbA = this.add.circle(w * 0.78, h * 0.22, 150, this.introConfig.glowCyan, 0.11)
      .setBlendMode(Phaser.BlendModes.ADD)
      .setDepth(2);
    const orbB = this.add.circle(w * 0.2, h * 0.3, 110, this.introConfig.glowPink, 0.1)
      .setBlendMode(Phaser.BlendModes.ADD)
      .setDepth(2);
    this.bgOrbs = [orbA, orbB];
    this.bgOrbs.forEach((orb, idx) => {
      this.tweens.add({
        targets: orb,
        alpha: { from: orb.alpha * 0.8, to: orb.alpha * 1.35 },
        scale: { from: 0.88 + idx * 0.08, to: 1.12 + idx * 0.12 },
        duration: 2800 + idx * 800,
        yoyo: true,
        repeat: -1,
        ease: "Sine.InOut",
      });
    });
  }

  normalizeReleaseNotes(rawText) {
    const text = String(rawText || "").replace(/\r/g, "").trim();
    const isPlaceholder = text.toLowerCase() === "none" || text.toLowerCase() === "null" || text === "-";
    if (!text || isPlaceholder) {
      return "Changelog unavailable for this check.\n\nOpen GitHub Releases for full patch notes.";
    }

    const withoutTail = text
      .replace(/\*\*?\s*full\s*changelog\s*\*?\s*:?\s*[\s\S]*$/i, "")
      .replace(/full\s*changelog\s*:?\s*[\s\S]*$/i, "")
      .trim();

    const lines = withoutTail
      .split("\n")
      .filter((line) => !/full\s*changelog/i.test(line))
      .filter((line) => !/github\.com\/.+\/compare\//i.test(line))
      .filter((line) => !/github\.com\/.+\/releases\/download\//i.test(line))
      .filter((line) => !/^\s*https?:\/\/\S+\s*$/i.test(line))
      .map((line) => line.replace(/https?:\/\/\S+/g, ""))
      .map((line) => line.length > 68 ? `${line.slice(0, 68)}...` : line)
      .filter((line) => line.trim().length > 0);

    const compact = lines.join("\n").trim();
    const capped = compact.length > 460 ? `${compact.slice(0, 460)}\n...` : compact;
    return capped || "Changelog unavailable for this check.\n\nOpen GitHub Releases for full patch notes.";
  }

  parseVersionParts(versionText) {
    return String(versionText || "")
      .split(".")
      .map((p) => Number(p))
      .filter((n) => Number.isFinite(n));
  }

  compareVersions(aText, bText) {
    const a = this.parseVersionParts(aText);
    const b = this.parseVersionParts(bText);
    const len = Math.max(a.length, b.length);
    for (let i = 0; i < len; i += 1) {
      const av = Number.isFinite(a[i]) ? a[i] : 0;
      const bv = Number.isFinite(b[i]) ? b[i] : 0;
      if (av > bv) return 1;
      if (av < bv) return -1;
    }
    return 0;
  }

  setLatestChangesFromResult(result) {
    if (!result) return;
    const currentBuild = ((Platformer.BUILD_VERSION && String(Platformer.BUILD_VERSION).trim()) || "1.0.0");
    const v = result.latestVersion ? String(result.latestVersion) : "";
    const staleRemote = !v || this.compareVersions(v, currentBuild) < 0;
    if (staleRemote) {
      this.latestReleaseTag = currentBuild;
      this.latestReleaseNotes = `Release ${currentBuild}\n\n${this.localBuildNotes}`;
      if (this.changePanelBody) this.changePanelBody.setText(this.latestReleaseNotes);
      return;
    }
    const notes = this.normalizeReleaseNotes(result.releaseNotes || "");
    this.latestReleaseTag = v;
    this.latestReleaseNotes = v ? `Release ${v}\n\n${notes}` : notes;
    if (this.changePanelBody) this.changePanelBody.setText(this.latestReleaseNotes);
  }

  showExtras() {
    if (Platformer.Debug) Platformer.Debug.log("MenuScene", "Extras opened.");
    try {
      this.scene.start("ExtrasScene");
    } catch (err) {
      if (Platformer.Debug) {
        Platformer.Debug.error("MenuScene.extras", err && err.stack ? err.stack : String(err));
      }
    }
  }

  handleExit() {
    if (Platformer.Debug) Platformer.Debug.log("MenuScene", "Exit requested.");
    if (window.pywebview && window.pywebview.api && typeof window.pywebview.api.exit_app === "function") {
      window.pywebview.api.exit_app();
      return;
    }

    const hint = this.add.text(this.scale.width / 2, this.scale.height - 36,
      "Exit is disabled in browser. Close tab/window.", {
        fontFamily: "Consolas",
        fontSize: "20px",
        color: "#0f172a",
        stroke: "#f8fafc",
        strokeThickness: 4,
      }
    ).setOrigin(0.5);

    this.time.delayedCall(2200, () => hint.destroy());
  }

  setupMenuMusic() {
    const settings = Platformer.Settings.current.audio;
    const volume = (settings.master / 100) * (settings.music / 100);
    if (Platformer.Debug) {
      Platformer.Debug.log(
        "MenuScene.audio",
        `setupMenuMusic master=${settings.master} music=${settings.music} volume=${volume.toFixed(2)} muted=${this.sound && this.sound.mute ? "yes" : "no"} hidden=${document.hidden ? "yes" : "no"}`
      );
      if (volume <= 0.001) {
        Platformer.Debug.warn("MenuScene.audio", "Effective music volume is 0. Increase Master/Music volume in Options.");
      }
    }

    this.sound.stopByKey("pause-bgm");
    if (Platformer.pauseMusicHtml) {
      Platformer.pauseMusicHtml.pause();
      Platformer.pauseMusicHtml.currentTime = 0;
      Platformer.pauseMusicHtml = null;
    }

    if (Platformer.gameMusic) {
      Platformer.gameMusic.stop();
      Platformer.gameMusic = null;
    }
    if (Platformer.gameMusicHtml) {
      Platformer.gameMusicHtml.pause();
      Platformer.gameMusicHtml.currentTime = 0;
      Platformer.gameMusicHtml = null;
    }

    const wirePlayback = () => {
      this.menuMusic = this.sound.get("menu-bgm");
      if (!this.menuMusic) {
        try {
          this.menuMusic = this.sound.add("menu-bgm", { loop: true, volume });
          if (Platformer.Debug) Platformer.Debug.log("MenuScene.audio", "Created menu-bgm sound instance.");
        } catch (_e) {
          if (Platformer.Debug) Platformer.Debug.warn("MenuScene.audio", "Failed to create menu-bgm sound instance.");
          return;
        }
      } else {
        this.menuMusic.setVolume(volume);
        this.menuMusic.setLoop(true);
        if (Platformer.Debug) Platformer.Debug.log("MenuScene.audio", "Reusing existing menu-bgm instance.");
      }

      const tryPlay = () => {
        if (!this.menuMusic) return;
        if (settings.muteWhenUnfocused && document.hidden) return;
        if (this.menuMusic.isPlaying) return;
        try {
          if (this.sound && this.sound.context && this.sound.context.state === "suspended") {
            this.sound.context.resume().catch(() => {});
            if (Platformer.Debug) Platformer.Debug.warn("MenuScene.audio", "WebAudio context suspended; resume requested.");
          }
          this.menuMusic.play();
          if (Platformer.Debug) Platformer.Debug.log("MenuScene.audio", "Playing menu-bgm (Phaser).");
        } catch (_e) {
          // Autoplay restrictions are expected; user input handler below retries.
          if (Platformer.Debug) Platformer.Debug.warn("MenuScene.audio", "menu-bgm play blocked; waiting for next input.");
        }
      };

      this.input.once("pointerdown", tryPlay);
      this.input.keyboard.once("keydown", tryPlay);
      tryPlay();
    };

    // If HTML fallback is already active, just update its volume and keep playing.
    if (Platformer.menuMusicHtml) {
      this.menuMusicHtml = Platformer.menuMusicHtml;
      this.menuMusicHtml.volume = Phaser.Math.Clamp(volume, 0, 1);
      if (Platformer.Debug) Platformer.Debug.log("MenuScene.audio", "Using existing HTML menu music instance.");
      return;
    }

    if (this.cache.audio.exists("menu-bgm")) {
      wirePlayback();
      return;
    }

    this.load.audio("menu-bgm", "assets/nickpanek-energetic-chiptune-video-game-music-platformer-8-bit-318348.mp3");
    this.load.once("complete", wirePlayback);
    this.load.once("loaderror", () => {
      if (Platformer.Debug) Platformer.Debug.warn("MenuScene.audio", "menu-bgm loaderror; switching to HTML fallback.");
      this.setupHtmlAudioFallback(volume, settings);
    });
    this.load.start();
    this.time.delayedCall(1300, () => {
      if (!this.sys || !this.sys.settings || !this.sys.settings.active) return;
      const phaserPlaying = !!(this.menuMusic && this.menuMusic.isPlaying);
      const htmlPlaying = !!(Platformer.menuMusicHtml && !Platformer.menuMusicHtml.paused);
      if (!phaserPlaying && !htmlPlaying && Platformer.Debug) {
        Platformer.Debug.warn("MenuScene.audio", "No menu music is currently playing after startup.");
      }
    });
  }

  applyRuntimeSettings(nextSettings) {
    try {
      const settings = nextSettings || Platformer.Settings.current || {};
      const audio = settings.audio || { master: 80, music: 60, muteWhenUnfocused: false };
      const volume = Phaser.Math.Clamp((Number(audio.master) / 100) * (Number(audio.music) / 100), 0, 1);
      if (this.menuMusic) {
        this.menuMusic.setVolume(volume);
      }
      if (this.menuMusicHtml) {
        this.menuMusicHtml.volume = volume;
      }
      if (Platformer.menuMusicHtml) {
        Platformer.menuMusicHtml.volume = volume;
      }
      if (audio.muteWhenUnfocused && document.hidden) {
        if (Platformer.menuMusicHtml && !Platformer.menuMusicHtml.paused) {
          Platformer.menuMusicHtml.pause();
        }
      }
      if (Platformer.Debug) {
        Platformer.Debug.log("MenuScene.settings", `Applied runtime settings: menuVolume=${volume.toFixed(2)}`);
      }
    } catch (err) {
      if (Platformer.Debug) {
        Platformer.Debug.error("MenuScene.settings", err && err.stack ? err.stack : String(err));
      }
    }
  }

  setupHtmlAudioFallback(volume, settings) {
    try {
      if (Platformer.menuMusicHtml) {
        this.menuMusicHtml = Platformer.menuMusicHtml;
        this.menuMusicHtml.volume = Phaser.Math.Clamp(volume, 0, 1);
        if (Platformer.Debug) Platformer.Debug.log("MenuScene.audio", "Reusing HTML fallback music instance.");
        return;
      }

      this.menuMusicHtml = new Audio("assets/nickpanek-energetic-chiptune-video-game-music-platformer-8-bit-318348.mp3");
      Platformer.menuMusicHtml = this.menuMusicHtml;
      this.menuMusicHtml.loop = true;
      this.menuMusicHtml.volume = Phaser.Math.Clamp(volume, 0, 1);

      const tryPlay = () => {
        if (!this.menuMusicHtml) return;
        if (settings.muteWhenUnfocused && document.hidden) return;
        this.menuMusicHtml.play()
          .then(() => {
            if (Platformer.Debug) Platformer.Debug.log("MenuScene.audio", "Playing menu-bgm (HTML fallback).");
          })
          .catch((err) => {
            if (Platformer.Debug) Platformer.Debug.warn("MenuScene.audio", `HTML fallback play blocked: ${err && err.message ? err.message : err}`);
          });
      };

      this.input.once("pointerdown", tryPlay);
      this.input.keyboard.once("keydown", tryPlay);
      tryPlay();
    } catch (_e) {
      // Keep menu functional with no music.
      if (Platformer.Debug) Platformer.Debug.error("MenuScene.audio", "HTML fallback setup failed.");
    }
  }

  stopMenuMusic() {
    if (Platformer.Debug) Platformer.Debug.log("MenuScene.audio", "Stopping menu music.");
    if (this.menuMusic && this.menuMusic.isPlaying) {
      this.menuMusic.stop();
    }
    if (this.menuMusicHtml) {
      this.menuMusicHtml.pause();
      this.menuMusicHtml.currentTime = 0;
      this.menuMusicHtml = null;
    }
    if (Platformer.menuMusicHtml) {
      Platformer.menuMusicHtml.pause();
      Platformer.menuMusicHtml.currentTime = 0;
      Platformer.menuMusicHtml = null;
    }
  }

  update(_time, delta) {
    if (!this.introLines || this.introLines.length === 0) return;
    const w = this.scale.width;
    const dt = Math.max(0.001, delta / 1000);
    this.introLines.forEach((line) => {
      if (!line || !line.active) return;
      line.x -= line.introSpeed * line.introParallax * dt;
      if (line.x < -line.width - 10) {
        line.x = w + Phaser.Math.Between(10, 80);
      }
    });
    const t = _time * 0.001;
    if (this.bgOrbs && this.bgOrbs.length === 2) {
      this.bgOrbs[0].x = this.scale.width * 0.78 + Math.cos(t * 0.6) * 16;
      this.bgOrbs[1].x = this.scale.width * 0.2 + Math.sin(t * 0.75) * 18;
    }
    this.updateMenuMiniStage(delta);
  }

  updateMenuMiniStage(delta) {
    if (!this.menuRunner || !this.menuStage || !this.menuStage.lane) return;
    const dt = Math.max(0.001, delta / 1000);
    const lane = this.menuStage.lane;
    const minX = lane.x + 26;
    const maxX = lane.x + lane.width - 26;

    if (!Number.isFinite(this.menuRunner.menuX)) this.menuRunner.menuX = minX + 40;
    this.menuRunner.menuX += this.menuRunnerFace * this.menuRunnerSpeed * dt;
    if (this.menuRunner.menuX <= minX) {
      this.menuRunner.menuX = minX;
      this.menuRunnerFace = 1;
    } else if (this.menuRunner.menuX >= maxX) {
      this.menuRunner.menuX = maxX;
      this.menuRunnerFace = -1;
    }

    this.menuRunnerJumpCooldown -= delta;
    this.menuRunnerDamageCooldown -= delta;
    this.menuRunnerActionTimer -= delta;
    const target = this.menuEnemies.find((e) => {
      if (!e || !e.alive) return false;
      const dx = e.menuX - this.menuRunner.menuX;
      if (Math.abs(dx) > 120) return false;
      return dx * this.menuRunnerFace > 0;
    });
    const grounded = this.menuRunner.y >= this.menuRunnerGroundY - 0.5;
    const freestyleJump = grounded && this.menuRunnerActionTimer <= 0 && this.menuRunnerJumpCooldown <= 0 && Phaser.Math.Between(0, 100) < 12;
    if ((target || freestyleJump) && grounded && this.menuRunnerJumpCooldown <= 0) {
      this.menuRunnerVy = this.menuRunnerJumpVy;
      this.menuRunnerJumpCooldown = target ? 520 : 900;
      this.menuRunnerActionTimer = Phaser.Math.Between(650, 1300);
    }

    this.menuRunnerVy += this.menuRunnerGravity * dt;
    this.menuRunner.y += this.menuRunnerVy * dt;
    if (this.menuRunner.y > this.menuRunnerGroundY) {
      this.menuRunner.y = this.menuRunnerGroundY;
      this.menuRunnerVy = 0;
    }

    this.menuRunner.setFlipX(this.menuRunnerFace < 0);
    if (this.menuRunnerVy < -30) this.menuRunner.setTexture(this.textureOr("player-jump", "player"));
    else if (this.menuRunnerVy > 70 && this.menuRunner.y < this.menuRunnerGroundY) this.menuRunner.setTexture(this.textureOr("player-jump", "player"));
    else this.menuRunner.setTexture(this.textureOr(Math.floor(this.time.now / 130) % 2 === 0 ? "player-run-1" : "player-run-2", "player"));
    this.menuRunner.x = this.menuRunner.menuX;
    if (this.time.now < this.menuRunnerDamageFlashUntil) {
      const blinkOn = Math.floor(this.time.now / 70) % 2 === 0;
      if (blinkOn) this.menuRunner.setTint(0xff4d4d);
      else this.menuRunner.clearTint();
    } else {
      this.menuRunner.clearTint();
    }

    this.menuEnemies.forEach((enemy) => {
      if (!enemy) return;
      if (!enemy.alive) {
        if (this.time.now >= enemy.respawnAt) {
          enemy.alive = true;
          enemy.setVisible(true);
          enemy.setAlpha(1);
          enemy.setScale(1, 1);
          enemy.y = this.menuRunnerGroundY + 2;
          enemy.menuX = Phaser.Math.Between(minX + 40, maxX - 40);
          enemy.menuDir = Phaser.Math.Between(0, 1) ? 1 : -1;
        }
        return;
      }

      enemy.menuX += enemy.menuDir * enemy.menuSpeed * dt;
      if (enemy.menuX <= minX + 18) {
        enemy.menuX = minX + 18;
        enemy.menuDir = 1;
      } else if (enemy.menuX >= maxX - 18) {
        enemy.menuX = maxX - 18;
        enemy.menuDir = -1;
      }
      enemy.x = enemy.menuX;
      enemy.setFlipX(enemy.menuDir < 0);
      const stomp = Math.abs(this.menuRunner.x - enemy.x) < 18
        && this.menuRunner.y < enemy.y - 10
        && this.menuRunnerVy > 60;
      if (stomp) {
        enemy.alive = false;
        enemy.respawnAt = this.time.now + Phaser.Math.Between(1300, 2200);
        this.tweens.add({
          targets: enemy,
          scaleX: 1.35,
          scaleY: 0.45,
          alpha: 0.25,
          duration: 120,
          onComplete: () => {
            if (enemy && enemy.active) enemy.setVisible(false);
          },
        });
        const puff = this.add.circle(enemy.x, enemy.y - 6, 6, 0xffffff, 0.95).setDepth(8.25).setBlendMode(Phaser.BlendModes.ADD);
        this.menuStage.add(puff);
        this.tweens.add({
          targets: puff,
          scale: 3.1,
          alpha: 0,
          duration: 260,
          ease: "Cubic.Out",
          onComplete: () => puff.destroy(),
        });
        this.menuRunnerVy = -190;
        return;
      }

      const sideHit = Math.abs(this.menuRunner.x - enemy.x) < 22
        && Math.abs(this.menuRunner.y - enemy.y) < 24
        && this.menuRunnerDamageCooldown <= 0;
      if (sideHit) {
        this.menuRunnerDamageCooldown = 700;
        this.menuRunnerDamageFlashUntil = this.time.now + 420;
        this.menuRunnerVy = -120;
        this.menuRunnerFace = this.menuRunner.x < enemy.x ? -1 : 1;
        this.menuRunner.menuX += this.menuRunnerFace * 20;
        this.menuRunner.menuX = Phaser.Math.Clamp(this.menuRunner.menuX, minX, maxX);
      }
    });
    this.saveMenuMiniStageState();
  }

  textureOr(textureKey, fallbackKey) {
    if (textureKey && this.textures.exists(textureKey)) return textureKey;
    if (fallbackKey && this.textures.exists(fallbackKey)) return fallbackKey;
    return "__WHITE";
  }

  shutdown() {
    if (this.onSettingsChanged) {
      this.game.events.off("settings-changed", this.onSettingsChanged);
      this.onSettingsChanged = null;
    }
    // Keep menu music alive across Menu <-> Options transitions.
    this.saveMenuMiniStageState();
    if (this.onResize) {
      this.scale.off("resize", this.onResize);
      this.onResize = null;
    }
    if (this.introParticles) {
      this.introParticles.destroy();
      this.introParticles = null;
    }
    if (this.introFx) {
      this.introFx.destroy(true);
      this.introFx = null;
    }
    if (this.introGlow) {
      this.introGlow.destroy();
      this.introGlow = null;
    }
    if (this.menuStage) {
      this.menuStage.destroy(true);
      this.menuStage = null;
    }
    this.menuRunner = null;
    this.menuEnemies = [];
    this.bgOrbs = [];
    this.introLines = [];
  }
};
  /* <<< scenes/menu-scene.js */

  /* >>> scenes/world-map-scene.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.WorldMapScene = class extends Phaser.Scene {
  constructor() {
    super("WorldMapScene");
    this.mapData = null;
    this.progress = null;
    this.mapRoot = null;
    this.avatar = null;
    this.controller = null;
    this.nodes = [];
    this.selectedNode = null;
    this.ui = null;
    this.keys = null;
    this.onResize = null;
    this.lastSaveAt = 0;
    this.lastInteractDown = false;
    this.lastHelpDown = false;
    this.focusNodeId = null;
    this.lastViewportW = 0;
    this.lastViewportH = 0;
    this.pendingRelayoutCall = null;
    this.useDataDrivenWorld = false;
    this.worldView = null;
    this.activeWorld = null;
    this.pendingWorldLoad = null;
    this.worldNodeById = {};
    this.worldGraph = {};
    this.currentNodeId = null;
    this.pendingTargetNodeId = null;
    this.travelState = null;
    this.prevInput = { left: false, right: false, up: false, down: false, interact: false };
    this.autoWalkConsumed = {};
    this.worldState = null;
    this.shopPanel = null;
    this.onSettingsChanged = null;
  }

  init(data) {
    this.focusNodeId = data && data.focusNodeId ? String(data.focusNodeId) : null;
  }

  create() {
    this.onSettingsChanged = (nextSettings) => this.applyRuntimeSettings(nextSettings);
    this.game.events.on("settings-changed", this.onSettingsChanged);
    if (!Platformer.DEBUG_WORLD_MAP) {
      this.useDataDrivenWorld = true;
      this.createDataDrivenWorldStatic();
      return;
    }

    this.mapData = Platformer.WorldMapData;
    this.progress = Platformer.Progress;
    this.progress.ensureLoaded();

    this.mapRoot = this.add.container(0, 0).setDepth(10);
    this.drawBackground();
    this.drawPathsAndBlockedRegions();
    this.createNodes();
    this.createAvatar();
    this.ui = new Platformer.WorldMapUI(this);

    this.keys = this.buildInputMap();
    this.input.keyboard.on("keydown-ESC", () => this.scene.start("MenuScene"));
    this.input.keyboard.on("keydown-H", () => this.ui.toggleHelp());

    this.onResize = () => this.handleResize();
    this.scale.on("resize", this.onResize);
    this.handleResize();

    if (Platformer.Debug) {
      const unlocked = Object.keys(this.progress.ensureLoaded().unlockedNodes || {}).length;
      Platformer.Debug.log("WorldMap", `Loaded map=${this.mapData.id} nodes=${this.nodes.length} unlocked=${unlocked}`);
    }
  }

  createDataDrivenWorldStatic() {
    this.progress = Platformer.Progress;
    this.progress.ensureLoaded();
    this.keys = this.buildInputMap();
    this.shopPanel = new Platformer.WorldMapShopPanel(this);
    this.ensureWorldMapMusic();
    this.time.delayedCall(1300, () => {
      if (!this.sys || !this.sys.settings || !this.sys.settings.active) return;
      const phaserPlaying = !!(this.sound && this.sound.get("menu-bgm") && this.sound.get("menu-bgm").isPlaying);
      const htmlPlaying = !!(Platformer.menuMusicHtml && !Platformer.menuMusicHtml.paused);
      if (!phaserPlaying && !htmlPlaying && Platformer.Debug) {
        Platformer.Debug.warn("WorldMap.audio", "No world-map music is currently playing after startup.");
      }
    });

    this.input.keyboard.on("keydown-ESC", () => {
      if (this.shopPanel && this.shopPanel.visible) {
        this.shopPanel.close();
        this.refreshTraversalUi();
        return;
      }
      this.scene.start("MenuScene");
    });
    this.onResize = () => this.handleResize();
    this.scale.on("resize", this.onResize);

    this.pendingWorldLoad = Platformer.WorldMapManager.loadWorld("world_tutorial")
      .then((world) => {
        if (!this.sys || !this.sys.settings || !this.sys.settings.active) return;
        this.activeWorld = world;
        this.worldState = this.progress.ensureWorldState(world);
        this.applyWorldProgressToNodes();
        this.worldView = new Platformer.WorldMapView(this, world);
        this.worldView.render();
        this.buildWorldGraph();
        this.initWorldTraversalState();
        this.handleResize();
      })
      .catch((err) => {
        if (Platformer.Debug) {
          Platformer.Debug.error("WorldMapScene.createDataDrivenWorldStatic", err && err.stack ? err.stack : String(err));
        }
      })
      .finally(() => {
        this.pendingWorldLoad = null;
      });
  }

  applyWorldProgressToNodes() {
    if (!this.activeWorld || !Array.isArray(this.activeWorld.nodes) || !this.progress) return;
    const ws = this.progress.ensureWorldState(this.activeWorld);
    this.worldState = ws;
    this.activeWorld.nodes.forEach((node) => {
      if (!node || !node.id) return;
      const id = String(node.id);
      const unlocked = !!ws.unlockedNodes[id];
      const completed = !!ws.completedNodes[id];
      node.state = completed ? "completed" : (unlocked ? "unlocked" : "locked");
    });
  }

  buildWorldGraph() {
    this.worldNodeById = {};
    this.worldGraph = {};
    const nodes = Array.isArray(this.activeWorld && this.activeWorld.nodes) ? this.activeWorld.nodes : [];
    const edges = Array.isArray(this.activeWorld && this.activeWorld.edges) ? this.activeWorld.edges : [];
    nodes.forEach((n) => {
      if (!n || !n.id || !n.pos) return;
      this.worldNodeById[n.id] = n;
      this.worldGraph[n.id] = this.worldGraph[n.id] || [];
    });
    edges.forEach((e) => {
      if (!e || !e.from || !e.to) return;
      if (!this.worldNodeById[e.from] || !this.worldNodeById[e.to]) return;
      this.worldGraph[e.from] = this.worldGraph[e.from] || [];
      this.worldGraph[e.to] = this.worldGraph[e.to] || [];
      if (!this.worldGraph[e.from].includes(e.to)) this.worldGraph[e.from].push(e.to);
      if (!this.worldGraph[e.to].includes(e.from)) this.worldGraph[e.to].push(e.from);
    });
  }

  initWorldTraversalState() {
    const startId = (this.activeWorld && this.activeWorld.startNodeId) || null;
    this.currentNodeId = this.resolveInitialNodeId(startId);
    this.pendingTargetNodeId = null;
    this.travelState = null;
    this.autoWalkConsumed = {};

    const node = this.worldNodeById[this.currentNodeId];
    if (node && this.worldView) {
      this.worldView.createAvatar();
      this.worldView.setAvatarPosition(node.pos.x - 26, node.pos.y);
      this.worldView.selectNode(node.id);
      this.refreshTraversalUi();
    }
  }

  resolveInitialNodeId(defaultId) {
    if (this.focusNodeId && this.worldNodeById[this.focusNodeId]) return this.focusNodeId;
    const ws = this.progress.ensureWorldState(this.activeWorld);
    if (ws && ws.lastSelectedNodeId && this.worldNodeById[ws.lastSelectedNodeId]) return ws.lastSelectedNodeId;
    if (defaultId && this.worldNodeById[defaultId]) return defaultId;
    const keys = Object.keys(this.worldNodeById);
    return keys.length ? keys[0] : null;
  }

  getConnectedNodeIds(nodeId) {
    return (this.worldGraph[nodeId] || []).filter((id) => !!this.worldNodeById[id]);
  }

  isCurrentWorldNodeUnlocked(nodeId) {
    if (!this.activeWorld || !this.progress) return false;
    return this.progress.isWorldNodeUnlocked(this.activeWorld, nodeId);
  }

  chooseDirectionalNeighbor(fromId, dirX, dirY) {
    const from = this.worldNodeById[fromId];
    if (!from) return null;
    const candidates = this.getConnectedNodeIds(fromId).filter((id) => this.isCurrentWorldNodeUnlocked(id));
    if (!candidates.length) return null;

    let bestId = null;
    let bestScore = -Infinity;
    candidates.forEach((id) => {
      const to = this.worldNodeById[id];
      if (!to) return;
      const vx = to.pos.x - from.pos.x;
      const vy = to.pos.y - from.pos.y;
      const mag = Math.sqrt(vx * vx + vy * vy);
      if (mag < 0.001) return;
      const nx = vx / mag;
      const ny = vy / mag;
      const dot = nx * dirX + ny * dirY;
      if (dot <= 0.15) return;
      const score = dot * 1000 - mag;
      if (score > bestScore) {
        bestScore = score;
        bestId = id;
      }
    });
    return bestId;
  }

  startTravelTo(targetNodeId, autoWalk = false) {
    if (!this.currentNodeId || !targetNodeId || this.currentNodeId === targetNodeId) return false;
    if (!this.isCurrentWorldNodeUnlocked(targetNodeId)) return false;
    const from = this.worldNodeById[this.currentNodeId];
    const to = this.worldNodeById[targetNodeId];
    if (!from || !to) return false;
    const dx = to.pos.x - from.pos.x;
    const dy = to.pos.y - from.pos.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist < 1) return false;

    this.travelState = {
      fromId: this.currentNodeId,
      toId: targetNodeId,
      x: from.pos.x - 26,
      y: from.pos.y,
      startX: from.pos.x - 26,
      startY: from.pos.y,
      endX: to.pos.x - 26,
      endY: to.pos.y,
      dist,
      traveled: 0,
      speed: autoWalk ? 92 : 170,
      autoWalk: !!autoWalk,
    };
    this.pendingTargetNodeId = targetNodeId;
    return true;
  }

  updateTravel(deltaMs) {
    if (!this.travelState || !this.worldView) return;
    const dt = Math.max(0.001, Number(deltaMs || 16) / 1000);
    const t = this.travelState;
    const step = Math.min(t.dist - t.traveled, t.speed * dt);
    t.traveled += step;
    const p = Phaser.Math.Clamp(t.traveled / Math.max(1, t.dist), 0, 1);
    const x = Phaser.Math.Linear(t.startX, t.endX, p);
    const y = Phaser.Math.Linear(t.startY, t.endY, p);
    this.worldView.setAvatarPosition(x, y);
    this.worldView.setAvatarFacing(t.endX - t.startX);
    this.worldView.setAvatarMoving(true, this.time.now);

    if (p >= 1) {
      this.currentNodeId = t.toId;
      this.travelState = null;
      this.pendingTargetNodeId = null;
      this.onArriveNode(this.currentNodeId);
    }
  }

  onArriveNode(nodeId) {
    const node = this.worldNodeById[nodeId];
    if (!node || !this.worldView) return;
    this.worldView.setAvatarMoving(false, this.time.now);
    this.worldView.selectNode(nodeId);
    this.progress.setWorldSelectedNode(this.activeWorld, nodeId);
    this.refreshTraversalUi();
  }

  refreshTraversalUi() {
    if (!this.worldView || !this.currentNodeId) return;
    const node = this.worldNodeById[this.currentNodeId];
    if (!node) return;
    this.applyWorldProgressToNodes();
    if (this.worldView) {
      this.activeWorld.nodes.forEach((n) => {
        this.worldView.setNodeState(n.id, n.state);
      });
    }
    this.worldView.selectNode(node.id);
    const options = this.getConnectedNodeIds(node.id).filter((id) => this.isCurrentWorldNodeUnlocked(id));
    this.worldView.setAvailableNodes(options, this.pendingTargetNodeId);

    const title = node.ui && node.ui.title ? node.ui.title : node.id;
    const hint = node.ui && node.ui.hint ? node.ui.hint : "Press Enter/E to confirm";
    const nodeUnlocked = this.isCurrentWorldNodeUnlocked(node.id);
    const prompt = this.pendingTargetNodeId
      ? `Traveling to ${this.pendingTargetNodeId}...`
      : (nodeUnlocked
        ? (String(node.type || "") === "shop" ? "Move: WASD/Arrows  Confirm: E/Enter (Shop)" : "Move: WASD/Arrows  Confirm: E/Enter")
        : "Locked node.");
    const best = this.progress.getWorldNodeBest(this.activeWorld, node.id);
    this.worldView.infoTitle.setText(`${title} (${node.id})`);
    this.worldView.infoBody.setText([
      `Type: ${String(node.type || "level")}`,
      `State: ${String(node.state || "locked")}`,
      `Best Coins: ${best ? Number(best.bestCoins || 0) : 0}`,
      `Best Time Left: ${best ? Number(best.bestTimeLeft || 0) : 0}s`,
      "",
      hint,
    ].join("\n"));
    this.worldView.reflowInfoPanel();
    this.worldView.setPrompt(prompt);

    const edgeCount = Array.isArray(this.activeWorld && this.activeWorld.edges) ? this.activeWorld.edges.length : 0;
    const unlockedCount = this.activeWorld.nodes.filter((n) => this.isCurrentWorldNodeUnlocked(n.id)).length;
    this.worldView.setDebug(`World: ${this.activeWorld.id} | Node: ${node.id} | Next: ${options.length} | Unlocked: ${unlockedCount}/${this.activeWorld.nodes.length} | Edges: ${edgeCount}`);
  }

  tryStartAutoWalk() {
    if (!this.currentNodeId || this.travelState) return;
    const node = this.worldNodeById[this.currentNodeId];
    if (!node || !node.autoWalkTo) return;
    if (this.autoWalkConsumed[node.id]) return;
    if (!this.worldNodeById[node.autoWalkTo]) return;
    if (!this.isCurrentWorldNodeUnlocked(node.autoWalkTo)) return;
    this.autoWalkConsumed[node.id] = true;
    this.startTravelTo(node.autoWalkTo, true);
    this.refreshTraversalUi();
  }

  drawBackground() {
    const { w, h } = this.getViewportSize();
    this.bgSky = this.add.rectangle(0, 0, w, h, 0x071638, 1).setOrigin(0, 0).setDepth(0).setScrollFactor(0);
    this.bgStrip1 = this.add.rectangle(0, h * 0.15, w, h * 0.18, 0x122b63, 0.5).setOrigin(0, 0).setDepth(1).setScrollFactor(0);
    this.bgStrip2 = this.add.rectangle(0, h * 0.62, w, h * 0.22, 0x173c84, 0.48).setOrigin(0, 0).setDepth(1).setScrollFactor(0);
    this.grid = this.add.graphics().setDepth(2).setScrollFactor(0);
    this.redrawGrid();

    this.particles = this.add.particles(0, 0, this.textureOr("coin", "__WHITE"), {
      x: { min: 0, max: w },
      y: { min: 0, max: h },
      lifespan: { min: 2500, max: 5000 },
      speedY: { min: -18, max: -5 },
      speedX: { min: -8, max: 8 },
      scale: { start: 0.08, end: 0 },
      alpha: { start: 0.3, end: 0 },
      frequency: 130,
      quantity: 1,
    }).setDepth(3).setScrollFactor(0);
  }

  redrawGrid() {
    if (!this.grid) return;
    const { w, h } = this.getViewportSize();
    this.grid.clear();
    this.grid.lineStyle(1, 0x38bdf8, 0.08);
    for (let x = 0; x < w; x += 64) {
      this.grid.beginPath();
      this.grid.moveTo(x, 0);
      this.grid.lineTo(x, h);
      this.grid.strokePath();
    }
    for (let y = 0; y < h; y += 64) {
      this.grid.beginPath();
      this.grid.moveTo(0, y);
      this.grid.lineTo(w, y);
      this.grid.strokePath();
    }
  }

  drawPathsAndBlockedRegions() {
    const g = this.add.graphics().setDepth(10);
    g.lineStyle(8, 0x0f2f63, 0.95);
    this.mapData.nodes.forEach((node) => {
      (node.next || []).forEach((nextId) => {
        const next = this.mapData.getNodeById(nextId);
        if (!next) return;
        g.beginPath();
        g.moveTo(node.x, node.y);
        g.lineTo(next.x, next.y);
        g.strokePath();
      });
    });
    g.lineStyle(3, 0x67e8f9, 0.88);
    this.mapData.nodes.forEach((node) => {
      (node.next || []).forEach((nextId) => {
        const next = this.mapData.getNodeById(nextId);
        if (!next) return;
        g.beginPath();
        g.moveTo(node.x, node.y);
        g.lineTo(next.x, next.y);
        g.strokePath();
      });
    });

    this.mapRoot.add(g);
    this.blockedVisuals = this.mapData.blockedRegions.map((r) => {
      const rect = this.add.rectangle(r.x + r.width / 2, r.y + r.height / 2, r.width, r.height, 0x0f172a, 0.62)
        .setStrokeStyle(2, 0x334155, 0.9)
        .setDepth(11);
      const label = this.add.text(rect.x, rect.y, r.label || "blocked", {
        fontFamily: "Consolas",
        fontSize: "14px",
        color: "#94a3b8",
      }).setOrigin(0.5).setDepth(12);
      this.mapRoot.add([rect, label]);
      return { rect, label };
    });
  }

  createNodes() {
    this.nodes = this.mapData.nodes.map((n) => new Platformer.LevelNode(this, n, this.progress, this.mapRoot));
    this.refreshNodeUnlocks();
  }

  createAvatar() {
    const spawn = this.computeSpawnPoint();
    this.avatar = this.add.sprite(spawn.x, spawn.y, this.textureOr("player-run-1", "player-idle-1")).setDepth(30);
    this.avatar.setDisplaySize(42, 56);
    this.mapRoot.add(this.avatar);
    this.controller = new Platformer.PlayerMapController(
      this,
      this.avatar,
      this.mapData.bounds,
      this.mapData.blockedRegions
    );
  }

  computeSpawnPoint() {
    const d = this.progress.ensureLoaded();
    if (this.focusNodeId) {
      const node = this.mapData.getNodeById(this.focusNodeId);
      if (node) return { x: node.x - 26, y: node.y };
    }
    if (d.lastMapPosition) {
      return {
        x: Phaser.Math.Clamp(d.lastMapPosition.x, this.mapData.bounds.x + 18, this.mapData.bounds.x + this.mapData.bounds.width - 18),
        y: Phaser.Math.Clamp(d.lastMapPosition.y, this.mapData.bounds.y + 18, this.mapData.bounds.y + this.mapData.bounds.height - 18),
      };
    }
    if (d.lastSelectedNodeId) {
      const node = this.mapData.getNodeById(d.lastSelectedNodeId);
      if (node) return { x: node.x - 26, y: node.y };
    }
    return { x: this.mapData.spawn.x, y: this.mapData.spawn.y };
  }

  buildInputMap() {
    const controls = Platformer.Settings.current.controls || {};
    const key = (name, fallback) => {
      const code = String(controls[name] || fallback || "").toUpperCase();
      return this.input.keyboard.addKey(code);
    };
    return {
      left: key("left", "A"),
      right: key("right", "D"),
      up: key("jump", "W"),
      down: this.input.keyboard.addKey("S"),
      interact: key("interact", "E"),
      enter: this.input.keyboard.addKey("ENTER"),
      arrows: this.input.keyboard.createCursorKeys(),
    };
  }

  getInputState() {
    const k = this.keys;
    return {
      left: (k.left && k.left.isDown) || (k.arrows && k.arrows.left.isDown),
      right: (k.right && k.right.isDown) || (k.arrows && k.arrows.right.isDown),
      up: (k.up && k.up.isDown) || (k.arrows && k.arrows.up.isDown),
      down: (k.down && k.down.isDown) || (k.arrows && k.arrows.down.isDown),
      interact: (k.interact && k.interact.isDown) || (k.enter && k.enter.isDown),
    };
  }

  refreshNodeUnlocks() {
    this.nodes.forEach((n) => n.refreshUnlock());
  }

  update(_time, delta) {
    if (this.useDataDrivenWorld) {
      if (this.worldView && typeof this.worldView.updateAmbient === "function") {
        this.worldView.updateAmbient(_time, delta);
      }
      const vp = this.getViewportSize();
      if (vp.w !== this.lastViewportW || vp.h !== this.lastViewportH) {
        this.handleResize(vp.w, vp.h);
      }
      if (this.travelState) {
        this.updateTravel(delta);
        return;
      }
      this.handleDataDrivenInput();
      return;
    }
    if (!this.controller || !this.avatar) return;
    const vp = this.getViewportSize();
    if (vp.w !== this.lastViewportW || vp.h !== this.lastViewportH) {
      this.handleResize(vp.w, vp.h);
    }
    const input = this.getInputState();
    const motion = this.controller.update(input, delta);

    if (motion.moving) {
      const frame = Math.floor(this.time.now / 120) % 2 === 0 ? "player-run-1" : "player-run-2";
      this.avatar.setTexture(this.textureOr(frame, "player-idle-1"));
    } else {
      this.avatar.setTexture(this.textureOr("player-idle-1", "player-run-1"));
    }

    this.updateSelectedNode();
    this.updateInteraction(input.interact);
    this.updateSaveTick();
  }

  updateSelectedNode() {
    let nearest = null;
    let nearestDist = Infinity;
    this.nodes.forEach((node) => {
      const dx = this.avatar.x - node.data.x;
      const dy = this.avatar.y - node.data.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const inRange = dist <= node.radius;
      node.setSelected(inRange);
      if (inRange && dist < nearestDist) {
        nearest = node;
        nearestDist = dist;
      }
    });

    this.selectedNode = nearest;
    const d = this.progress.ensureLoaded();
    const best = nearest ? d.bestByNode[nearest.id] : null;
    const tutorialHint = nearest && !this.progress.hasSeenTutorial(nearest.id)
      ? `Tip: ${nearest.data.tutorial || "No tutorial text."}`
      : "";
    this.ui.updateNodeInfo(
      nearest ? nearest.data : null,
      best,
      nearest ? nearest.unlocked : false,
      !!nearest,
      tutorialHint
    );

    const unlockedCount = Object.keys(d.unlockedNodes || {}).filter((k) => d.unlockedNodes[k]).length;
    this.ui.setDebug(`Selected: ${nearest ? nearest.id : "none"} | Unlocked: ${unlockedCount}/${this.nodes.length}`);
  }

  updateInteraction(interactDown) {
    const pressed = interactDown && !this.lastInteractDown;
    this.lastInteractDown = interactDown;
    if (!pressed || !this.selectedNode) return;

    const node = this.selectedNode;
    if (!node.unlocked) {
      Platformer.beeper.damage();
      return;
    }

    this.progress.data.lastSelectedNodeId = node.id;
    this.progress.save();
    if (!this.progress.hasSeenTutorial(node.id)) {
      this.progress.markTutorialSeen(node.id);
      if (Platformer.Debug) Platformer.Debug.log("WorldMap", `First-time hint consumed for ${node.id}`);
    }
    this.progress.updateMapPosition({ x: this.avatar.x, y: this.avatar.y });

    this.launchLevel(node.data);
  }

  launchLevel(nodeData) {
    if (!nodeData) return;
    const levelNum = this.resolveNodeGameLevel(nodeData);
    if (Platformer.Debug) Platformer.Debug.log("WorldMap", `Entering ${nodeData.id} -> level=${levelNum}`);
    this.stopWorldMapMusic();

    const difficulty = Platformer.Settings.current.gameplay.difficulty;
    const baseLives = difficulty === "easy" ? 3 : (difficulty === "hard" ? 1 : 2);
    this.registry.set("coins", 0);
    this.registry.set("health", 3);
    this.registry.set("lives", baseLives);
    this.registry.set("level", levelNum);

    if (this.scene.isActive("UIScene") || this.scene.isPaused("UIScene")) {
      this.scene.stop("UIScene");
    }

    this.scene.start("GameScene", {
      level: levelNum,
      nodeId: nodeData.id,
      worldId: this.activeWorld && this.activeWorld.id ? this.activeWorld.id : null,
      fromWorldMap: true,
    });
    this.scene.launch("UIScene");
  }

  resolveNodeGameLevel(nodeData) {
    if (!nodeData) return 1;
    if (Number.isFinite(Number(nodeData.gameLevel))) return Number(nodeData.gameLevel);
    if (nodeData.levelRef && Platformer.WorldMapManager && typeof Platformer.WorldMapManager.resolveGameLevelRef === "function") {
      return Platformer.WorldMapManager.resolveGameLevelRef(nodeData.levelRef);
    }
    return 1;
  }

  ensureWorldMapMusic() {
    try {
      const audioSettings = Platformer.Settings.current.audio;
      const volume = Phaser.Math.Clamp((audioSettings.master / 100) * (audioSettings.music / 100), 0, 1);
      if (Platformer.Debug) {
        Platformer.Debug.log(
          "WorldMap.audio",
          `Ensuring map BGM master=${audioSettings.master} music=${audioSettings.music} volume=${volume.toFixed(2)} muted=${this.sound && this.sound.mute ? "yes" : "no"} hidden=${document.hidden ? "yes" : "no"}`
        );
        if (volume <= 0.001) {
          Platformer.Debug.warn("WorldMap.audio", "Effective music volume is 0. Increase Master/Music volume in Options.");
        }
      }

      if (Platformer.gameMusic) {
        try {
          if (Platformer.gameMusic.isPlaying) Platformer.gameMusic.stop();
        } catch (_e) {}
        Platformer.gameMusic = null;
      }
      if (Platformer.gameMusicHtml) {
        try {
          Platformer.gameMusicHtml.pause();
          Platformer.gameMusicHtml.currentTime = 0;
        } catch (_e) {}
        Platformer.gameMusicHtml = null;
      }

      const tryPlayMenuBgm = () => {
        let music = this.sound.get("menu-bgm");
        if (!music) {
          try {
            music = this.sound.add("menu-bgm", { loop: true, volume });
            if (Platformer.Debug) Platformer.Debug.log("WorldMap.audio", "Created menu-bgm sound instance.");
          } catch (err) {
            if (Platformer.Debug) Platformer.Debug.warn("WorldMap.audio", `menu-bgm add failed: ${err && err.message ? err.message : err}`);
            return false;
          }
        }
        Platformer.menuMusic = music;
        music.setLoop(true);
        music.setVolume(volume);
        if (!music.isPlaying) {
          try {
            if (this.sound && this.sound.context && this.sound.context.state === "suspended") {
              this.sound.context.resume().catch(() => {});
              if (Platformer.Debug) Platformer.Debug.warn("WorldMap.audio", "WebAudio context suspended; resume requested.");
            }
            music.play();
            if (Platformer.Debug) Platformer.Debug.log("WorldMap.audio", "Playing menu-bgm (Phaser).");
          } catch (err) {
            if (Platformer.Debug) Platformer.Debug.warn("WorldMap.audio", `menu-bgm play blocked: ${err && err.message ? err.message : err}`);
            return false;
          }
        } else if (Platformer.Debug) {
          Platformer.Debug.log("WorldMap.audio", "menu-bgm already playing.");
        }
        return true;
      };

      if (this.cache.audio.exists("menu-bgm")) {
        if (tryPlayMenuBgm()) return;
      } else {
        this.load.audio("menu-bgm", "assets/nickpanek-energetic-chiptune-video-game-music-platformer-8-bit-318348.mp3");
        this.load.once("complete", () => {
          if (!this.sys || !this.sys.settings || !this.sys.settings.active) return;
          if (!tryPlayMenuBgm()) {
            this.playWorldMapHtmlMusic(volume, audioSettings);
          }
        });
        this.load.once("loaderror", () => {
          if (Platformer.Debug) Platformer.Debug.warn("WorldMap.audio", "menu-bgm loaderror; using HTML fallback.");
          this.playWorldMapHtmlMusic(volume, audioSettings);
        });
        this.load.start();
        return;
      }
      this.playWorldMapHtmlMusic(volume, audioSettings);
    } catch (err) {
      if (Platformer.Debug) Platformer.Debug.error("WorldMap.audio", err && err.stack ? err.stack : String(err));
    }
  }

  applyRuntimeSettings(nextSettings) {
    try {
      const settings = nextSettings || Platformer.Settings.current || {};
      const audio = settings.audio || { master: 80, music: 60, muteWhenUnfocused: false };
      const volume = Phaser.Math.Clamp((Number(audio.master) / 100) * (Number(audio.music) / 100), 0, 1);

      if (Platformer.menuMusic && typeof Platformer.menuMusic.setVolume === "function") {
        Platformer.menuMusic.setVolume(volume);
      }
      if (Platformer.menuMusicHtml) {
        Platformer.menuMusicHtml.volume = volume;
      }
      if (audio.muteWhenUnfocused && document.hidden) {
        if (Platformer.menuMusicHtml && !Platformer.menuMusicHtml.paused) {
          Platformer.menuMusicHtml.pause();
        }
      }
      this.keys = this.buildInputMap();
      if (Platformer.Debug) {
        Platformer.Debug.log("WorldMap.settings", `Applied runtime settings: mapVolume=${volume.toFixed(2)}`);
      }
    } catch (err) {
      if (Platformer.Debug) {
        Platformer.Debug.error("WorldMap.settings", err && err.stack ? err.stack : String(err));
      }
    }
  }

  playWorldMapHtmlMusic(volume, audioSettings) {
    try {
      if (!Platformer.menuMusicHtml) {
        Platformer.menuMusicHtml = new Audio("assets/nickpanek-energetic-chiptune-video-game-music-platformer-8-bit-318348.mp3");
      }
      const music = Platformer.menuMusicHtml;
      music.loop = true;
      music.volume = Phaser.Math.Clamp(volume, 0, 1);
      music.onerror = (e) => {
        if (Platformer.Debug) Platformer.Debug.error("WorldMap.audio", `HTML audio error: ${e && e.message ? e.message : "unknown error"}`);
      };
      const tryPlay = () => {
        if (audioSettings && audioSettings.muteWhenUnfocused && document.hidden) return;
        music.play().then(() => {
          if (Platformer.Debug) Platformer.Debug.log("WorldMap.audio", "Playing menu-bgm (HTML fallback).");
        }).catch((e) => {
          if (Platformer.Debug) Platformer.Debug.warn("WorldMap.audio", `HTML play blocked: ${e && e.message ? e.message : e}`);
        });
      };
      this.input.once("pointerdown", tryPlay);
      this.input.keyboard.once("keydown", tryPlay);
      tryPlay();
    } catch (err) {
      if (Platformer.Debug) Platformer.Debug.error("WorldMap.audio", `HTML fallback failed: ${err && err.message ? err.message : err}`);
    }
  }

  stopWorldMapMusic() {
    try {
      this.sound.stopByKey("menu-bgm");
      if (Platformer.menuMusic) {
        try {
          if (Platformer.menuMusic.isPlaying) Platformer.menuMusic.stop();
        } catch (_e) {}
        Platformer.menuMusic = null;
      }
      if (Platformer.menuMusicHtml) {
        Platformer.menuMusicHtml.pause();
        Platformer.menuMusicHtml.currentTime = 0;
        Platformer.menuMusicHtml = null;
      }
      if (Platformer.Debug) Platformer.Debug.log("WorldMap.audio", "Stopped world-map/menu music.");
    } catch (err) {
      if (Platformer.Debug) Platformer.Debug.warn("WorldMap.audio", `Stop failed: ${err && err.message ? err.message : err}`);
    }
  }

  updateSaveTick() {
    if (!this.progress || !this.avatar) return;
    if (this.time.now - this.lastSaveAt < 900) return;
    this.lastSaveAt = this.time.now;
    this.progress.updateMapPosition({ x: this.avatar.x, y: this.avatar.y });
  }

  handleDataDrivenInput() {
    if (!this.keys || !this.currentNodeId || !this.worldView) return;
    const input = this.getInputState();
    const just = {
      left: input.left && !this.prevInput.left,
      right: input.right && !this.prevInput.right,
      up: input.up && !this.prevInput.up,
      down: input.down && !this.prevInput.down,
      interact: input.interact && !this.prevInput.interact,
    };
    this.prevInput = input;

    if (this.shopPanel && this.shopPanel.visible) {
      this.shopPanel.handleInput(just);
      return;
    }

    let direction = null;
    if (just.left) direction = { x: -1, y: 0 };
    else if (just.right) direction = { x: 1, y: 0 };
    else if (just.up) direction = { x: 0, y: -1 };
    else if (just.down) direction = { x: 0, y: 1 };

    if (direction) {
      const candidate = this.chooseDirectionalNeighbor(this.currentNodeId, direction.x, direction.y);
      if (candidate) {
        this.pendingTargetNodeId = candidate;
        this.startTravelTo(candidate, false);
      } else if (Platformer.Debug) {
        Platformer.Debug.log("WorldMap.unlock", `Blocked move from ${this.currentNodeId}: no unlocked neighbor in direction (${direction.x},${direction.y}).`);
      }
      this.refreshTraversalUi();
      return;
    }

    if (just.interact) {
      const node = this.worldNodeById[this.currentNodeId];
      if (!node) return;
      if (!this.isCurrentWorldNodeUnlocked(node.id)) {
        Platformer.beeper.damage();
        return;
      }
      if (!this.progress.hasSeenWorldTutorial(this.activeWorld, node.id)) {
        this.progress.markWorldTutorialSeen(this.activeWorld, node.id);
      }
      if (String(node.type || "") === "shop" || !!node.shopRef) {
        this.openShopForNode(node);
        return;
      }
      if (node.levelRef || Number.isFinite(Number(node.gameLevel))) {
        this.launchLevel(node);
        return;
      }
      Platformer.beeper.coin();
    }
  }

  handleResize(inW, inH) {
    if (!this.sys || !this.sys.settings || !this.sys.settings.active) return;
    const vp = this.getViewportSize();
    const w = Number(inW) || vp.w;
    const h = Number(inH) || vp.h;
    this.lastViewportW = w;
    this.lastViewportH = h;
    if (this.useDataDrivenWorld) {
      if (this.worldView) this.worldView.resize();
      if (this.shopPanel) this.shopPanel.resize();
      return;
    }
    const safeRectSizePos = (obj, width, height, x, y) => {
      if (!obj || !obj.active || !obj.scene) return;
      obj.setSize(width, height).setPosition(x, y);
    };
    safeRectSizePos(this.bgSky, w, h, 0, 0);
    safeRectSizePos(this.bgStrip1, w, h * 0.18, 0, h * 0.15);
    safeRectSizePos(this.bgStrip2, w, h * 0.22, 0, h * 0.62);
    this.redrawGrid();
    if (this.particles) {
      this.particles.setConfig({
        x: { min: 0, max: w },
        y: { min: 0, max: h },
      });
    }
    if (this.ui) this.ui.resize();
    this.layoutMapRootToViewport();
    if (this.pendingRelayoutCall) {
      this.pendingRelayoutCall.remove(false);
      this.pendingRelayoutCall = null;
    }
    if (this.time && this.sys && this.sys.settings && this.sys.settings.active) {
      this.pendingRelayoutCall = this.time.delayedCall(40, () => {
        this.pendingRelayoutCall = null;
        if (!this.sys || !this.sys.settings || !this.sys.settings.active) return;
        this.layoutMapRootToViewport();
      });
    }
  }

  layoutMapRootToViewport() {
    if (!this.sys || !this.sys.settings || !this.sys.settings.active) return;
    if (!this.mapRoot || !this.mapRoot.active || !this.mapData || !this.mapData.bounds) return;
    const { w, h } = this.getViewportSize();
    const b = this.mapData.bounds;
    const margin = Math.max(24, Math.round(Math.min(w, h) * 0.04));
    const sx = (w - margin * 2) / Math.max(1, b.width);
    const sy = (h - margin * 2) / Math.max(1, b.height);
    const scale = Phaser.Math.Clamp(Math.min(sx, sy), 0.35, 2.2);
    const fittedW = b.width * scale;
    const fittedH = b.height * scale;
    const offsetX = (w - fittedW) * 0.5 - b.x * scale;
    const offsetY = (h - fittedH) * 0.5 - b.y * scale;

    this.mapRoot.setScale(scale);
    this.mapRoot.setPosition(offsetX, offsetY);

    const cam = this.cameras && this.cameras.main;
    if (cam) {
      cam.setViewport(0, 0, w, h);
      cam.setZoom(1);
      cam.scrollX = 0;
      cam.scrollY = 0;
      cam.roundPixels = true;
    }
  }

  getViewportSize() {
    const gs = this.scale && this.scale.gameSize ? this.scale.gameSize : null;
    const bs = this.scale && this.scale.baseSize ? this.scale.baseSize : null;
    const w = (gs && gs.width) || (bs && bs.width) || this.scale.width || 960;
    const h = (gs && gs.height) || (bs && bs.height) || this.scale.height || 540;
    return { w: Math.max(640, Math.round(w)), h: Math.max(360, Math.round(h)) };
  }

  openShopForNode(node) {
    const worldId = this.activeWorld && this.activeWorld.id ? this.activeWorld.id : "world_tutorial";
    const shopRef = node && node.shopRef ? String(node.shopRef) : null;
    if (!shopRef) {
      if (Platformer.Debug) Platformer.Debug.warn("WorldMap.shop", `Node ${node && node.id ? node.id : "unknown"} has no shopRef.`);
      Platformer.beeper.damage();
      return;
    }
    Platformer.WorldMapManager.loadShop(worldId, shopRef)
      .then((shop) => {
        if (!this.sys || !this.sys.settings || !this.sys.settings.active) return;
        if (!this.shopPanel) return;
        this.shopPanel.open(shop, () => {
          this.refreshTraversalUi();
        });
      })
      .catch((err) => {
        if (Platformer.Debug) Platformer.Debug.error("WorldMap.shop", err && err.stack ? err.stack : String(err));
        Platformer.beeper.damage();
      });
  }

  textureOr(key, fallback) {
    if (key && this.textures.exists(key)) return key;
    if (fallback && this.textures.exists(fallback)) return fallback;
    return "__WHITE";
  }

  shutdown() {
    if (this.onSettingsChanged) {
      this.game.events.off("settings-changed", this.onSettingsChanged);
      this.onSettingsChanged = null;
    }
    if (!this.scene.isActive("GameScene")) {
      this.stopWorldMapMusic();
    }
    if (this.pendingWorldLoad && typeof this.pendingWorldLoad.cancel === "function") {
      this.pendingWorldLoad.cancel();
    }
    this.pendingWorldLoad = null;
    if (this.pendingRelayoutCall) {
      this.pendingRelayoutCall.remove(false);
      this.pendingRelayoutCall = null;
    }
    if (this.onResize) {
      this.scale.off("resize", this.onResize);
      this.onResize = null;
    }
    if (this.ui) {
      this.ui.destroy();
      this.ui = null;
    }
    if (this.worldView) {
      this.worldView.destroy();
      this.worldView = null;
    }
    if (this.shopPanel) {
      this.shopPanel.destroy();
      this.shopPanel = null;
    }
    this.worldNodeById = {};
    this.worldGraph = {};
    this.currentNodeId = null;
    this.pendingTargetNodeId = null;
    this.travelState = null;
    this.nodes.forEach((n) => n.destroy());
    this.nodes = [];
    if (this.particles) {
      this.particles.destroy();
      this.particles = null;
    }
    if (this.mapRoot) {
      this.mapRoot.destroy(true);
      this.mapRoot = null;
    }
  }
};
  /* <<< scenes/world-map-scene.js */

  /* >>> scenes/extras-scene.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.ExtrasScene = class extends Phaser.Scene {
  constructor() {
    super("ExtrasScene");
    this.onResize = null;
    this.categoryButtons = {};
    this.cards = [];
    this.selectedCategory = "conceptArt";
    this.preview = null;
    this.previewText = null;
    this.infoText = null;
    this.progressSnapshot = null;
  }

  create() {
    this.bgSky = this.add.rectangle(0, 0, 10, 10, 0x081336, 0.98).setOrigin(0, 0);
    this.bgMid = this.add.rectangle(0, 0, 10, 10, 0x132a56, 0.94).setOrigin(0, 0);
    this.bgGround = this.add.rectangle(0, 0, 10, 10, 0x0b6f49, 0.34).setOrigin(0, 0);
    this.bgOverlay = this.add.rectangle(0, 0, 10, 10, 0x020617, 0.38).setOrigin(0, 0);

    this.title = this.add.text(0, 34, "EXTRA'S", {
      fontFamily: "Consolas",
      fontSize: "54px",
      color: "#f8fafc",
      stroke: "#0f172a",
      strokeThickness: 6,
    }).setOrigin(0.5, 0).setDepth(10);

    this.subtitle = this.add.text(0, 98, "Unlock concept art, achievements and skins by playing levels.", {
      fontFamily: "Consolas",
      fontSize: "20px",
      color: "#cbd5e1",
      stroke: "#0f172a",
      strokeThickness: 3,
    }).setOrigin(0.5, 0).setDepth(10);

    this.backBtn = this.add.rectangle(98, 42, 164, 48, 0x1e293b, 0.96)
      .setStrokeStyle(2, 0x67e8f9, 1)
      .setInteractive({ useHandCursor: true })
      .setDepth(12);
    this.backLabel = this.add.text(98, 42, "< BACK", {
      fontFamily: "Consolas",
      fontSize: "28px",
      color: "#f8fafc",
    }).setOrigin(0.5).setDepth(13);
    this.backBtn.on("pointerdown", () => {
      if (Platformer.Debug) Platformer.Debug.log("ExtrasScene", "Back to menu.");
      this.scene.start("MenuScene");
    });

    this.categoryBar = this.add.container(0, 0).setDepth(11);
    this.cardsContainer = this.add.container(0, 0).setDepth(11);

    this.preview = this.add.rectangle(0, 0, 10, 10, 0x0f172a, 0.9)
      .setStrokeStyle(2, 0x67e8f9, 0.9)
      .setDepth(12)
      .setVisible(false);
    this.previewText = this.add.text(0, 0, "", {
      fontFamily: "Consolas",
      fontSize: "20px",
      color: "#e2e8f0",
      align: "left",
      wordWrap: { width: 520 },
    }).setDepth(13).setVisible(false);

    this.infoText = this.add.text(0, 0, "", {
      fontFamily: "Consolas",
      fontSize: "18px",
      color: "#93c5fd",
      stroke: "#0f172a",
      strokeThickness: 3,
    }).setOrigin(0, 1).setDepth(12);

    this.input.keyboard.on("keydown-ESC", () => {
      if (this.preview && this.preview.visible) {
        this.preview.setVisible(false);
        this.previewText.setVisible(false);
        return;
      }
      this.scene.start("MenuScene");
    });
    this.input.on("pointerdown", (pointer) => {
      if (!this.preview || !this.preview.visible) return;
      const b = this.preview.getBounds();
      if (!Phaser.Geom.Rectangle.Contains(b, pointer.x, pointer.y)) {
        this.preview.setVisible(false);
        this.previewText.setVisible(false);
      }
    });

    this.refreshProgressSnapshot();
    this.createCategoryButtons();
    this.renderCards();
    this.layout();

    this.onResize = () => {
      if (!this.sys || !this.sys.settings || !this.sys.settings.active) return;
      this.layout();
    };
    this.scale.on("resize", this.onResize);
  }

  refreshProgressSnapshot() {
    try {
      this.progressSnapshot = Platformer.Progress ? Platformer.Progress.ensureLoaded() : {};
    } catch (err) {
      this.progressSnapshot = {};
      if (Platformer.Debug) Platformer.Debug.error("ExtrasScene.progress", err && err.stack ? err.stack : String(err));
    }
  }

  getCompletedCount() {
    const progress = this.progressSnapshot || {};
    const worlds = progress.worlds || {};
    const worldCompleted = Object.values(worlds)
      .map((w) => (w && w.completedNodes) ? Object.keys(w.completedNodes).filter((k) => w.completedNodes[k]).length : 0)
      .reduce((sum, n) => sum + n, 0);
    const legacyCompleted = progress.completedNodes
      ? Object.keys(progress.completedNodes).filter((k) => progress.completedNodes[k]).length
      : 0;
    return Math.max(worldCompleted, legacyCompleted);
  }

  getTotalCoins() {
    const progress = this.progressSnapshot || {};
    return Math.max(0, Number(progress.walletCoins || 0));
  }

  buildExtrasData() {
    const completed = this.getCompletedCount();
    const coins = this.getTotalCoins();
    const owned = (this.progressSnapshot && this.progressSnapshot.upgradesOwned) || {};

    const unlockedBy = (type, value) => {
      if (type === "levels") return completed >= value;
      if (type === "coins") return coins >= value;
      if (type === "upgrade") return Number(owned[value] || 0) > 0;
      return false;
    };

    const mk = (item) => ({
      id: item.id,
      name: item.name,
      subcategory: item.subcategory,
      description: item.description,
      unlockType: item.unlockType,
      unlockValue: item.unlockValue,
      unlocked: unlockedBy(item.unlockType, item.unlockValue),
    });

    return {
      conceptArt: [
        mk({ id: "concept_rooftop", name: "Rooftop Sketch", subcategory: "Environment", description: "Early rooftop layout and jump flow.", unlockType: "levels", unlockValue: 1 }),
        mk({ id: "concept_enemy", name: "Blue Creature Draft", subcategory: "Enemies", description: "Concept pass for creature face + silhouette.", unlockType: "levels", unlockValue: 2 }),
        mk({ id: "concept_boss", name: "Boss Moodboard", subcategory: "Boss", description: "Color and posture exploration for boss route.", unlockType: "levels", unlockValue: 4 }),
      ],
      achievements: [
        mk({ id: "ach_first_clear", name: "First Clear", subcategory: "Milestone", description: "Complete any level.", unlockType: "levels", unlockValue: 1 }),
        mk({ id: "ach_collector", name: "Coin Collector", subcategory: "Economy", description: "Hold at least 25 wallet coins.", unlockType: "coins", unlockValue: 25 }),
        mk({ id: "ach_hunter", name: "Path Hunter", subcategory: "Progress", description: "Complete 4 levels.", unlockType: "levels", unlockValue: 4 }),
      ],
      skins: [
        mk({ id: "skin_classic", name: "Classic Runner", subcategory: "Player", description: "Base skin available from start.", unlockType: "levels", unlockValue: 0 }),
        mk({ id: "skin_dash", name: "Turbo Accent", subcategory: "Player", description: "Unlock by buying a speed upgrade.", unlockType: "upgrade", unlockValue: "speed_boost_1" }),
        mk({ id: "skin_guardian", name: "Guardian Palette", subcategory: "Player", description: "Unlock by buying a health upgrade.", unlockType: "upgrade", unlockValue: "hp_up_1" }),
      ],
    };
  }

  createCategoryButtons() {
    const entries = [
      { id: "conceptArt", label: "Concept Art" },
      { id: "achievements", label: "Achievements" },
      { id: "skins", label: "Skins" },
    ];
    entries.forEach((entry) => {
      const box = this.add.rectangle(0, 0, 220, 44, 0x1e293b, 0.94)
        .setStrokeStyle(2, 0x67e8f9, 0.75)
        .setInteractive({ useHandCursor: true });
      const txt = this.add.text(0, 0, entry.label, {
        fontFamily: "Consolas",
        fontSize: "24px",
        color: "#e2e8f0",
      }).setOrigin(0.5);
      box.on("pointerdown", () => {
        this.selectedCategory = entry.id;
        this.renderCards();
      });
      this.categoryBar.add([box, txt]);
      this.categoryButtons[entry.id] = { box, txt };
    });
  }

  clearCards() {
    this.cards.forEach((card) => {
      if (!card) return;
      [card.box, card.label, card.sub, card.desc, card.status].forEach((o) => {
        if (o && o.destroy) o.destroy();
      });
    });
    this.cards = [];
    this.cardsContainer.removeAll(true);
  }

  renderCards() {
    this.refreshProgressSnapshot();
    const all = this.buildExtrasData();
    const selected = all[this.selectedCategory] || [];
    this.clearCards();

    selected.forEach((item) => {
      const box = this.add.rectangle(0, 0, 320, 160, item.unlocked ? 0x102748 : 0x0f172a, 0.95)
        .setStrokeStyle(2, item.unlocked ? 0x38bdf8 : 0x475569, 0.95)
        .setInteractive({ useHandCursor: true });
      const label = this.add.text(0, 0, item.name, {
        fontFamily: "Consolas",
        fontSize: "26px",
        color: item.unlocked ? "#f8fafc" : "#94a3b8",
      }).setOrigin(0, 0);
      const sub = this.add.text(0, 0, `Category: ${item.subcategory}`, {
        fontFamily: "Consolas",
        fontSize: "18px",
        color: "#93c5fd",
      }).setOrigin(0, 0);
      const desc = this.add.text(0, 0, item.description, {
        fontFamily: "Consolas",
        fontSize: "17px",
        color: "#cbd5e1",
        wordWrap: { width: 280 },
      }).setOrigin(0, 0);
      const requirement = item.unlockType === "levels"
        ? `Complete ${item.unlockValue} level(s)`
        : item.unlockType === "coins"
          ? `Collect ${item.unlockValue} wallet coins`
          : `Buy upgrade: ${item.unlockValue}`;
      const status = this.add.text(0, 0, item.unlocked ? "UNLOCKED - Click to view" : `LOCKED - ${requirement}`, {
        fontFamily: "Consolas",
        fontSize: "16px",
        color: item.unlocked ? "#4ade80" : "#fca5a5",
      }).setOrigin(0, 0);

      box.on("pointerdown", () => this.showPreview(item, requirement));

      this.cardsContainer.add([box, label, sub, desc, status]);
      this.cards.push({ item, box, label, sub, desc, status });
    });
    this.layout();
  }

  showPreview(item, requirementText) {
    const lines = [
      `${item.name}`,
      `Type: ${item.subcategory}`,
      "",
      item.description,
      "",
      item.unlocked ? "Unlocked content preview ready." : `Locked: ${requirementText}`,
      "",
      "Press ESC or click outside to close.",
    ];
    this.previewText.setText(lines.join("\n"));
    this.preview.setVisible(true);
    this.previewText.setVisible(true);
    this.layout();
  }

  layout() {
    if (!this.sys || !this.sys.settings || !this.sys.settings.active) return;
    const w = this.scale.width;
    const h = this.scale.height;
    this.bgSky.setSize(w, h).setPosition(0, 0);
    this.bgMid.setSize(w, Math.round(h * 0.45)).setPosition(0, Math.round(h * 0.28));
    this.bgGround.setSize(w, Math.round(h * 0.22)).setPosition(0, Math.round(h * 0.72));
    this.bgOverlay.setSize(w, h).setPosition(0, 0);

    this.title.setPosition(w * 0.5, 22);
    this.subtitle.setPosition(w * 0.5, 88);

    const catY = 140;
    const catStartX = Math.round(w * 0.5 - 240);
    const catGap = 250;
    ["conceptArt", "achievements", "skins"].forEach((id, idx) => {
      const btn = this.categoryButtons[id];
      if (!btn) return;
      const x = catStartX + idx * catGap;
      btn.box.setPosition(x, catY);
      btn.txt.setPosition(x, catY);
      const active = this.selectedCategory === id;
      btn.box.setFillStyle(active ? 0x1d4ed8 : 0x1e293b, active ? 0.98 : 0.94);
      btn.box.setStrokeStyle(2, active ? 0x93c5fd : 0x67e8f9, active ? 1 : 0.75);
    });

    const gridTop = 186;
    const cols = 3;
    const cardW = Math.min(360, Math.floor((w - 80) / cols) - 18);
    const cardH = 176;
    const gapX = 16;
    const gapY = 16;
    this.cards.forEach((card, idx) => {
      const col = idx % cols;
      const row = Math.floor(idx / cols);
      const x = 30 + col * (cardW + gapX);
      const y = gridTop + row * (cardH + gapY);
      card.box.setPosition(x + cardW / 2, y + cardH / 2).setSize(cardW, cardH);
      card.label.setPosition(x + 14, y + 10);
      card.sub.setPosition(x + 14, y + 50);
      card.desc.setPosition(x + 14, y + 78).setWordWrapWidth(cardW - 28);
      card.status.setPosition(x + 14, y + cardH - 24);
    });

    const progress = this.progressSnapshot || {};
    const completed = this.getCompletedCount();
    const coins = this.getTotalCoins();
    this.infoText.setText(`Completed Levels: ${completed}   |   Wallet Coins: ${coins}   |   ESC: Back to menu`)
      .setPosition(18, h - 10);

    if (this.preview.visible && this.previewText.visible) {
      const pw = Math.min(620, w - 80);
      const ph = Math.min(300, h - 220);
      const px = w * 0.5;
      const py = h * 0.5 + 30;
      this.preview.setSize(pw, ph).setPosition(px, py);
      this.previewText.setPosition(px - pw / 2 + 18, py - ph / 2 + 16).setWordWrapWidth(pw - 36);
    }

    if (progress && Platformer.Debug) {
      Platformer.Debug.log("ExtrasScene.layout", `${w}x${h} category=${this.selectedCategory} cards=${this.cards.length}`);
    }
  }

  shutdown() {
    if (this.onResize) {
      this.scale.off("resize", this.onResize);
      this.onResize = null;
    }
  }
};
  /* <<< scenes/extras-scene.js */

  /* >>> scenes/intro-scene.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.IntroScene = class extends Phaser.Scene {
  constructor() {
    super("IntroScene");
    this.slideIndex = 0;
    this.slides = [];
  }

  create() {
    const cx = this.scale.width / 2;
    const cy = this.scale.height / 2;
    const textScale = Platformer.Settings.textScale();

    this.slides = [
      {
        title: "Mission Briefing",
        body: "Complete 4 levels by collecting 10 coins each.\nBeat the timer and use checkpoints to survive.",
      },
      {
        title: "Hazards + Enemies",
        body: "Laser turrets launch fireballs.\nEnemy types per level: Walker, Hopper, Dasher, Tank.\nStomp enemies from above to defeat.",
      },
      {
        title: "Controls",
        body: "Move: Left/Right\nJump: Jump key (rebindable)\nDash: Dash key (burst + enemy break)\nAttack: Attack key (close-range hit)\nPause: Pause key\nTip: F2 = demo instant win",
      },
      {
        title: "Coin Rewards",
        body: "3 Coins: +1 Health\n6 Coins: +12s Time\n9 Coins: +1 Shield block\n10 Coins: Level clear",
      },
    ];

    this.add.rectangle(cx, cy, this.scale.width, this.scale.height, 0x020617, 0.55);

    this.add.text(cx, 70, "LEVEL PREVIEW", {
      fontFamily: "Verdana",
      fontSize: `${Math.round(42 * textScale)}px`,
      color: "#f8fafc",
      stroke: "#0f172a",
      strokeThickness: 6,
    }).setOrigin(0.5);

    this.panel = this.add.rectangle(cx, cy + 10, 760, 320, 0x0f172a, 0.58)
      .setStrokeStyle(2, 0x94a3b8, 0.9);

    this.titleText = this.add.text(cx, cy - 86, "", {
      fontFamily: "Verdana",
      fontSize: `${Math.round(34 * textScale)}px`,
      color: "#f8fafc",
      stroke: "#111827",
      strokeThickness: 4,
    }).setOrigin(0.5);

    this.bodyText = this.add.text(cx, cy - 4, "", {
      fontFamily: "Consolas",
      fontSize: `${Math.round(24 * textScale)}px`,
      color: "#e2e8f0",
      align: "center",
      lineSpacing: 10,
    }).setOrigin(0.5);

    this.pageText = this.add.text(cx - 340, cy + 136, "", {
      fontFamily: "Consolas",
      fontSize: `${Math.round(18 * textScale)}px`,
      color: "#cbd5e1",
    }).setOrigin(0, 0.5);

    this.nextBtn = this.add.rectangle(cx + 280, cy + 136, 170, 44, 0x1d4ed8, 0.98)
      .setStrokeStyle(2, 0x93c5fd)
      .setInteractive({ useHandCursor: true });
    this.nextBtnText = this.add.text(cx + 280, cy + 136, "Next >", {
      fontFamily: "Consolas",
      fontSize: `${Math.round(25 * textScale)}px`,
      color: "#f8fafc",
    }).setOrigin(0.5);

    this.skipBtn = this.add.rectangle(cx + 90, cy + 136, 140, 44, 0x475569, 0.96)
      .setStrokeStyle(2, 0x94a3b8)
      .setInteractive({ useHandCursor: true });
    this.skipText = this.add.text(cx + 90, cy + 136, "Skip", {
      fontFamily: "Consolas",
      fontSize: `${Math.round(24 * textScale)}px`,
      color: "#f8fafc",
    }).setOrigin(0.5);

    this.nextBtn.on("pointerdown", () => this.next());
    this.skipBtn.on("pointerdown", () => this.startGame());

    this.input.keyboard.on("keydown-ENTER", () => this.next());
    this.input.keyboard.on("keydown-SPACE", () => this.next());
    this.input.keyboard.on("keydown-ESC", () => this.scene.start("MenuScene"));

    this.renderSlide();
  }

  renderSlide() {
    const s = this.slides[this.slideIndex];
    this.titleText.setText(s.title);
    this.bodyText.setText(s.body);
    this.pageText.setText(`Preview ${this.slideIndex + 1}/${this.slides.length}`);

    const isLast = this.slideIndex === this.slides.length - 1;
    this.nextBtn.setFillStyle(isLast ? 0x16a34a : 0x1d4ed8, 0.98);
    this.nextBtnText.setText(isLast ? "Start Game" : "Next >");
  }

  next() {
    if (this.slideIndex < this.slides.length - 1) {
      this.slideIndex += 1;
      this.renderSlide();
      return;
    }
    this.startGame();
  }

  startGame() {
    Platformer.Settings.current.convenience.introSeen = true;
    Platformer.Settings.save();

    Platformer.beeper.unlock();
    const difficulty = Platformer.Settings.current.gameplay.difficulty;
    const baseLives = difficulty === "easy" ? 3 : (difficulty === "hard" ? 1 : 2);

    if (this.scene.isActive("UIScene") || this.scene.isPaused("UIScene")) {
      this.scene.stop("UIScene");
    }
    if (this.scene.isActive("GameScene") || this.scene.isPaused("GameScene")) {
      this.scene.stop("GameScene");
    }

    this.registry.set("coins", 0);
    this.registry.set("health", 3);
    this.registry.set("lives", baseLives);
    this.registry.set("level", 1);
    this.scene.start("GameScene", { level: 1 });
    this.scene.launch("UIScene");
  }
};
  /* <<< scenes/intro-scene.js */

  /* >>> scenes/options-scene.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.OptionsScene = class extends Phaser.Scene {
  constructor() {
    super("OptionsScene");
    this.awaitingControl = null;
    this.rebindHint = null;
    this.dom = null;
    this.boundKeydown = null;
    this.returnTo = "menu";
    this.backBtn = null;
    this.bgSky = null;
    this.bgMid = null;
    this.bgGround = null;
    this.bgAccentTop = null;
    this.bgAccentBottom = null;
    this.bgOrbs = [];
    this.bgLines = [];
    this.onResize = null;
    this.overlayShade = null;
    this.titleText = null;
    this.hintText = null;
    this.backBtnText = null;
    this.domWrap = null;
    this.optScrollEl = null;
    this.boundDomWheel = null;
    this.domRecoveryUntil = 0;
    this.domRecoveredOnce = false;
    this.nativeViewport = null;
    this.viewportPollEvent = null;
  }

  getResolutionPresets() {
    return [
      "854x480",
      "1024x576",
      "1280x720",
      "1366x768",
      "1600x900",
      "1920x1080",
      "2560x1440",
      "3840x2160",
    ];
  }

  parseResolutionPreset(text) {
    const m = String(text || "").trim().match(/^(\d{3,5})x(\d{3,5})$/i);
    if (!m) return null;
    const w = Number(m[1]);
    const h = Number(m[2]);
    if (!Number.isFinite(w) || !Number.isFinite(h)) return null;
    return { width: w, height: h };
  }

  init(data) {
    this.returnTo = data && data.returnTo ? data.returnTo : "menu";
    if (Platformer.Debug) Platformer.Debug.log("OptionsScene", `Opened (returnTo=${this.returnTo}).`);
  }

  create() {
    try {
      if (Platformer.Debug) Platformer.Debug.log("OptionsScene.create", "Begin create.");
      const s = Platformer.Settings.current;
      const cx = this.scale.width / 2;
      const cy = this.scale.height / 2;

    this.createMenuLikeBackdrop();
    this.layoutBackdrop();
    this.titleText = this.add.text(cx, 48, "OPTIONS", {
      fontFamily: "Verdana",
      fontSize: "42px",
      color: "#f8fafc",
      stroke: "#0f172a",
      strokeThickness: 6,
    }).setOrigin(0.5).setDepth(95);

    this.rebindHint = this.add.text(cx, 92, "Click a key button to rebind. Press ESC to return.", {
      fontFamily: "Consolas",
      fontSize: "18px",
      color: "#cbd5e1",
    }).setOrigin(0.5).setDepth(95);

    const wrap = document.createElement("div");
    wrap.style.width = "min(1180px, 94vw)";
    wrap.style.maxHeight = "74vh";
    wrap.style.overflowY = "hidden";
    wrap.style.padding = "6px";
    wrap.style.display = "flex";
    wrap.style.flexDirection = "column";
    wrap.style.position = "relative";
    wrap.style.fontFamily = "Consolas, monospace";
    wrap.style.color = "#e2e8f0";

    const css = `
      <style>
        .opt-grid { display:grid; grid-template-columns: repeat(2, minmax(340px, 1fr)); gap: 12px; }
        .opt-scroll {
          overflow-y:auto;
          flex:1 1 auto;
          min-height: 0;
          height: 100%;
          padding-right: 10px;
          padding-bottom: 84px;
          box-sizing: border-box;
        }
        .opt-card { background: rgba(15,23,42,0.82); border:2px solid #334155; border-radius:10px; padding: 12px; box-shadow: 0 6px 18px rgba(2,6,23,0.35); }
        .opt-title { margin: 0 0 10px 0; color:#f8fafc; font-size: 22px; letter-spacing: 0.5px; }
        .opt-row { display:flex; justify-content:space-between; align-items:center; gap:10px; margin: 8px 0; }
        .opt-row > span { color:#cbd5e1; }
        .opt-card select, .opt-card input[type="text"], .opt-card button {
          background:#1e293b; color:#e2e8f0; border:1px solid #475569; border-radius:6px; padding: 4px 8px; font-family:inherit;
        }
        .opt-card input[type="range"] { width: 170px; }
        .opt-actions {
          display:flex; gap:10px; justify-content:flex-end;
          position: absolute; left: 8px; right: 8px; bottom: 8px; z-index: 5;
          background: rgba(2,6,23,0.92); border: 1px solid #334155; border-radius: 8px; padding: 10px;
        }
        .opt-actions button { background:#0f172a; color:#f8fafc; border:2px solid #64748b; border-radius:8px; padding:8px 12px; cursor:pointer; }
        .opt-actions #saveBack { border-color:#22d3ee; }
        @media (max-width: 900px) { .opt-grid { grid-template-columns: 1fr; } }
      </style>
    `;
    const cardStart = (title) => `<section class="opt-card"><h3 class="opt-title">${title}</h3>`;
    const cardEnd = () => `</section>`;
    const row = (label, control) => `<div class="opt-row"><span>${label}</span><span>${control}</span></div>`;

    wrap.innerHTML = [
      css,
      `<div class="opt-scroll"><div class="opt-grid">`,
      cardStart("Gameplay"),
      row("Difficulty", `<select id="difficulty"><option value="easy">Easy</option><option value="normal">Normal</option><option value="hard">Hard</option></select>`),
      cardEnd(),

      cardStart("Controls"),
      row("Left", `<button data-bind="left">${s.controls.left}</button>`),
      row("Right", `<button data-bind="right">${s.controls.right}</button>`),
      row("Jump", `<button data-bind="jump">${s.controls.jump}</button>`),
      row("Dash", `<button data-bind="dash">${s.controls.dash}</button>`),
      row("Attack", `<button data-bind="attack">${s.controls.attack}</button>`),
      row("Interact", `<button data-bind="interact">${s.controls.interact}</button>`),
      row("Pause", `<button data-bind="pause">${s.controls.pause}</button>`),
      cardEnd(),

      cardStart("Accessibility"),
      row("Text size", `<select id="textSize"><option value="small">Small</option><option value="medium">Medium</option><option value="large">Large</option></select>`),
      row("Colorblind mode", `<select id="colorblindMode"><option value="off">Off</option><option value="protanopia">Protanopia</option><option value="deuteranopia">Deuteranopia</option><option value="tritanopia">Tritanopia</option></select>`),
      row("Reduce screen shake", `<input id="reduceScreenShake" type="range" min="0" max="100" step="1" /><span id="reduceScreenShakeVal"></span>`),
      row("Reduced motion", `<select id="reducedMotion"><option value="off">Off</option><option value="on">On</option></select>`),
      row("Flash reduction", `<select id="flashReduction"><option value="off">Off</option><option value="on">On</option></select>`),
      row("Subtitles", `<select id="subtitles"><option value="off">Off</option><option value="on">On</option></select>`),
      row("Audio cues", `<select id="audioCues"><option value="off">Off</option><option value="on">On</option></select>`),
      cardEnd(),

      cardStart("Video"),
      row("Display mode", `<select id="fullscreen"><option value="off">Windowed</option><option value="borderless">Borderless</option><option value="on">Fullscreen</option></select>`),
      row("Resolution", `<select id="resolutionPreset">${this.getResolutionPresets().map((p) => `<option value="${p}">${p}</option>`).join("")}</select>`),
      row("Resolution scale", `<input id="resolutionScale" type="range" min="50" max="100" step="1" /><span id="resolutionScaleVal"></span>`),
      row("Pixel-perfect", `<select id="pixelPerfect"><option value="off">Off</option><option value="on">On</option></select>`),
      row("VSync", `<select id="vsync"><option value="off">Off</option><option value="on">On</option></select>`),
      row("FPS cap", `<select id="fpsCap"><option value="30">30</option><option value="60">60</option><option value="unlimited">Unlimited</option></select>`),
      row("Camera smoothing", `<input id="cameraSmoothing" type="range" min="0" max="100" step="1" /><span id="cameraSmoothingVal"></span>`),
      row("Brightness", `<input id="brightness" type="range" min="0.8" max="1.2" step="0.01" /><span id="brightnessVal"></span>`),
      cardEnd(),

      cardStart("Audio"),
      row("Master volume", `<input id="master" type="range" min="0" max="100" step="1" /><span id="masterVal"></span>`),
      row("Music volume", `<input id="music" type="range" min="0" max="100" step="1" /><span id="musicVal"></span>`),
      row("SFX volume", `<input id="sfx" type="range" min="0" max="100" step="1" /><span id="sfxVal"></span>`),
      row("UI volume", `<input id="ui" type="range" min="0" max="100" step="1" /><span id="uiVal"></span>`),
      row("Dynamic range", `<select id="dynamicRange"><option value="night">Night</option><option value="normal">Normal</option><option value="wide">Wide</option></select>`),
      row("Mute when unfocused", `<select id="muteWhenUnfocused"><option value="off">Off</option><option value="on">On</option></select>`),
      cardEnd(),

      cardStart("Save / Convenience"),
      row("Auto-save", `<select id="autoSave"><option value="off">Off</option><option value="on">On</option></select>`),
      row("Checkpoint frequency", `<select id="checkpointFrequency"><option value="sparse">Sparse</option><option value="standard">Standard</option><option value="frequent">Frequent</option></select>`),
      row("Speedrun mode", `<select id="speedrunMode"><option value="off">Off</option><option value="on">On</option></select>`),
      cardEnd(),

      cardStart("Updates"),
      row("Online update check", `<select id="updatesEnabled"><option value="off">Off</option><option value="on">On</option></select>`),
      row("Auto update + restart", `<select id="autoUpdate"><option value="on">On</option><option value="off">Off</option></select>`),
      row("Update source", `<input id="updateSource" type="text" readonly style="opacity:0.85" />`),
      row("Current version", `<input id="currentVersion" type="text" readonly style="opacity:0.85" />`),
      cardEnd(),
      `</div></div>`,

      `<div class="opt-actions">`,
      `<button id="resetDefaults">Reset defaults</button>`,
      `<button id="saveBack">Save + Back</button>`,
      `</div>`,
    ].join("");

    this.domWrap = wrap;
    this.dom = null;
    wrap.style.position = "fixed";
    wrap.style.left = "50%";
    wrap.style.top = "50%";
    wrap.style.transform = "translate(-50%, -50%)";
    wrap.style.zIndex = "1000000";
    wrap.style.display = "block";
    wrap.style.opacity = "1";
    wrap.style.visibility = "visible";
    wrap.style.pointerEvents = "auto";
    document.body.appendChild(wrap);
    this.domRecoveryUntil = this.time.now + 1200;
    this.domRecoveredOnce = false;
    this.startNativeViewportPolling();
    this.backBtn = this.add.rectangle(96, 44, 156, 46, 0xdc2626, 0.98)
      .setStrokeStyle(3, 0xfee2e2)
      .setOrigin(0, 0.5)
      .setScrollFactor(0)
      .setDepth(97)
      .setInteractive({ useHandCursor: true });
    this.backBtnText = this.add.text(96, 44, "< BACK", {
      fontFamily: "Consolas",
      fontSize: "28px",
      color: "#ffffff",
      stroke: "#450a0a",
      strokeThickness: 5,
    }).setOrigin(0, 0.5).setDepth(98);
    this.backBtn.on("pointerdown", async () => {
      await applyAndSave();
      if (Platformer.Debug) Platformer.Debug.log("OptionsScene", "Back button pressed.");
      this.goBack();
    });

    const val = (id) => wrap.querySelector(`#${id}`);
    this.optScrollEl = wrap.querySelector(".opt-scroll");
    if (this.optScrollEl) {
      this.boundDomWheel = (event) => {
        this.optScrollEl.scrollTop += event.deltaY;
        event.preventDefault();
        event.stopPropagation();
      };
      this.optScrollEl.addEventListener("wheel", this.boundDomWheel, { passive: false });
    }
    const setSelect = (id, v) => { val(id).value = v; };
    const setRange = (id, v, suffix = "%") => {
      val(id).value = String(v);
      const txt = val(`${id}Val`);
      if (txt) txt.textContent = `${v}${suffix}`;
    };

    setSelect("difficulty", s.gameplay.difficulty);
    setSelect("textSize", s.accessibility.textSize);
    setSelect("colorblindMode", s.accessibility.colorblindMode);
    setRange("reduceScreenShake", s.accessibility.reduceScreenShake);
    setSelect("reducedMotion", s.accessibility.reducedMotion ? "on" : "off");
    setSelect("flashReduction", s.accessibility.flashReduction ? "on" : "off");
    setSelect("subtitles", s.accessibility.subtitles ? "on" : "off");
    setSelect("audioCues", s.accessibility.audioCues ? "on" : "off");

    const displayMode = s.video.displayMode || (s.video.fullscreen ? "fullscreen" : "windowed");
    setSelect("fullscreen", displayMode === "fullscreen" ? "on" : (displayMode === "borderless" ? "borderless" : "off"));
    setSelect("resolutionPreset", s.video.resolutionPreset || "1920x1080");
    setRange("resolutionScale", s.video.resolutionScale);
    setSelect("pixelPerfect", s.video.pixelPerfect ? "on" : "off");
    setSelect("vsync", s.video.vsync ? "on" : "off");
    setSelect("fpsCap", s.video.fpsCap);
    setRange("cameraSmoothing", s.video.cameraSmoothing);
    setRange("brightness", s.video.brightness.toFixed(2), "");

    setRange("master", s.audio.master);
    setRange("music", s.audio.music);
    setRange("sfx", s.audio.sfx);
    setRange("ui", s.audio.ui);
    setSelect("dynamicRange", s.audio.dynamicRange);
    setSelect("muteWhenUnfocused", s.audio.muteWhenUnfocused ? "on" : "off");

    setSelect("autoSave", s.convenience.autoSave ? "on" : "off");
    setSelect("checkpointFrequency", s.convenience.checkpointFrequency);
    setSelect("speedrunMode", s.convenience.speedrunMode ? "on" : "off");
    setSelect("updatesEnabled", s.updates.enabled ? "on" : "off");
    setSelect("autoUpdate", s.updates.autoUpdate === false ? "off" : "on");
    val("updateSource").value = s.updates.source || "GitHub Releases";
    val("currentVersion").value = (Platformer.BUILD_VERSION && String(Platformer.BUILD_VERSION).trim()) || s.updates.currentVersion || "1.0.0";

    ["reduceScreenShake", "resolutionScale", "cameraSmoothing", "brightness", "master", "music", "sfx", "ui"].forEach((id) => {
      val(id).addEventListener("input", () => {
        const suffix = id === "brightness" ? "" : "%";
        val(`${id}Val`).textContent = `${val(id).value}${suffix}`;
      });
    });

    wrap.querySelectorAll("[data-bind]").forEach((btn) => {
      btn.addEventListener("click", () => {
        this.awaitingControl = btn.getAttribute("data-bind");
        if (Platformer.Debug) Platformer.Debug.log("OptionsScene.rebind", `Awaiting key for ${this.awaitingControl}`);
        this.rebindHint.setText(`Press a key for ${this.awaitingControl.toUpperCase()}...`);
      });
    });

    const applyAndSave = async () => {
      const c = Platformer.Settings.current;
      c.gameplay.difficulty = val("difficulty").value;

      c.accessibility.textSize = val("textSize").value;
      c.accessibility.colorblindMode = val("colorblindMode").value;
      c.accessibility.reduceScreenShake = Number(val("reduceScreenShake").value);
      c.accessibility.reducedMotion = val("reducedMotion").value === "on";
      c.accessibility.flashReduction = val("flashReduction").value === "on";
      c.accessibility.subtitles = val("subtitles").value === "on";
      c.accessibility.audioCues = val("audioCues").value === "on";

      const fullscreenSel = val("fullscreen").value;
      c.video.displayMode = fullscreenSel === "on"
        ? "fullscreen"
        : (fullscreenSel === "borderless" ? "borderless" : "windowed");
      c.video.fullscreen = c.video.displayMode === "fullscreen";
      c.video.resolutionPreset = val("resolutionPreset").value || "1920x1080";
      c.video.resolutionScale = Number(val("resolutionScale").value);
      c.video.pixelPerfect = val("pixelPerfect").value === "on";
      c.video.vsync = val("vsync").value === "on";
      c.video.fpsCap = val("fpsCap").value;
      c.video.cameraSmoothing = Number(val("cameraSmoothing").value);
      c.video.brightness = Number(val("brightness").value);

      c.audio.master = Number(val("master").value);
      c.audio.music = Number(val("music").value);
      c.audio.sfx = Number(val("sfx").value);
      c.audio.ui = Number(val("ui").value);
      c.audio.dynamicRange = val("dynamicRange").value;
      c.audio.muteWhenUnfocused = val("muteWhenUnfocused").value === "on";

      c.convenience.autoSave = val("autoSave").value === "on";
      c.convenience.checkpointFrequency = val("checkpointFrequency").value;
      c.convenience.speedrunMode = val("speedrunMode").value === "on";

      c.updates.enabled = val("updatesEnabled").value === "on";
      c.updates.autoUpdate = val("autoUpdate").value === "on";
      c.updates.source = "GitHub Releases";
      c.updates.currentVersion = (Platformer.BUILD_VERSION && String(Platformer.BUILD_VERSION).trim()) || "1.0.0";
      c.updates.manifestUrl = "";
      c.updates.downloadUrl = "";

      await Platformer.Settings.save();
      try {
        this.game.events.emit("settings-changed", Platformer.deepClone(c));
      } catch (err) {
        if (Platformer.Debug) Platformer.Debug.error("OptionsScene.settings", `Emit failed: ${err && err.message ? err.message : err}`);
      }
      if (Platformer.Debug) {
        Platformer.Debug.log(
          "OptionsScene.settings",
          `Saved audio(m=${c.audio.master},mu=${c.audio.music},sfx=${c.audio.sfx}) video(mode=${c.video.displayMode},preset=${c.video.resolutionPreset},resScale=${c.video.resolutionScale},bright=${c.video.brightness})`
        );
      }
      this.applyRuntimeVideoSettings();
    };

    wrap.querySelector("#saveBack").addEventListener("click", async () => {
      await applyAndSave();
      if (Platformer.Debug) Platformer.Debug.log("OptionsScene", "Save + Back pressed.");
      this.goBack();
    });

    wrap.querySelector("#resetDefaults").addEventListener("click", () => {
      Platformer.Settings.reset();
      if (Platformer.Debug) Platformer.Debug.warn("OptionsScene", "Settings reset to defaults.");
      this.scene.restart();
    });

    this.boundKeydown = (event) => {
      if (!this.awaitingControl) return;
      event.preventDefault();
      const key = this.normalizeKey(event);
      Platformer.Settings.current.controls[this.awaitingControl] = key;
      Platformer.Settings.save();
      const btn = wrap.querySelector(`[data-bind="${this.awaitingControl}"]`);
      if (btn) btn.textContent = key;
      if (Platformer.Debug) Platformer.Debug.log("OptionsScene.rebind", `${this.awaitingControl} -> ${key}`);
      this.rebindHint.setText(`${this.awaitingControl.toUpperCase()} bound to ${key}`);
      this.awaitingControl = null;
    };

    window.addEventListener("keydown", this.boundKeydown, true);
    this.events.once("shutdown", () => this.cleanup());
      this.onResize = () => this.layoutOptions();
      this.scale.on("resize", this.onResize);
    this.layoutOptions();

      this.input.keyboard.on("keydown-ESC", async () => {
      if (this.awaitingControl) {
        this.awaitingControl = null;
        if (Platformer.Debug) Platformer.Debug.log("OptionsScene.rebind", "Rebind cancelled with ESC.");
        this.rebindHint.setText("Click a key button to rebind. Press ESC to return.");
        return;
      }
      await applyAndSave();
      if (Platformer.Debug) Platformer.Debug.log("OptionsScene", "ESC save + back.");
      this.goBack();
    });
      this.game.events.emit("options-ready");
      if (Platformer.Debug) Platformer.Debug.log("OptionsScene.create", "Ready.");
      this.time.delayedCall(16, () => {
        try {
          this.scene.bringToTop("OptionsScene");
          this.forceDomVisible("post-ready");
          if (Platformer.Debug) {
            Platformer.Debug.log("OptionsScene.create", `Post-ready visibility check dom=${!!this.domWrap} size=${this.scale.width}x${this.scale.height}`);
          }
        } catch (err2) {
          if (Platformer.Debug) Platformer.Debug.error("OptionsScene.create", `Post-ready check failed: ${err2 && err2.message ? err2.message : err2}`);
        }
      });
    } catch (err) {
      if (Platformer.Debug) {
        Platformer.Debug.error("OptionsScene.create", err && err.stack ? err.stack : String(err));
      }
      try {
        this.game.events.emit("options-failed", { message: err && err.message ? err.message : String(err) });
      } catch (_e) {}
      try {
        this.cleanup();
      } catch (_e) {}
      // Ensure user is never stuck on a blank overlay if options init fails.
      this.goBack();
    }
  }

  createMenuLikeBackdrop() {
    const w = this.scale.width;
    const h = this.scale.height;
    this.bgSky = this.add.rectangle(0, 0, w, h, 0x081336, 0.62).setOrigin(0, 0);
    this.bgMid = this.add.rectangle(0, 0, w, 220, 0x132a56, 0.52).setOrigin(0, 0);
    this.bgGround = this.add.rectangle(0, 0, w, 120, 0x0b6f49, 0.46).setOrigin(0, 0);
    this.bgAccentTop = this.add.rectangle(0, 0, w, Math.round(h * 0.42), 0x1e3a8a, 0.16).setOrigin(0, 0);
    this.bgAccentBottom = this.add.rectangle(0, 0, w, Math.round(h * 0.2), 0x34d399, 0.13).setOrigin(0, 0);

    const orbA = this.add.circle(w * 0.78, h * 0.22, 150, 0x53e0ff, 0.08).setBlendMode(Phaser.BlendModes.ADD);
    const orbB = this.add.circle(w * 0.2, h * 0.3, 110, 0xff71c7, 0.07).setBlendMode(Phaser.BlendModes.ADD);
    this.bgOrbs = [orbA, orbB];

    this.bgLines = [];
    for (let i = 0; i < 10; i += 1) {
      const line = this.add.rectangle(
        Phaser.Math.Between(0, w),
        Phaser.Math.Between(40, h - 80),
        Phaser.Math.Between(70, 150),
        2,
        i % 3 === 0 ? 0xff71c7 : 0x53e0ff,
        0.18
      ).setOrigin(0, 0.5);
      line.moveSpeed = Phaser.Math.FloatBetween(26, 62);
      this.bgLines.push(line);
    }
  }

  layoutBackdrop() {
    if (!this.bgSky) return;
    const w = this.scale.width;
    const h = this.scale.height;
    const cy = h / 2;
    this.bgSky.setSize(w, h).setPosition(0, 0);
    this.bgMid.setSize(w, 220).setPosition(0, cy + 160);
    this.bgGround.setSize(w, 120).setPosition(0, cy + 220);
    this.bgAccentTop.setSize(w, Math.round(h * 0.42)).setPosition(0, 0);
    this.bgAccentBottom.setSize(w, Math.round(h * 0.2)).setPosition(0, h - Math.round(h * 0.24));
  }

  layoutOptions() {
    const w = this.scale.width;
    const h = this.scale.height;
    const vw = Math.max(640, (this.nativeViewport && this.nativeViewport.w) || window.innerWidth || w || 640);
    const vh = Math.max(360, (this.nativeViewport && this.nativeViewport.h) || window.innerHeight || h || 360);
    const cx = w / 2;
    const cy = h / 2;
    this.layoutBackdrop();
    if (this.titleText) this.titleText.setPosition(cx, 48);
    if (this.rebindHint) this.rebindHint.setPosition(cx, 92);

    if (this.domWrap) {
      const panelH = Math.floor(Math.max(320, vh * 0.74));
      this.domWrap.style.width = `${Math.floor(Math.min(1180, vw * 0.94))}px`;
      this.domWrap.style.maxHeight = `${panelH}px`;
      this.domWrap.style.height = `${panelH}px`;
    }
    if (this.optScrollEl) {
      this.optScrollEl.style.height = "100%";
      this.optScrollEl.style.maxHeight = "100%";
      this.optScrollEl.style.overflowY = "auto";
    }
    const topY = 130;
    const panelH = Math.floor(Math.max(320, vh * 0.74));
    const domY = Math.min((vh / 2) + 28, topY + (panelH / 2));
    if (this.domWrap) {
      this.domWrap.style.left = `${Math.round(vw / 2)}px`;
      this.domWrap.style.top = `${Math.round(domY)}px`;
      this.domWrap.style.transform = "translate(-50%, -50%)";
      this.forceDomVisible("layout");
    }

    if (this.backBtn) this.backBtn.setPosition(14, 44);
    if (this.backBtnText) this.backBtnText.setPosition(36, 44);
  }

  goBack() {
    if (this.returnTo === "pause") {
      if (Platformer.Debug) Platformer.Debug.log("OptionsScene", "Returning to pause menu.");
      this.scene.stop();
      this.game.events.emit("options-closed-to-pause");
      return;
    }
    if (Platformer.Debug) Platformer.Debug.log("OptionsScene", "Returning to main menu.");
    this.scene.start("MenuScene");
  }

  normalizeKey(event) {
    const k = (event.key || "").toUpperCase();
    if (k === " ") return "SPACE";
    if (k === "ESCAPE") return "ESC";
    if (k === "ARROWLEFT") return "LEFT";
    if (k === "ARROWRIGHT") return "RIGHT";
    if (k === "ARROWUP") return "UP";
    if (k === "ARROWDOWN") return "DOWN";
    if (k === "CONTROL") return "CTRL";
    return k;
  }

  applyRuntimeVideoSettings() {
    const s = Platformer.Settings.current.video;
    const mode = s.displayMode || (s.fullscreen ? "fullscreen" : "windowed");
    const parsed = this.parseResolutionPreset(s.resolutionPreset || "1920x1080");
    const targetW = parsed ? parsed.width : 1920;
    const targetH = parsed ? parsed.height : 1080;
    if (window.pywebview && window.pywebview.api && typeof window.pywebview.api.set_window_mode === "function") {
      window.pywebview.api.set_window_mode(mode, targetW, targetH)
        .then((res) => {
          if (res && res.ok) {
            if (Platformer.Debug) Platformer.Debug.log("Options.fullscreen", `native mode=${res.mode || mode} size=${res.width || targetW}x${res.height || targetH}`);
          } else if (Platformer.Debug) {
            Platformer.Debug.warn("Options.fullscreen", (res && res.message) || "native window mode call failed");
          }
        })
        .catch((err) => {
          if (Platformer.Debug) Platformer.Debug.warn("Options.fullscreen", `native window mode error: ${err && err.message ? err.message : err}`);
        });
      return;
    }
    if (window.pywebview && window.pywebview.api && typeof window.pywebview.api.set_fullscreen === "function") {
      window.pywebview.api.set_fullscreen(mode === "fullscreen")
        .then((res) => {
          if (res && res.ok) {
            if (Platformer.Debug) Platformer.Debug.log("Options.fullscreen", `native fullscreen=${res.fullscreen}`);
          } else if (Platformer.Debug) {
            Platformer.Debug.warn("Options.fullscreen", (res && res.message) || "native fullscreen call failed");
          }
        })
        .catch((err) => {
          if (Platformer.Debug) Platformer.Debug.warn("Options.fullscreen", `native fullscreen error: ${err && err.message ? err.message : err}`);
        });
      return;
    }

    if (mode === "fullscreen" && !this.scale.isFullscreen) {
      this.scale.startFullscreen();
      if (Platformer.Debug) Platformer.Debug.log("Options.fullscreen", "browser fullscreen start requested");
    }
    if (mode !== "fullscreen" && this.scale.isFullscreen) {
      this.scale.stopFullscreen();
      if (Platformer.Debug) Platformer.Debug.log("Options.fullscreen", "browser fullscreen stop requested");
    }
  }

  shutdown() {
    this.cleanup();
  }

  cleanup() {
    if (this.onResize) {
      this.scale.off("resize", this.onResize);
      this.onResize = null;
    }
    if (this.optScrollEl && this.boundDomWheel) {
      this.optScrollEl.removeEventListener("wheel", this.boundDomWheel);
    }
    this.boundDomWheel = null;
    this.optScrollEl = null;
    if (this.viewportPollEvent) {
      this.viewportPollEvent.remove(false);
      this.viewportPollEvent = null;
    }
    this.nativeViewport = null;
    if (this.domWrap && this.domWrap.parentNode) {
      this.domWrap.parentNode.removeChild(this.domWrap);
    }
    this.domWrap = null;
    this.dom = null;
    if (this.boundKeydown) {
      window.removeEventListener("keydown", this.boundKeydown, true);
      this.boundKeydown = null;
    }
  }

  forceDomVisible(reason = "unknown") {
    if (!this.domWrap) return;
    if (!this.domWrap.parentNode) {
      document.body.appendChild(this.domWrap);
    }
    this.domWrap.style.position = "fixed";
    this.domWrap.style.zIndex = "1000000";
    this.domWrap.style.display = "block";
    this.domWrap.style.opacity = "1";
    this.domWrap.style.visibility = "visible";
    this.domWrap.style.pointerEvents = "auto";
    const rect = this.domWrap.getBoundingClientRect();
    const likelyHidden = rect.width < 40 || rect.height < 40;
    if (likelyHidden) {
      const vw = Math.max(640, window.innerWidth || this.scale.width || 640);
      const vh = Math.max(360, window.innerHeight || this.scale.height || 360);
      this.domWrap.style.width = `${Math.floor(Math.min(1180, vw * 0.94))}px`;
      this.domWrap.style.maxHeight = `${Math.floor(Math.max(320, vh * 0.74))}px`;
      this.domWrap.style.height = `${Math.floor(Math.max(320, vh * 0.74))}px`;
      this.domWrap.style.left = `${Math.round(vw / 2)}px`;
      this.domWrap.style.top = `${Math.round(vh / 2)}px`;
    }
    if (!this.domRecoveredOnce && Platformer.Debug) {
      Platformer.Debug.log(
        "OptionsScene.dom",
        `forceDomVisible(${reason}) rect=${Math.round(rect.width)}x${Math.round(rect.height)} at ${Math.round(rect.x)},${Math.round(rect.y)}`
      );
      this.domRecoveredOnce = true;
    }
  }

  startNativeViewportPolling() {
    if (!(window.pywebview && window.pywebview.api && typeof window.pywebview.api.get_window_size === "function")) {
      return;
    }
    let attempts = 0;
    const pollOnce = () => {
      if (!this.sys || !this.sys.settings || !this.sys.settings.active) return;
      attempts += 1;
      window.pywebview.api.get_window_size()
        .then((res) => {
          if (!res || !res.ok) return;
          const nw = Math.max(640, Number(res.width) || 0);
          const nh = Math.max(360, Number(res.height) || 0);
          if (!Number.isFinite(nw) || !Number.isFinite(nh)) return;
          const changed = !this.nativeViewport || this.nativeViewport.w !== nw || this.nativeViewport.h !== nh;
          this.nativeViewport = { w: nw, h: nh };
          if (changed) {
            this.layoutOptions();
            if (Platformer.Debug) {
              Platformer.Debug.log("OptionsScene.viewport", `native ${nw}x${nh} fullscreen=${!!res.fullscreen} attempt=${attempts}`);
            }
          }
        })
        .catch((err) => {
          if (attempts <= 2 && Platformer.Debug) {
            Platformer.Debug.warn("OptionsScene.viewport", `native poll failed: ${err && err.message ? err.message : err}`);
          }
        });
      if (attempts >= 12 && this.viewportPollEvent) {
        this.viewportPollEvent.remove(false);
        this.viewportPollEvent = null;
      }
    };
    pollOnce();
    this.viewportPollEvent = this.time.addEvent({ delay: 140, loop: true, callback: pollOnce });
  }

  update(time, delta) {
    if (this.domWrap && time <= this.domRecoveryUntil) {
      this.forceDomVisible("update-recovery");
    }
    const dt = Math.max(0.001, delta / 1000);
    const w = this.scale.width;
    this.bgLines.forEach((line) => {
      if (!line || !line.active) return;
      line.x -= line.moveSpeed * dt;
      if (line.x < -line.width - 10) line.x = w + Phaser.Math.Between(10, 80);
    });
    const t = time * 0.001;
    if (this.bgOrbs && this.bgOrbs.length === 2) {
      this.bgOrbs[0].x = this.scale.width * 0.78 + Math.cos(t * 0.6) * 16;
      this.bgOrbs[1].x = this.scale.width * 0.2 + Math.sin(t * 0.75) * 18;
    }
  }
};
  /* <<< scenes/options-scene.js */

  /* >>> scenes/game-scene.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.GameScene = class extends Phaser.Scene {
  constructor() {
    super("GameScene");
    this.solids = null;
    this.oneWays = null;
    this.hazards = null;
    this.coins = null;
    this.enemies = null;
    this.checkpoints = null;
    this.player = null;
    this.cursors = null;
    this.keys = null;
    this.respawnPoint = new Phaser.Math.Vector2(64, 64);
    this.lastOnGroundTime = 0;
    this.lastJumpPressedTime = -9999;
    this.isJumpHeld = false;
    this.jumpsUsed = 0;
    this.lastDamageTime = -9999;
    this.isDead = false;
    this.spawnPoint = new Phaser.Math.Vector2(64, 64);
    this.mapRows = [];
    this.mapWidth = 0;
    this.mapHeight = 0;
    this.levelComplete = false;
    this.parallax = [];
    this.lastEnemyEdgeCheckTime = 0;
    this.playerHealthBarBg = null;
    this.playerHealthBarFill = null;
    this.hazardProjectiles = null;
    this.hazardShooters = [];
    this.lastHazardShotAt = 0;
    this.projectileIntervalMs = 1200;
    this.projectileSpeed = 220;
    this.levelTimeRemainingMs = 90000;
    this.lastTickTime = 0;
    this.lastTimerSecond = -1;
    this.threatActive = false;
    this.idleAnimWarned = false;
    this.useImportedCharacter = false;
    this.diagLastAt = 0;
    this.diagCooldowns = {};
    this.facingDir = 1;
    this.isDashing = false;
    this.dashEndsAt = 0;
    this.lastDashAt = -9999;
    this.attackActiveUntil = 0;
    this.lastAttackAt = -9999;
    this.wasGroundedLastFrame = false;
    this.airbornePeakSpeedY = 0;
    this.coinRewardState = {};
    this.shieldCharges = 0;
    this.lastAuxHudAt = 0;
    this.onSettingsChanged = null;
    this.jetpack = null;
    this.jetpackFuelPercent = 100;
    this.jetpackActive = false;
    this.jetpackFlame = null;
    this.jetpackFlameOffsetY = 22;
    this.tinyGridMode = false;
    this.playerTuning = null;
    this.jetpackTuning = null;
    this.hpBarCfg = null;
    this.lastTileEmbedLogAt = 0;
    this.tileEmbedFrames = 0;
    this.playerBodyWorldW = 0;
    this.playerBodyWorldH = 0;
    this.playerHitboxProfile = { w: 9, h: 24, ox: 0, oy: -3 };
    this.hitboxOverlay = null;
    this.hitboxOverlayEnabled = false;
    this.onHitboxesToggle = null;
    this.onPlayerHitboxChanged = null;
    this.lastHitboxDrawAt = 0;
    this.ldtkVisualTiles = [];
    this.usesLdtkLevel = false;
  }

  init(data) {
    const settings = Platformer.Settings.current;
    const difficulty = settings.gameplay.difficulty;
    const startLives = difficulty === "easy" ? 3 : (difficulty === "hard" ? 1 : 2);
    const timerSeconds = difficulty === "easy" ? 120 : (difficulty === "hard" ? 70 : 90);
    const carryState = !!(data && data.carryState);

    this.currentLevel = data.level || 1;
    this.currentNodeId = data && data.nodeId ? String(data.nodeId) : null;
    this.currentWorldId = data && data.worldId ? String(data.worldId) : null;
    this.registry.set("level", this.currentLevel);
    if (!carryState) {
      this.registry.set("health", 3);
      this.registry.set("lives", startLives);
    } else {
      this.registry.set("health", Math.max(1, this.registry.get("health") || 3));
      this.registry.set("lives", Math.max(1, this.registry.get("lives") || startLives));
    }
    this.registry.set("coins", 0);
    this.registry.set("timeLeft", timerSeconds);
    this.registry.set("threat", "CALM");
    this.registry.set("dashCd", 0);
    this.registry.set("shield", 0);
    this.registry.set("jetpackFuel", 100);
    this.isDead = false;
    this.levelComplete = false;
    this.levelTimeRemainingMs = timerSeconds * 1000;
    this.lastTickTime = 0;
    this.lastTimerSecond = -1;
    this.lastHazardShotAt = 0;
    this.threatActive = false;
    this.facingDir = 1;
    this.isDashing = false;
    this.dashEndsAt = 0;
    this.lastDashAt = -9999;
    this.attackActiveUntil = 0;
    this.lastAttackAt = -9999;
    this.wasGroundedLastFrame = false;
    this.airbornePeakSpeedY = 0;
    this.coinRewardState = {};
    this.shieldCharges = 0;
    this.lastAuxHudAt = 0;
    this.jetpackFuelPercent = 100;
    this.jetpackActive = false;
  }

  create() {
    const { PLAYER, TILE } = Platformer.Config;
    const settings = Platformer.Settings.current;
    const difficulty = settings.gameplay.difficulty;
    const checkpointMode = settings.convenience.checkpointFrequency;
    this.tinyGridMode = TILE <= 8;
    this.playerTuning = this.buildPlayerTuning(PLAYER);
    this.jetpackTuning = this.buildJetpackTuning(Platformer.Config.JETPACK);
    const P = this.playerTuning;
    const enemySpeedScale = this.tinyGridMode ? 0.34 : 1;

    const ldtkLevelData = this.tryBuildLevelFromLdtk(this.currentLevel || 1);
    if (ldtkLevelData && Array.isArray(ldtkLevelData.rows) && ldtkLevelData.rows.length) {
      this.mapRows = ldtkLevelData.rows;
      this.usesLdtkLevel = true;
      if (Platformer.Debug) {
        Platformer.Debug.log("GameScene.ldtk", `Using native LDtk map for level=${this.currentLevel} size=${ldtkLevelData.width}x${ldtkLevelData.height}`);
      }
    } else {
      this.mapRows = Platformer.createLevelData(this.currentLevel || 1);
      this.usesLdtkLevel = false;
    }
    this.mapHeight = this.mapRows.length;
    this.mapWidth = this.mapRows[0].length;
    this.normalizeTurretTiles();
    this.normalizeEnemyTiles();

    this.physics.world.gravity.y = P.gravity;
    this.physics.world.setBounds(0, 0, this.mapWidth * TILE, this.mapHeight * TILE + 180);

    if (this.usesLdtkLevel) {
      this.cameras.main.setBackgroundColor("#0f132a");
      this.renderLdtkVisualTiles();
      if (Platformer.Debug) {
        Platformer.Debug.log("GameScene.ldtk", "LDtk level active: placeholder ground rendering disabled (collision-only solids).");
      }
    } else {
      this.createTokyoBackdrop();
    }

    this.solids = this.physics.add.staticGroup();
    this.oneWays = this.physics.add.staticGroup();
    this.hazards = this.physics.add.staticGroup();
    this.coins = this.physics.add.staticGroup();
    this.checkpoints = this.physics.add.staticGroup();
    this.enemies = this.physics.add.group({ allowGravity: true, immovable: false });
    this.enemyPatrolSpeed = (difficulty === "hard" ? 95 : (difficulty === "easy" ? 48 : 60)) * enemySpeedScale;
    this.hazardDamage = difficulty === "hard" ? 2 : 1;
    this.hazardCooldownScale = difficulty === "easy" ? 1.35 : (difficulty === "hard" ? 0.8 : 1);
    this.projectileIntervalMs = difficulty === "hard" ? 850 : (difficulty === "easy" ? 1500 : 1100);
    this.projectileSpeed = (difficulty === "hard" ? 270 : (difficulty === "easy" ? 180 : 230)) * enemySpeedScale;
    this.maxCheckpointCount = checkpointMode === "sparse" ? 1 : (checkpointMode === "frequent" ? 999 : (difficulty === "hard" ? 1 : 2));
    this.spawnCheckpointOnStart = checkpointMode === "frequent" || difficulty === "easy";
    this.hazardProjectiles = this.physics.add.group({ allowGravity: false, immovable: true });
    let checkpointCount = 0;

    for (let y = 0; y < this.mapHeight; y += 1) {
      for (let x = 0; x < this.mapWidth; x += 1) {
        const tile = this.mapRows[y][x];
        const px = x * TILE;
        const py = y * TILE;

        if (tile === "#") {
          const block = this.solids.create(px + TILE / 2, py + TILE / 2, "ground");
          if (this.usesLdtkLevel) {
            // Keep collider body but don't draw placeholder tile over LDtk visuals.
            block.setVisible(false);
            block.setAlpha(0);
          }
          block.refreshBody();
        }

        if (tile === "=") {
          const platform = this.oneWays.create(px + TILE / 2, py + Math.max(2, Math.round(TILE * 0.38)), "oneway");
          platform.refreshBody();
        }

        if (tile === "^") {
          const spike = this.hazards.create(px + TILE / 2, py + TILE / 2, "hazard");
          spike.setDisplaySize(TILE, TILE);
          spike.refreshBody();
        }

        if (tile === "C") {
          const coin = this.coins.create(px + TILE / 2, py + TILE / 2, "coin");
          if (this.tinyGridMode) coin.setDisplaySize(Math.max(5, TILE * 0.85), Math.max(5, TILE * 0.85));
          coin.refreshBody();
        }

        if (tile === "E" || tile === "F" || tile === "G" || tile === "H") {
          const enemyType = tile;
          const textureByType = { E: "enemy-e", F: "enemy-f", G: "enemy-g", H: "enemy-h" };
          const speedByType = { E: this.enemyPatrolSpeed, F: this.enemyPatrolSpeed * 0.9, G: this.enemyPatrolSpeed * 1.2, H: this.enemyPatrolSpeed * 0.75 };
          const enemy = this.enemies.create(px + TILE / 2, py + TILE / 2, textureByType[enemyType] || "enemy");
          const patrol = this.computeEnemyPatrolBounds(x, y);
          if (this.tinyGridMode) {
            enemy.setDisplaySize(10, 10);
            enemy.body.setSize(8, 8);
          } else {
            enemy.body.setSize(24, 24);
          }
          enemy.setBounce(0, 0);
          enemy.setCollideWorldBounds(true);
          enemy.setVelocityX(-speedByType[enemyType]);
          enemy.setData("patrolSpeed", speedByType[enemyType]);
          enemy.setData("direction", -1);
          enemy.setData("turnCooldownUntil", 0);
          enemy.setData("patrolMinX", patrol.minX);
          enemy.setData("patrolMaxX", patrol.maxX);
          enemy.setData("useBoundedPatrol", patrol.maxX - patrol.minX >= TILE * 2);
          enemy.setData("enemyType", enemyType);
          enemy.setData("nextJumpAt", this.time.now + 800 + x * 3);
          enemy.setData("hp", enemyType === "H" ? 2 : 1);
          enemy.setData("lastX", enemy.x);
          enemy.setData("stuckSince", this.time.now);
          enemy.setData("aiState", "patrol");
          enemy.setData("stateUntil", 0);
          enemy.setData("attackCooldownUntil", this.time.now + 700 + (x % 5) * 90);
        }

        if (tile === "K") {
          if (checkpointCount >= this.maxCheckpointCount) {
            continue;
          }
          const checkpoint = this.checkpoints.create(px + TILE / 2, py + TILE / 2, "checkpoint");
          if (this.tinyGridMode) checkpoint.setDisplaySize(Math.max(4, TILE * 0.75), Math.max(12, TILE * 2));
          checkpoint.setData("activeCheckpoint", false);
          checkpoint.refreshBody();
          checkpointCount += 1;
        }

        if (tile === "S") {
          this.spawnPoint.set(px + TILE / 2, py + TILE / 2);
        }
      }
    }

    this.player = this.physics.add.sprite(this.spawnPoint.x, this.spawnPoint.y, "player-idle-1");
    if (this.textures.exists("player-idle-sheet")) {
      this.player.setTexture("player-idle-sheet", 0);
      this.useImportedCharacter = true;
      if (Platformer.Debug) Platformer.Debug.log("GameScene.playerIdle", "Using imported player-idle-sheet.");
    } else if (Platformer.Debug) {
      Platformer.Debug.warn("GameScene.playerIdle", "player-idle-sheet missing, using fallback idle textures.");
    }
    const tinyGrid = TILE <= 8;
    if (this.useImportedCharacter) {
      if (tinyGrid) {
        this.player.setDisplaySize(32, 32);
        this.applyTinyPlayerHitboxProfile();
      } else {
        this.player.setDisplaySize(56, 56);
        this.player.body.setSize(22, 44, true);
      }
    } else if (tinyGrid) {
      this.player.setDisplaySize(32, 32);
      this.applyTinyPlayerHitboxProfile();
    } else {
      this.player.setDisplaySize(28, 38);
      this.player.body.setSize(20, 34);
    }
    this.alignPlayerBodyToFeet();
    if (this.tinyGridMode && Platformer.Debug && this.player && this.player.body) {
      Platformer.Debug.log(
        "GameScene.collision",
        `Tiny body initialized world=${this.player.body.width.toFixed(1)}x${this.player.body.height.toFixed(1)} scale=${this.player.scaleX.toFixed(3)},${this.player.scaleY.toFixed(3)}`
      );
    }
    this.player.setCollideWorldBounds(true);
    // Allow dash velocity to exceed normal run cap.
    this.player.setMaxVelocity(Math.max(P.maxSpeed, P.dashSpeed + 60), P.maxFallSpeed || 760);
    this.player.setDragX(P.drag);
    this.player.setAccelerationY(0);
    this.player.body.setGravityY(0);
    this.resolvePlayerEmbedding("spawn");

    this.respawnPoint.copy(this.spawnPoint);
    if (this.spawnCheckpointOnStart) {
      const extraStartCheckpoint = this.checkpoints.create(
        this.spawnPoint.x + (this.tinyGridMode ? TILE * 3 : 24),
        this.spawnPoint.y - (this.tinyGridMode ? TILE * 2 : 20),
        "checkpoint"
      );
      if (this.tinyGridMode) extraStartCheckpoint.setDisplaySize(Math.max(4, TILE * 0.75), Math.max(12, TILE * 2));
      extraStartCheckpoint.setData("activeCheckpoint", true);
      extraStartCheckpoint.setTint(0x22c55e);
      extraStartCheckpoint.refreshBody();
    }

    this.physics.add.collider(this.player, this.solids);
    this.physics.add.collider(this.enemies, this.solids);
    this.physics.add.collider(this.enemies, this.oneWays, null, this.enemyOneWayProcess, this);
    this.physics.add.collider(this.player, this.oneWays, null, this.oneWayProcess, this);

    this.physics.add.collider(this.player, this.hazards);
    this.physics.add.collider(this.hazardProjectiles, this.solids, (projectile) => projectile.destroy(), null, this);
    this.physics.add.collider(this.hazardProjectiles, this.oneWays, (projectile) => projectile.destroy(), null, this);
    this.physics.add.overlap(this.player, this.coins, (_, coin) => this.collectCoin(coin), null, this);
    this.physics.add.overlap(this.player, this.checkpoints, (_, cp) => this.activateCheckpoint(cp), null, this);
    this.physics.add.overlap(this.player, this.enemies, (_, enemy) => this.handleEnemyContact(enemy), null, this);
    this.physics.add.overlap(this.player, this.hazardProjectiles, (_, projectile) => {
      projectile.destroy();
      this.applyDamage(1);
    }, null, this);

    this.cameras.main.setBounds(0, 0, this.mapWidth * TILE, this.mapHeight * TILE);
    const smooth = Phaser.Math.Clamp(settings.video.cameraSmoothing / 100, 0, 1);
    const followLerp = this.tinyGridMode ? 1 : smooth;
    this.cameras.main.startFollow(this.player, true, followLerp, followLerp);
    this.cameras.main.roundPixels = !this.tinyGridMode;
    this.cameras.main.setDeadzone(this.tinyGridMode ? 56 : 180, this.tinyGridMode ? 40 : 120);
    this.cameras.main.setBackgroundColor("#0b1026");
    this.updateCameraFraming();
    this.scale.on("resize", this.updateCameraFraming, this);
    this.applyVideoSettings();
    this.createPlayerHealthBar();
    this.createJetpackFx();
    this.jetpack = new Platformer.JetpackController(this.jetpackTuning, {
      onJetpackStart: () => {
        if (Platformer.Debug) Platformer.Debug.log("GameScene.jetpack", "Jetpack thrust started.");
      },
      onJetpackStop: (_scene, ctrl, reason) => {
        if (Platformer.Debug) {
          Platformer.Debug.log("GameScene.jetpack", `Jetpack thrust stopped. reason=${reason} fuel=${Math.round(ctrl.fuelPercent)}%`);
        }
      },
    });
    this.jetpack.reset(true);
    this.jetpackFuelPercent = this.jetpack.fuelPercent;
    if (Platformer.Debug) {
      const j = Platformer.Config.JETPACK || {};
      Platformer.Debug.log(
        "GameScene.jetpack",
        `Init cap=${j.fuelCapacity}s drain=${j.drainRate}/s regen=${j.regenRate}/s tinyGrid=${this.tinyGridMode ? "yes" : "no"}`
      );
    }
    if (Platformer.Debug) {
      Platformer.Debug.log(
        "GameScene.tuning",
        `tinyGrid=${this.tinyGridMode ? "yes" : "no"} speed=${P.maxSpeed.toFixed(1)} jump=${P.jumpVelocity.toFixed(1)} gravity=${P.gravity.toFixed(1)}`
      );
    }
    this.registry.set("shield", this.shieldCharges);
    this.registry.set("jetpackFuel", this.jetpackFuelPercent);
    this.setupHitboxOverlay();

    this.cursors = this.input.keyboard.createCursorKeys();
    this.keys = this.input.keyboard.addKeys(this.buildControlKeyMap());
    this.onSettingsChanged = (nextSettings) => this.applyRuntimeSettings(nextSettings);
    this.game.events.on("settings-changed", this.onSettingsChanged);
    this.setupGameMusic();
    this.setupHazardShooters();
    this.initRuntimeDiagnostics();
    this.onRestartLevel = () => {
      if (Platformer.Debug) Platformer.Debug.warn("GameScene", "restart-level event received; restarting current level.");
      this.scene.restart({ level: this.currentLevel || 1 });
    };
    this.game.events.on("restart-level", this.onRestartLevel);

    this.events.emit("hud-update");
  }

  initRuntimeDiagnostics() {
    if (!Platformer.Debug) return;
    Platformer.Debug.log(
      "GameScene.diag",
      `Level ${this.currentLevel} booted. map=${this.mapWidth}x${this.mapHeight} enemies=${this.enemies ? this.enemies.countActive(true) : 0} turrets=${this.hazards ? this.hazards.countActive(true) : 0}`
    );
  }

  diagWarn(key, message, cooldownMs = 1600) {
    if (!Platformer.Debug) return;
    const now = this.time ? this.time.now : Date.now();
    const last = this.diagCooldowns[key] || 0;
    if (now - last < cooldownMs) return;
    this.diagCooldowns[key] = now;
    Platformer.Debug.warn(`GameScene.diag.${key}`, message);
  }

  runRuntimeDiagnostics(now) {
    if (!Platformer.Debug) return;
    if (!this.player || !this.player.body) {
      this.diagWarn("player_missing", "Player body missing during update.", 3000);
      return;
    }

    const worldW = this.mapWidth * Platformer.Config.TILE;
    const worldH = this.mapHeight * Platformer.Config.TILE + 200;
    const { x, y } = this.player;
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
      this.diagWarn("player_nan", `Invalid player position x=${x} y=${y}`, 0);
    }
    if (x < -140 || x > worldW + 140 || y < -200 || y > worldH + 260) {
      this.diagWarn("player_oob", `Player out of expected bounds x=${Math.round(x)} y=${Math.round(y)} world=${worldW}x${worldH}`);
    }

    const health = this.registry.get("health");
    const lives = this.registry.get("lives");
    const coins = this.registry.get("coins");
    if (!Number.isFinite(health) || health < -1 || health > 3) this.diagWarn("health_invalid", `health=${health}`);
    if (!Number.isFinite(lives) || lives < -1 || lives > 9) this.diagWarn("lives_invalid", `lives=${lives}`);
    if (!Number.isFinite(coins) || coins < 0 || coins > 9999) this.diagWarn("coins_invalid", `coins=${coins}`);

    let groundedEnemies = 0;
    let stuckEnemies = 0;
    this.enemies.children.each((enemy) => {
      if (!enemy || !enemy.active || !enemy.body) return;
      const ex = enemy.x;
      const ey = enemy.y;
      if (!Number.isFinite(ex) || !Number.isFinite(ey)) {
        this.diagWarn("enemy_nan", `enemy invalid pos x=${ex} y=${ey}`, 0);
        return;
      }
      if (ex < -80 || ex > worldW + 80 || ey > worldH + 200) {
        this.diagWarn("enemy_oob", `enemy out of bounds x=${Math.round(ex)} y=${Math.round(ey)}`);
      }
      if (enemy.body.blocked.down || enemy.body.touching.down) groundedEnemies += 1;
      const speedX = Math.abs(enemy.body.velocity.x || 0);
      if ((enemy.body.blocked.down || enemy.body.touching.down) && speedX < 8) stuckEnemies += 1;
    });

    if (this.enemies.countActive(true) > 0 && groundedEnemies === 0) {
      this.diagWarn("enemies_airborne", "All enemies airborne; check spawn/support tiles.", 2200);
    }
    if (stuckEnemies >= 2) {
      this.diagWarn("enemies_stalling", `${stuckEnemies} enemies currently stalled on ground.`, 1800);
    }

    this.hazards.children.each((hazard) => {
      if (!hazard || !hazard.active) return;
      const belowY = hazard.y + Platformer.Config.TILE * 0.55;
      if (!this.hasSupportAtWorld(hazard.x, belowY)) {
        this.diagWarn("turret_unsupported", `Turret at (${Math.round(hazard.x)},${Math.round(hazard.y)}) has no support below.`);
      }
    });

    if (this.hazardProjectiles && this.hazardShooters.length > 0 && now > 4500 && this.lastHazardShotAt <= 0) {
      this.diagWarn("no_projectile_fire", "Turrets present but no projectile has fired yet.", 5000);
    }
  }

  setupGameMusic() {
    const audioSettings = Platformer.Settings.current.audio;
    const volume = (audioSettings.master / 100) * (audioSettings.music / 100);

    if (Platformer.menuMusicHtml) {
      Platformer.menuMusicHtml.pause();
      Platformer.menuMusicHtml.currentTime = 0;
      Platformer.menuMusicHtml = null;
    }
    this.sound.stopByKey("menu-bgm");

    const startPhaserMusic = () => {
      let music = Platformer.gameMusic;
      if (!music) {
        music = this.sound.get("game-bgm");
        if (!music) {
          try {
            music = this.sound.add("game-bgm", { loop: true, volume });
          } catch (_e) {
            this.setupHtmlGameMusicFallback(volume, audioSettings);
            return;
          }
        }
        Platformer.gameMusic = music;
      }

      music.setLoop(true);
      music.setVolume(volume);
      const tryPlay = () => {
        if (!music || music.isPlaying) return;
        try {
          music.play();
        } catch (_e) {
          // Autoplay gating may block until first user input.
        }
      };
      this.input.once("pointerdown", tryPlay);
      this.input.keyboard.once("keydown", tryPlay);
      tryPlay();
    };

    if (this.cache.audio.exists("game-bgm")) {
      startPhaserMusic();
      return;
    }

    this.load.audio("game-bgm", "assets/Slaughter to Prevail - K (mp3cut.net).mp3");
    this.load.once("complete", startPhaserMusic);
    this.load.once("loaderror", () => this.setupHtmlGameMusicFallback(volume, audioSettings));
    this.load.start();
  }

  setupHtmlGameMusicFallback(volume, audioSettings) {
    try {
      if (!Platformer.gameMusicHtml) {
        Platformer.gameMusicHtml = new Audio("assets/Slaughter to Prevail - K (mp3cut.net).mp3");
      }
      const music = Platformer.gameMusicHtml;
      music.loop = true;
      music.volume = Phaser.Math.Clamp(volume, 0, 1);

      const tryPlay = () => {
        if (audioSettings.muteWhenUnfocused && document.hidden) return;
        music.play().catch(() => {});
      };

      this.input.once("pointerdown", tryPlay);
      this.input.keyboard.once("keydown", tryPlay);
      tryPlay();
    } catch (_e) {
      // Keep game functional if audio fails.
    }
  }

  createPlayerHealthBar() {
    this.hpBarCfg = this.tinyGridMode
      ? { yOff: 20, w: 16, h: 4, fillW: 14, fillH: 2 }
      : { yOff: 34, w: 38, h: 7, fillW: 34, fillH: 5 };
    this.playerHealthBarBg = this.add.rectangle(
      this.player.x,
      this.player.y - this.hpBarCfg.yOff,
      this.hpBarCfg.w,
      this.hpBarCfg.h,
      0x111827,
      0.92
    )
      .setStrokeStyle(1, 0xe2e8f0, 0.85)
      .setDepth(55);
    this.playerHealthBarFill = this.add.rectangle(
      this.player.x - this.hpBarCfg.fillW / 2,
      this.player.y - this.hpBarCfg.yOff,
      this.hpBarCfg.fillW,
      this.hpBarCfg.fillH,
      0x22c55e,
      1
    )
      .setOrigin(0, 0.5)
      .setDepth(56);
    this.updatePlayerHealthBar();
  }

  createJetpackFx() {
    let key = this.textures.exists("jetpack-flame-1") ? "jetpack-flame-1" : "coin";
    if (this.tinyGridMode) {
      if (!this.textures.exists("jetpack-flame-tiny")) {
        const g = this.make.graphics({ x: 0, y: 0, add: false });
        g.fillStyle(0xfbbf24, 1);
        g.fillTriangle(4, 0, 0, 7, 8, 7);
        g.generateTexture("jetpack-flame-tiny", 8, 8);
        g.destroy();
      }
      key = "jetpack-flame-tiny";
    }
    this.jetpackFlameOffsetY = this.tinyGridMode ? 7 : 22;
    this.jetpackFlame = this.add.sprite(this.player.x, this.player.y + 18, key)
      .setDepth(54)
      .setVisible(false);
    this.jetpackFlame.setBlendMode(this.tinyGridMode ? Phaser.BlendModes.NORMAL : Phaser.BlendModes.ADD);
    if (this.tinyGridMode) {
      this.jetpackFlame.setDisplaySize(6, 6);
    } else if (key === "coin") {
      this.jetpackFlame.setDisplaySize(12, 12);
    }
  }

  updateJetpackFx(now, active) {
    if (!this.jetpackFlame || !this.player) return;
    this.jetpackFlame.setPosition(this.player.x, this.player.y + this.jetpackFlameOffsetY);
    if (!active) {
      this.jetpackFlame.setVisible(false);
      return;
    }
    this.jetpackFlame.setVisible(true);
    if (!this.tinyGridMode && this.textures.exists("jetpack-flame-1") && this.textures.exists("jetpack-flame-2")) {
      const frameKey = Math.floor(now / 75) % 2 === 0 ? "jetpack-flame-1" : "jetpack-flame-2";
      this.jetpackFlame.setTexture(frameKey);
    }
    if (this.tinyGridMode) {
      const pulse = 0.85 + Math.sin(now * 0.03) * 0.15;
      this.jetpackFlame.setScale(this.facingDir < 0 ? -pulse : pulse, pulse);
      this.jetpackFlame.setAlpha(0.9);
      return;
    }
    this.jetpackFlame.setScale(this.facingDir < 0 ? -1 : 1, 1);
  }

  alignPlayerBodyToFeet() {
    if (!this.player || !this.player.body || !this.tinyGridMode) return;
    const sx = Math.max(0.0001, Math.abs(this.player.scaleX || 1));
    const sy = Math.max(0.0001, Math.abs(this.player.scaleY || 1));
    const bodyWorldW = this.playerBodyWorldW || this.player.body.width;
    const bodyWorldH = this.playerBodyWorldH || this.player.body.height;
    const p = this.playerHitboxProfile || { ox: 0, oy: 10 };
    const oxWorld = Math.max(0, (this.player.displayWidth - bodyWorldW) * 0.5 + (p.ox || 0));
    const oyWorld = Math.max(0, this.player.displayHeight - bodyWorldH + (p.oy || 0));
    this.player.body.setOffset(oxWorld / sx, oyWorld / sy);
  }

  applyTinyPlayerHitboxProfile() {
    if (!this.tinyGridMode || !this.player) return;
    const fallback = { w: 9, h: 24, ox: 0, oy: -3 };
    let source = "fallback";
    let p = null;

    // First source: host-backed settings (persistent across EXE restarts).
    const settingsDebug = Platformer.Settings && Platformer.Settings.current
      ? Platformer.Settings.current.debug
      : null;
    if (settingsDebug && settingsDebug.playerHitbox) {
      p = {
        w: Phaser.Math.Clamp(Number(settingsDebug.playerHitbox.w) || fallback.w, 4, 64),
        h: Phaser.Math.Clamp(Number(settingsDebug.playerHitbox.h) || fallback.h, 4, 64),
        ox: Phaser.Math.Clamp(Number(settingsDebug.playerHitbox.ox) || fallback.ox, -24, 24),
        oy: Phaser.Math.Clamp(Number(settingsDebug.playerHitbox.oy) || fallback.oy, -24, 24),
      };
      source = "settings";
    }

    // Prefer the debug module profile when available.
    if (!p && Platformer.Debug && typeof Platformer.Debug.getPlayerHitboxProfile === "function") {
      p = Platformer.Debug.getPlayerHitboxProfile();
      source = "debug";
    }

    // Robust fallback: load persisted profile directly even if Debug init order changes.
    if (!p) {
      try {
        const raw = localStorage.getItem("platformer_player_hitbox");
        if (raw) {
          const parsed = JSON.parse(raw);
          p = {
            w: Phaser.Math.Clamp(Number(parsed.w) || fallback.w, 4, 64),
            h: Phaser.Math.Clamp(Number(parsed.h) || fallback.h, 4, 64),
            ox: Phaser.Math.Clamp(Number(parsed.ox) || fallback.ox, -24, 24),
            oy: Phaser.Math.Clamp(Number(parsed.oy) || fallback.oy, -24, 24),
          };
          source = "localStorage";
        }
      } catch (_e) {
        // Ignore parse/storage errors and keep fallback.
      }
    }

    this.playerHitboxProfile = { ...fallback, ...(p || {}) };
    this.setPlayerBodyWorldSize(this.playerHitboxProfile.w, this.playerHitboxProfile.h, false);
    this.alignPlayerBodyToFeet();
    if (Platformer.Debug) {
      Platformer.Debug.log(
        "GameScene.collision",
        `Hitbox profile loaded (${source}) w=${this.playerHitboxProfile.w} h=${this.playerHitboxProfile.h} ox=${this.playerHitboxProfile.ox} oy=${this.playerHitboxProfile.oy}`
      );
    }
  }

  setPlayerBodyWorldSize(worldW, worldH, center) {
    if (!this.player || !this.player.body) return;
    this.playerBodyWorldW = worldW;
    this.playerBodyWorldH = worldH;
    const sx = Math.max(0.0001, Math.abs(this.player.scaleX || 1));
    const sy = Math.max(0.0001, Math.abs(this.player.scaleY || 1));
    const rawW = Math.max(1, worldW / sx);
    const rawH = Math.max(1, worldH / sy);
    this.player.body.setSize(rawW, rawH, center);
  }

  resolvePlayerEmbedding(context) {
    if (!this.tinyGridMode || !this.player || !this.player.body) return;
    const body = this.player.body;
    let overlapped = !!body.embedded;
    if (!overlapped && this.physics && this.solids) {
      overlapped = this.physics.overlap(this.player, this.solids);
    }
    if (!overlapped) return;

    for (let i = 0; i < 64; i += 1) {
      this.player.y -= 1;
      if (typeof body.updateFromGameObject === "function") body.updateFromGameObject();
      if (!this.physics.overlap(this.player, this.solids)) {
        body.embedded = false;
        break;
      }
    }
    const stillOverlapped = this.physics && this.solids ? this.physics.overlap(this.player, this.solids) : false;
    if (body.velocity.y > 0) body.velocity.y = 0;
    if (Platformer.Debug) {
      if (stillOverlapped) {
        Platformer.Debug.error(
          "GameScene.collision",
          `Player still embedded after resolve (${context}) x=${this.player.x.toFixed(1)} y=${this.player.y.toFixed(1)} ` +
          `bx=${body.x.toFixed(1)} by=${body.y.toFixed(1)} bw=${body.width} bh=${body.height} ` +
          `vx=${body.velocity.x.toFixed(1)} vy=${body.velocity.y.toFixed(1)}`
        );
      } else {
        Platformer.Debug.warn("GameScene.collision", `Resolved embedded player (${context}).`);
      }
    }
  }

  logIfPlayerInsideTile(now) {
    if (!this.player || !this.player.body || !this.solids || !this.physics) return;
    const body = this.player.body;
    const overlapped = !!body.embedded || this.physics.overlap(this.player, this.solids);
    if (!overlapped) {
      this.tileEmbedFrames = 0;
      return;
    }

    this.tileEmbedFrames += 1;
    if (this.tileEmbedFrames < 2) return;
    if (now - this.lastTileEmbedLogAt < 500) return;
    this.lastTileEmbedLogAt = now;

    if (Platformer.Debug) {
      Platformer.Debug.error(
        "GameScene.collision",
        `INSIDE_TILE detected x=${this.player.x.toFixed(1)} y=${this.player.y.toFixed(1)} ` +
        `bx=${body.x.toFixed(1)} by=${body.y.toFixed(1)} bw=${body.width} bh=${body.height} ` +
        `vx=${body.velocity.x.toFixed(1)} vy=${body.velocity.y.toFixed(1)} ` +
        `blocked(d,l,r,u)=${body.blocked.down ? 1 : 0},${body.blocked.left ? 1 : 0},${body.blocked.right ? 1 : 0},${body.blocked.up ? 1 : 0}`
      );
    }
  }

  resolveGroundPenetration(now) {
    if (!this.tinyGridMode || !this.player || !this.player.body || !this.solids || !this.physics) return;
    const body = this.player.body;
    if (!body.blocked.down || body.velocity.y < 0) return;
    let top = Number.POSITIVE_INFINITY;
    const hasOverlap = this.physics.overlap(this.player, this.solids, (_p, solid) => {
      if (solid && solid.body) top = Math.min(top, solid.body.top);
    });
    if (!hasOverlap || !Number.isFinite(top)) return;

    const penetration = body.bottom - top;
    if (penetration <= 1.25) return;
    const moved = Math.min(4, Math.ceil(penetration - 1));
    this.player.y -= moved;
    if (typeof body.updateFromGameObject === "function") body.updateFromGameObject();
    if (moved > 0 && Platformer.Debug && now - this.lastTileEmbedLogAt > 250) {
      this.lastTileEmbedLogAt = now;
      Platformer.Debug.warn("GameScene.collision", `Ground penetration corrected by ${moved}px`);
    }
  }

  setupHitboxOverlay() {
    this.hitboxOverlayEnabled = !!(Platformer.Debug && Platformer.Debug.hitboxesEnabled);
    this.hitboxOverlay = this.add.graphics();
    this.hitboxOverlay.setDepth(5000);
    this.hitboxOverlay.setScrollFactor(1);
    this.onHitboxesToggle = (ev) => {
      this.hitboxOverlayEnabled = !!(ev && ev.detail && ev.detail.enabled);
      if (Platformer.Debug) Platformer.Debug.log("GameScene.hitboxes", `Overlay ${this.hitboxOverlayEnabled ? "ON" : "OFF"}`);
      if (!this.hitboxOverlayEnabled && this.hitboxOverlay) this.hitboxOverlay.clear();
    };
    window.addEventListener("platformer:hitboxes-toggle", this.onHitboxesToggle);
    this.onPlayerHitboxChanged = (ev) => {
      const p = ev && ev.detail ? ev.detail : null;
      if (!p || !this.tinyGridMode || !this.player) return;
      this.playerHitboxProfile = { ...this.playerHitboxProfile, ...p };
      this.setPlayerBodyWorldSize(this.playerHitboxProfile.w, this.playerHitboxProfile.h, false);
      this.alignPlayerBodyToFeet();
      if (typeof this.player.body.updateFromGameObject === "function") this.player.body.updateFromGameObject();
      if (Platformer.Debug) {
        Platformer.Debug.log(
          "GameScene.collision",
          `Player HB applied w=${this.playerHitboxProfile.w} h=${this.playerHitboxProfile.h} ox=${this.playerHitboxProfile.ox} oy=${this.playerHitboxProfile.oy}`
        );
      }
    };
    window.addEventListener("platformer:player-hitbox-changed", this.onPlayerHitboxChanged);
  }

  drawHitboxOverlay(now) {
    if (!this.hitboxOverlay) return;
    if (!this.hitboxOverlayEnabled) {
      this.hitboxOverlay.clear();
      return;
    }
    if (now - this.lastHitboxDrawAt < 16) return;
    this.lastHitboxDrawAt = now;

    const g = this.hitboxOverlay;
    g.clear();
    const cam = this.cameras && this.cameras.main ? this.cameras.main : null;
    const view = cam ? cam.worldView : null;
    const inView = (b) => {
      if (!view) return true;
      return !(b.right < view.x - 24 || b.x > view.right + 24 || b.bottom < view.y - 24 || b.y > view.bottom + 24);
    };

    const drawBody = (body, color, width = 1) => {
      if (!body) return;
      if (!inView(body)) return;
      g.lineStyle(width, color, 1);
      g.strokeRect(body.x, body.y, body.width, body.height);
    };

    drawBody(this.player && this.player.body, 0x22c55e, 2);
    this.solids && this.solids.children.each((o) => drawBody(o && o.body, 0x38bdf8, 1));
    this.oneWays && this.oneWays.children.each((o) => drawBody(o && o.body, 0x06b6d4, 1));
    this.hazards && this.hazards.children.each((o) => drawBody(o && o.body, 0xf97316, 1));
    this.enemies && this.enemies.children.each((o) => drawBody(o && o.body, 0xef4444, 1));
    this.hazardProjectiles && this.hazardProjectiles.children.each((o) => drawBody(o && o.body, 0xeab308, 1));
  }

  updatePlayerHealthBar() {
    if (!this.player || !this.playerHealthBarBg || !this.playerHealthBarFill) {
      return;
    }

    const health = Phaser.Math.Clamp(this.registry.get("health"), 0, 3);
    const ratio = health / 3;
    const fillWidth = Math.max(0, (this.hpBarCfg ? this.hpBarCfg.fillW : 34) * ratio);
    const color = ratio > 0.66 ? 0x22c55e : (ratio > 0.33 ? 0xf59e0b : 0xef4444);
    const yOff = this.hpBarCfg ? this.hpBarCfg.yOff : 34;
    const xOff = this.hpBarCfg ? this.hpBarCfg.fillW / 2 : 18;
    this.playerHealthBarBg.setPosition(this.player.x, this.player.y - yOff);
    this.playerHealthBarFill.setPosition(this.player.x - xOff, this.player.y - yOff);
    this.playerHealthBarFill.width = fillWidth;
    this.playerHealthBarFill.setFillStyle(color, 1);
    this.playerHealthBarFill.setVisible(fillWidth > 0);
  }

  setupHazardShooters() {
    this.hazardShooters = [];
    let i = 0;
    this.hazards.children.each((hazard) => {
      // All turrets are active; stagger initial fire times for readability.
      hazard.setData("nextShotAt", this.time.now + i * 140);
      this.hazardShooters.push(hazard);
      i += 1;
    });
  }

  spawnHazardProjectiles(now) {
    if (!this.hazardShooters.length) {
      return;
    }

    let fired = 0;
    const maxShotsPerTick = 2;
    for (let i = 0; i < this.hazardShooters.length; i += 1) {
      if (fired >= maxShotsPerTick) {
        break;
      }

      const shooter = this.hazardShooters[i];
      if (!shooter || !shooter.active) {
        continue;
      }

      const nextShotAt = shooter.getData("nextShotAt") || 0;
      if (now < nextShotAt) {
        continue;
      }

      const inRangeX = Math.abs(shooter.x - this.player.x) < (this.tinyGridMode ? 220 : 540);
      const inRangeY = Math.abs(shooter.y - this.player.y) < (this.tinyGridMode ? 120 : 260);
      if (!inRangeX || !inRangeY) {
        continue;
      }

      const projectile = this.hazardProjectiles.create(shooter.x, shooter.y - 8, "hazard-projectile");
      projectile.setDepth(70);
      projectile.body.setSize(this.tinyGridMode ? 4 : 10, this.tinyGridMode ? 4 : 10);
      if (this.tinyGridMode) projectile.setDisplaySize(5, 5);
      projectile.body.setAllowGravity(false);
      projectile.setCollideWorldBounds(false);

      const dir = this.player.x >= shooter.x ? 1 : -1;
      const yAim = Phaser.Math.Clamp(this.player.y - shooter.y, -120, 90) * 0.35;
      projectile.setVelocity(dir * this.projectileSpeed, yAim);

      const stagger = (Math.floor(shooter.x / Platformer.Config.TILE) % 3) * 90;
      shooter.setData("nextShotAt", now + this.projectileIntervalMs + stagger);
      fired += 1;
      this.lastHazardShotAt = now;
    }
  }

  updateProjectiles() {
    const maxY = this.mapHeight * Platformer.Config.TILE + 200;
    const minX = -120;
    const maxX = this.mapWidth * Platformer.Config.TILE + 120;
    this.hazardProjectiles.children.each((p) => {
      if (!p.active) return;
      if (p.x < minX || p.x > maxX || p.y > maxY) {
        p.destroy();
      }
    });
  }

  updateLevelTimer(now) {
    if (!this.lastTickTime) {
      this.lastTickTime = now;
      return;
    }

    const dt = now - this.lastTickTime;
    this.lastTickTime = now;
    this.levelTimeRemainingMs = Math.max(0, this.levelTimeRemainingMs - dt);
    const secondsLeft = Math.ceil(this.levelTimeRemainingMs / 1000);
    if (secondsLeft !== this.lastTimerSecond) {
      this.lastTimerSecond = secondsLeft;
      this.registry.set("timeLeft", secondsLeft);
    }

    if (this.levelTimeRemainingMs <= 0 && !this.isDead) {
      this.isDead = true;
      this.game.events.emit("game-over");
      this.scene.pause();
    }
  }

  createTokyoBackdrop() {
    const { TILE } = Platformer.Config;
    const worldW = this.mapWidth * TILE;

    const skyTop = this.add.rectangle(worldW / 2, 120, worldW, 240, 0x111827).setDepth(-120).setScrollFactor(0);
    const skyMid = this.add.rectangle(worldW / 2, 260, worldW, 280, 0x1e1b4b).setDepth(-119).setScrollFactor(0);
    const skyGlow = this.add.rectangle(worldW / 2, 210, worldW, 180, 0x312e81, 0.35).setDepth(-118).setScrollFactor(0);
    this.parallax.push(skyTop, skyMid, skyGlow);

    const moon = this.add.circle(760, 88, 34, 0xfef3c7, 0.9).setDepth(-117).setScrollFactor(0.04);
    const moonGlow = this.add.circle(760, 88, 52, 0xfef9c3, 0.18).setDepth(-118).setScrollFactor(0.04);
    this.parallax.push(moon, moonGlow);

    const farHeights = [110, 120, 100, 130, 95, 126, 106, 116];
    for (let i = 0; i < 40; i += 1) {
      const w = 90;
      const h = farHeights[i % farHeights.length];
      const x = i * 88;
      const y = 320 - h / 2;
      const b = this.add.rectangle(x, y, w, h, 0x0f172a).setOrigin(0, 0.5).setDepth(-90).setScrollFactor(0.2);
      this.parallax.push(b);

      for (let wx = 0; wx < 4; wx += 1) {
        const color = (wx + i) % 2 === 0 ? 0x22d3ee : 0xf472b6;
        const win = this.add.rectangle(x + 12 + wx * 18, y - h / 2 + 18 + ((i + wx) % 5) * 14, 9, 6, color, 0.8)
          .setDepth(-89)
          .setScrollFactor(0.2);
        this.parallax.push(win);
      }
    }

    const midHeights = [140, 170, 150, 188, 132, 168];
    for (let i = 0; i < 26; i += 1) {
      const w = 122;
      const h = midHeights[i % midHeights.length];
      const x = i * 118;
      const y = 390 - h / 2;
      const b = this.add.rectangle(x, y, w, h, 0x020617).setOrigin(0, 0.5).setDepth(-70).setScrollFactor(0.45);
      this.parallax.push(b);

      if (i % 4 === 1) {
        const sign = this.add.rectangle(x + 70, y - h / 2 + 34, 58, 18, 0xdb2777, 0.9)
          .setDepth(-69)
          .setScrollFactor(0.45);
        this.parallax.push(sign);
      }
    }

    for (let i = 0; i < 24; i += 1) {
      const line = this.add.rectangle(i * 170, 120 + (i % 5) * 72, 120, 4, 0xffffff, 0.28)
        .setAngle(-16)
        .setOrigin(0, 0.5)
        .setDepth(-60)
        .setScrollFactor(0.12);
      this.parallax.push(line);
    }
  }

  tryBuildLevelFromLdtk(levelNumber) {
    if (Number(levelNumber) !== 5) return null;
    try {
      const ldtk = this.cache && this.cache.json ? this.cache.json.get("ldtk-test") : null;
      if (!ldtk || typeof ldtk !== "object") {
        if (Platformer.Debug) Platformer.Debug.warn("GameScene.ldtk", "Missing cached ldtk-test JSON; falling back to classic level data.");
        return null;
      }
      const levels = Array.isArray(ldtk.levels) ? ldtk.levels : [];
      const level = levels[0] || null;
      if (!level) {
        if (Platformer.Debug) Platformer.Debug.warn("GameScene.ldtk", "No levels in test.ldtk; falling back.");
        return null;
      }
      const layers = Array.isArray(level.layerInstances) ? level.layerInstances : [];
      const intLayer = layers.find((li) => li && li.__type === "IntGrid") || null;
      if (!intLayer) {
        if (Platformer.Debug) Platformer.Debug.warn("GameScene.ldtk", "No IntGrid layer found in test.ldtk; falling back.");
        return null;
      }
      const width = Number(intLayer.__cWid || 0);
      const height = Number(intLayer.__cHei || 0);
      const csv = Array.isArray(intLayer.intGridCsv) ? intLayer.intGridCsv : [];
      if (!width || !height || csv.length !== width * height) {
        if (Platformer.Debug) Platformer.Debug.warn("GameScene.ldtk", `Invalid IntGrid dimensions w=${width} h=${height} csv=${csv.length}; falling back.`);
        return null;
      }

      const rowsChars = Array.from({ length: height }, () => Array.from({ length: width }, () => "."));
      for (let y = 0; y < height; y += 1) {
        for (let x = 0; x < width; x += 1) {
          const v = Number(csv[y * width + x] || 0);
          if (v !== 0) rowsChars[y][x] = "#";
        }
      }

      // Find a sensible spawn above a solid tile.
      let sx = 1;
      let sy = 1;
      for (let y = 1; y < height; y += 1) {
        let found = false;
        for (let x = 0; x < width; x += 1) {
          if (rowsChars[y][x] === "." && rowsChars[y - 1][x] === "#") {
            sx = x;
            sy = y;
            found = true;
            break;
          }
        }
        if (found) break;
      }
      rowsChars[sy][sx] = "S";

      return {
        width,
        height,
        rows: rowsChars.map((r) => r.join("")),
      };
    } catch (err) {
      if (Platformer.Debug) {
        Platformer.Debug.error("GameScene.ldtk", err && err.stack ? err.stack : String(err));
      }
      return null;
    }
  }

  renderLdtkVisualTiles() {
    try {
      if (!this.textures.exists("ldtk-cavernas")) {
        if (Platformer.Debug) Platformer.Debug.warn("GameScene.ldtk", "ldtk-cavernas texture missing; visual tile render skipped.");
        return;
      }
      const ldtk = this.cache && this.cache.json ? this.cache.json.get("ldtk-test") : null;
      const level = ldtk && Array.isArray(ldtk.levels) ? ldtk.levels[0] : null;
      const layers = level && Array.isArray(level.layerInstances) ? level.layerInstances : [];
      const intLayer = layers.find((li) => li && li.__type === "IntGrid") || null;
      if (!intLayer) return;
      const autoTiles = Array.isArray(intLayer.autoLayerTiles) ? intLayer.autoLayerTiles : [];

      const tex = this.textures.get("ldtk-cavernas");
      const src = tex && tex.getSourceImage ? tex.getSourceImage() : null;
      const tileSize = Number(intLayer.__gridSize || Platformer.Config.TILE || 8);
      const cols = src && src.width ? Math.max(1, Math.floor(src.width / tileSize)) : 1;

      // Clear previous visuals if scene restarts.
      if (Array.isArray(this.ldtkVisualTiles) && this.ldtkVisualTiles.length) {
        this.ldtkVisualTiles.forEach((o) => { if (o && o.destroy) o.destroy(); });
      }
      this.ldtkVisualTiles = [];

      for (let i = 0; i < autoTiles.length; i += 1) {
        const t = autoTiles[i];
        if (!t || !Array.isArray(t.px) || !Array.isArray(t.src)) continue;
        const px = Number(t.px[0] || 0);
        const py = Number(t.px[1] || 0);
        const sx = Number(t.src[0] || 0);
        const sy = Number(t.src[1] || 0);
        const f = Number(t.f || 0);
        const frame = Math.floor(sy / tileSize) * cols + Math.floor(sx / tileSize);
        const img = this.add.image(px + tileSize / 2, py + tileSize / 2, "ldtk-cavernas", frame)
          .setDepth(-40)
          .setOrigin(0.5);
        if ((f & 1) !== 0) img.setFlipX(true);
        if ((f & 2) !== 0) img.setFlipY(true);
        this.ldtkVisualTiles.push(img);
      }

      if (Platformer.Debug) {
        Platformer.Debug.log("GameScene.ldtk", `Rendered LDtk auto tiles: ${this.ldtkVisualTiles.length}`);
      }
    } catch (err) {
      if (Platformer.Debug) {
        Platformer.Debug.error("GameScene.ldtk", err && err.stack ? err.stack : String(err));
      }
    }
  }

  oneWayProcess(player, platform) {
    const pBody = player.body;
    const platBody = platform.body;
    const wasAbove = pBody.bottom <= platBody.top + 6;
    const isFalling = pBody.velocity.y >= 0;
    return wasAbove && isFalling;
  }

  keyCodeFromName(name, fallback) {
    if (!name) return fallback;
    const upper = String(name).toUpperCase();
    const direct = Phaser.Input.Keyboard.KeyCodes[upper];
    if (typeof direct === "number") return direct;
    if (upper.length === 1) {
      const letter = Phaser.Input.Keyboard.KeyCodes[upper];
      if (typeof letter === "number") return letter;
    }
    return fallback;
  }

  buildPlayerTuning(base) {
    const b = base || {};
    if (!this.tinyGridMode) return { ...b };
    const s = 0.5;
    return {
      ...b,
      maxSpeed: (b.maxSpeed || 164) * s,
      acceleration: (b.acceleration || 1080) * (s * 1.35),
      drag: (b.drag || 3200) * (s * 1.25),
      jumpVelocity: (b.jumpVelocity || 420) * s,
      gravity: (b.gravity || 1100) * s,
      dashSpeed: (b.dashSpeed || 460) * s,
      maxRiseSpeed: (b.maxRiseSpeed || 520) * s,
      maxFallSpeed: (b.maxFallSpeed || 760) * s,
      attackRange: Math.max(12, (b.attackRange || 44) * 0.45),
    };
  }

  buildJetpackTuning(base) {
    const b = { ...(base || {}) };
    if (!this.tinyGridMode) return b;
    const s = 0.5;
    b.maxUpSpeed = Math.max(28, Number(b.maxUpSpeed || 220) * s);
    b.momentumBoostSpeed = Math.max(12, Number(b.momentumBoostSpeed || 72) * s);
    b.activationKickSpeed = Math.max(8, Number(b.activationKickSpeed || 34) * s);
    b.maxAccel = Math.max(180, Number(b.maxAccel || 1320) * s);
    b.maxThrustAccel = Math.max(180, Number(b.maxThrustAccel || 1300) * s);
    b.brakeDecelMax = Math.max(120, Number(b.brakeDecelMax || 760) * s);
    b.liftThresholdSpeed = Math.max(10, Number(b.liftThresholdSpeed || 56) * s);
    return b;
  }

  buildControlKeyMap() {
    const c = Platformer.Settings.current.controls;
    return {
      left: this.keyCodeFromName(c.left, Phaser.Input.Keyboard.KeyCodes.A),
      right: this.keyCodeFromName(c.right, Phaser.Input.Keyboard.KeyCodes.D),
      jump: this.keyCodeFromName(c.jump, Phaser.Input.Keyboard.KeyCodes.W),
      dash: this.keyCodeFromName(c.dash, Phaser.Input.Keyboard.KeyCodes.SHIFT),
      attack: this.keyCodeFromName(c.attack, Phaser.Input.Keyboard.KeyCodes.J),
      interact: this.keyCodeFromName(c.interact, Phaser.Input.Keyboard.KeyCodes.E),
      pause: this.keyCodeFromName(c.pause, Phaser.Input.Keyboard.KeyCodes.ESC),
      jetpack: Phaser.Input.Keyboard.KeyCodes.SPACE,
      demoWin: Phaser.Input.Keyboard.KeyCodes.F2,
    };
  }

  applyVideoSettings() {
    const s = Platformer.Settings.current;
    const brightness = Phaser.Math.Clamp(s.video.brightness, 0.8, 1.2);
    const shade = brightness >= 1 ? 0xffffff : 0x000000;
    const alpha = Math.abs(1 - brightness) * 0.45;
    const centerX = this.mapWidth * Platformer.Config.TILE / 2;
    const centerY = this.mapHeight * Platformer.Config.TILE / 2;
    const width = this.mapWidth * Platformer.Config.TILE + 800;
    const height = this.mapHeight * Platformer.Config.TILE + 800;
    if (this.brightnessOverlay && this.brightnessOverlay.active) {
      this.brightnessOverlay.setPosition(centerX, centerY);
      this.brightnessOverlay.setSize(width, height);
      this.brightnessOverlay.setFillStyle(shade, alpha);
    } else {
      this.brightnessOverlay = this.add.rectangle(centerX, centerY, width, height, shade, alpha)
        .setScrollFactor(0)
        .setDepth(200);
    }
  }

  applyRuntimeSettings(nextSettings) {
    try {
      const settings = nextSettings || Platformer.Settings.current || {};
      const audio = settings.audio || { master: 80, music: 60 };
      const volume = Phaser.Math.Clamp((Number(audio.master) / 100) * (Number(audio.music) / 100), 0, 1);

      if (Platformer.gameMusic && typeof Platformer.gameMusic.setVolume === "function") {
        Platformer.gameMusic.setVolume(volume);
      }
      if (Platformer.gameMusicHtml) {
        Platformer.gameMusicHtml.volume = volume;
      }
      if (this.keys && this.input && this.input.keyboard) {
        this.keys = this.input.keyboard.addKeys(this.buildControlKeyMap());
      }
      this.applyVideoSettings();
      this.updateCameraFraming();
      if (this.cameras && this.cameras.main && this.player) {
        const smooth = Phaser.Math.Clamp((settings.video.cameraSmoothing || 0) / 100, 0, 1);
        const followLerp = this.tinyGridMode ? 1 : smooth;
        this.cameras.main.startFollow(this.player, true, followLerp, followLerp);
        this.cameras.main.roundPixels = !this.tinyGridMode;
      }
      if (Platformer.Debug) {
        Platformer.Debug.log("GameScene.settings", `Applied runtime settings: gameVolume=${volume.toFixed(2)}`);
      }
    } catch (err) {
      if (Platformer.Debug) {
        Platformer.Debug.error("GameScene.settings", err && err.stack ? err.stack : String(err));
      }
    }
  }

  updateCameraFraming() {
    if (!this.cameras || !this.cameras.main) {
      return;
    }
    const s = Platformer.Settings.current;
    const baseZoom = this.scale.height / Platformer.Config.GAME_HEIGHT;
    const resScale = Phaser.Math.Clamp(s.video.resolutionScale / 100, 0.5, 1);
    const modeZoom = this.tinyGridMode ? 3.5 : 1;
    const zoom = this.tinyGridMode
      ? Phaser.Math.Clamp(baseZoom * resScale * modeZoom, 2.5, 7)
      : Phaser.Math.Clamp(baseZoom * resScale * modeZoom, 0.75, 3);
    this.cameras.main.setZoom(zoom);
  }

  normalizeTurretTiles() {
    const grid = this.mapRows.map((row) => row.split(""));
    const inBounds = (x, y) => x >= 0 && x < this.mapWidth && y >= 0 && y < this.mapHeight;
    const isSupport = (x, y) => {
      if (!inBounds(x, y)) return false;
      const ch = grid[y][x];
      return ch === "#" || ch === "=";
    };
    const isWalkableSlot = (x, y) => {
      if (!inBounds(x, y)) return false;
      const ch = grid[y][x];
      return ch === "." || ch === "^";
    };
    const findSpawnX = () => {
      for (let yy = 0; yy < this.mapHeight; yy += 1) {
        for (let xx = 0; xx < this.mapWidth; xx += 1) {
          if (grid[yy][xx] === "S") return xx;
        }
      }
      return 0;
    };
    const spawnX = findSpawnX();

    const turrets = [];
    for (let y = 0; y < this.mapHeight; y += 1) {
      for (let x = 0; x < this.mapWidth; x += 1) {
        if (grid[y][x] === "^") {
          turrets.push({ x, y });
          grid[y][x] = ".";
        }
      }
    }

    const isSafeFromSpawn = (x) => Math.abs(x - spawnX) >= 8;
    const tryPlace = (x, y) => {
      if (isWalkableSlot(x, y) && isSupport(x, y + 1)) {
        if (!isSafeFromSpawn(x)) {
          return false;
        }
        grid[y][x] = "^";
        return true;
      }
      return false;
    };

    turrets.forEach(({ x, y }) => {
      let placed = false;
      const preferredY = Phaser.Math.Clamp(y, 0, this.mapHeight - 2);

      // Keep authored lane first for better level readability.
      placed = tryPlace(x, preferredY);

      // Then search nearby vertically only.
      if (!placed) {
        for (let d = 1; d <= 2 && !placed; d += 1) {
          const up = preferredY - d;
          const down = preferredY + d;
          if (up >= 0) placed = tryPlace(x, up);
          if (!placed && down <= this.mapHeight - 2) placed = tryPlace(x, down);
        }
      }
    });

    this.mapRows = grid.map((row) => row.join(""));
  }

  normalizeEnemyTiles() {
    const enemyChars = new Set(["E", "F", "G", "H"]);
    const grid = this.mapRows.map((row) => row.split(""));
    const inBounds = (x, y) => x >= 0 && x < this.mapWidth && y >= 0 && y < this.mapHeight;
    const chAt = (x, y) => (inBounds(x, y) ? grid[y][x] : ".");
    const isSupport = (x, y) => {
      const ch = chAt(x, y);
      return ch === "#" || ch === "=";
    };
    const isEnemySpotOpen = (x, y) => chAt(x, y) === ".";
    const isHazardAt = (x, y) => chAt(x, y) === "^";
    const hasHeadroom = (x, y) => y <= 0 || chAt(x, y - 1) === ".";
    const canStandAt = (x, y) =>
      inBounds(x, y)
      && y < this.mapHeight - 1
      && isEnemySpotOpen(x, y)
      && isSupport(x, y + 1)
      && !isHazardAt(x, y)
      && hasHeadroom(x, y);
    const patrolSpanAt = (x, y) => {
      if (!canStandAt(x, y)) {
        return 0;
      }

      let left = x;
      let right = x;
      while (canStandAt(left - 1, y)) left -= 1;
      while (canStandAt(right + 1, y)) right += 1;
      return right - left + 1;
    };

    let spawnX = 0;
    for (let y = 0; y < this.mapHeight; y += 1) {
      for (let x = 0; x < this.mapWidth; x += 1) {
        if (grid[y][x] === "S") {
          spawnX = x;
        }
      }
    }

    const turrets = [];
    const enemies = [];
    for (let y = 0; y < this.mapHeight; y += 1) {
      for (let x = 0; x < this.mapWidth; x += 1) {
        const ch = grid[y][x];
        if (ch === "^") turrets.push({ x, y });
        if (enemyChars.has(ch)) {
          enemies.push({ x, y, type: ch });
          grid[y][x] = ".";
        }
      }
    }

    const isSafeFromTurrets = (x, y) => !turrets.some((t) => Math.abs(t.x - x) <= 5 && Math.abs(t.y - y) <= 2);
    const isSafeFromSpawn = (x) => Math.abs(x - spawnX) >= 10;
    const placedEnemies = [];
    const isSafeFromOtherEnemies = (x, y) => !placedEnemies.some((e) => Math.abs(e.x - x) <= 4 && Math.abs(e.y - y) <= 2);
    const hasPatrolRoom = (x, y) => {
      const span = patrolSpanAt(x, y);
      if (span < 6) return false;
      return canStandAt(x - 1, y) || canStandAt(x + 1, y);
    };
    const canPlaceEnemy = (x, y) =>
      canStandAt(x, y)
      && hasPatrolRoom(x, y)
      && isSafeFromTurrets(x, y)
      && isSafeFromSpawn(x)
      && isSafeFromOtherEnemies(x, y);

    enemies.forEach((enemy) => {
      let placed = false;
      const tryOrder = [0, -1, 1];
      for (const dy of tryOrder) {
        const yy = enemy.y + dy;
        for (let dx = 0; dx <= 6; dx += 1) {
          const xs = dx === 0 ? [enemy.x] : [enemy.x - dx, enemy.x + dx];
          for (const xx of xs) {
            if (canPlaceEnemy(xx, yy)) {
              grid[yy][xx] = enemy.type;
              placedEnemies.push({ x: xx, y: yy });
              placed = true;
              break;
            }
          }
          if (placed) break;
        }
        if (placed) break;
      }

      if (!placed) {
        for (let y = 0; y < this.mapHeight - 1; y += 1) {
          for (let x = 0; x < this.mapWidth; x += 1) {
            if (canPlaceEnemy(x, y)) {
              grid[y][x] = enemy.type;
              placedEnemies.push({ x, y });
              placed = true;
              break;
            }
          }
          if (placed) break;
        }
      }
    });

    this.mapRows = grid.map((row) => row.join(""));
  }

  enemyOneWayProcess(enemy, platform) {
    const eBody = enemy.body;
    const pBody = platform.body;
    return eBody.bottom <= pBody.top + 4 && eBody.velocity.y >= 0;
  }

  tileCharAtWorld(worldX, worldY) {
    const { TILE } = Platformer.Config;
    const tx = Math.floor(worldX / TILE);
    const ty = Math.floor(worldY / TILE);
    return this.tileCharAt(tx, ty);
  }

  tileCharAt(tileX, tileY) {
    if (tileX < 0 || tileY < 0 || tileY >= this.mapHeight || tileX >= this.mapWidth) {
      return ".";
    }
    return this.mapRows[tileY][tileX];
  }

  hasSupportAtWorld(worldX, worldY) {
    const ch = this.tileCharAtWorld(worldX, worldY);
    return ch === "#" || ch === "=";
  }

  isHazardAtWorld(worldX, worldY) {
    return this.tileCharAtWorld(worldX, worldY) === "^";
  }

  isSupportTile(tileX, tileY) {
    const ch = this.tileCharAt(tileX, tileY);
    return ch === "#" || ch === "=";
  }

  isHazardTile(tileX, tileY) {
    return this.tileCharAt(tileX, tileY) === "^";
  }

  computeEnemyPatrolBounds(tileX, tileY) {
    const { TILE } = Platformer.Config;
    const supportY = tileY + 1;
    let left = tileX;
    let right = tileX;

    while (this.isSupportTile(left - 1, supportY) && !this.isHazardTile(left - 1, tileY)) {
      left -= 1;
    }
    while (this.isSupportTile(right + 1, supportY) && !this.isHazardTile(right + 1, tileY)) {
      right += 1;
    }

    return {
      minX: left * TILE + TILE / 2,
      maxX: right * TILE + TILE / 2,
    };
  }

  updateEnemyPatrol(enemy, now) {
    if (!enemy.active) return;

    let speed = enemy.getData("patrolSpeed");
    let dir = enemy.getData("direction");
    if (!dir) dir = enemy.body.velocity.x >= 0 ? 1 : -1;
    const minX = enemy.getData("patrolMinX");
    const maxX = enemy.getData("patrolMaxX");
    const useBounded = !!enemy.getData("useBoundedPatrol");
    const turnCooldownUntil = enemy.getData("turnCooldownUntil") || 0;
    const grounded = enemy.body.blocked.down || enemy.body.touching.down;
    const enemyType = enemy.getData("enemyType") || "E";
    const closeX = Math.abs(enemy.x - this.player.x) < (enemyType === "G" ? 260 : 190);
    const closeY = Math.abs(enemy.y - this.player.y) < 70;
    const aggressive = closeX && closeY;
    let aiState = enemy.getData("aiState") || "patrol";
    let stateUntil = enemy.getData("stateUntil") || 0;
    let attackCooldownUntil = enemy.getData("attackCooldownUntil") || 0;

    if (aggressive) {
      dir = this.player.x >= enemy.x ? 1 : -1;
      const mult = enemyType === "G" ? 2.3 : (enemyType === "H" ? 1.55 : 1.8);
      speed *= mult;
      enemy.setTint(0xf87171);
    } else {
      enemy.clearTint();
    }

    if ((enemyType === "G" || enemyType === "H") && aggressive && grounded) {
      if (aiState === "patrol" && now >= attackCooldownUntil) {
        aiState = "windup";
        stateUntil = now + (enemyType === "G" ? 210 : 280);
      } else if (aiState === "windup" && now >= stateUntil) {
        aiState = "lunge";
        stateUntil = now + (enemyType === "G" ? 280 : 220);
        dir = this.player.x >= enemy.x ? 1 : -1;
      } else if (aiState === "lunge" && now >= stateUntil) {
        aiState = "recover";
        stateUntil = now + 240;
        attackCooldownUntil = now + (enemyType === "G" ? 900 : 1200);
      } else if (aiState === "recover" && now >= stateUntil) {
        aiState = "patrol";
      }
    } else if (!aggressive && aiState !== "patrol") {
      aiState = "patrol";
    }

    if (aiState === "windup") {
      speed = 0;
      enemy.setTint(0xfacc15);
    } else if (aiState === "lunge") {
      const burst = enemyType === "G" ? 3.2 : 2.5;
      speed *= burst;
      enemy.setTint(0xfb7185);
    }

    if (enemyType === "F" && grounded) {
      const nextJumpAt = enemy.getData("nextJumpAt") || 0;
      if (now >= nextJumpAt) {
        enemy.setVelocityY(-260);
        enemy.setData("nextJumpAt", now + 1150);
      }
    }

    const hitLeft = enemy.body.blocked.left || enemy.body.touching.left;
    const hitRight = enemy.body.blocked.right || enemy.body.touching.right;

    if (hitLeft) {
      dir = 1;
      enemy.x += 1.5;
    }
    if (hitRight) {
      dir = -1;
      enemy.x -= 1.5;
    }

    if (useBounded) {
      if (enemy.x <= minX + 2) {
        dir = 1;
      } else if (enemy.x >= maxX - 2) {
        dir = -1;
      }
    }

    if (grounded) {
      const aheadX = enemy.x + dir * (enemy.body.width / 2 + 8);
      const footY = enemy.body.bottom + 6;
      const noGroundAhead = !this.hasSupportAtWorld(aheadX, footY);
      const hazardAhead = this.isHazardAtWorld(aheadX, footY - 10);
      if ((!useBounded && noGroundAhead) || hazardAhead) {
        if (now >= turnCooldownUntil) {
          dir *= -1;
          enemy.setData("turnCooldownUntil", now + 160);
          enemy.x += dir * 4;
        }
      }
    }

    if (!grounded && !useBounded) {
      const fallbackAheadX = enemy.x + dir * (enemy.body.width / 2 + 5);
      const fallbackFootY = enemy.body.bottom + 10;
      if (!this.hasSupportAtWorld(fallbackAheadX, fallbackFootY) && now >= turnCooldownUntil) {
        dir *= -1;
        enemy.setData("turnCooldownUntil", now + 160);
      }
    }

    enemy.setData("direction", dir);
    enemy.setVelocityX(dir * speed);
    enemy.setData("isAggressive", aggressive);
    enemy.setData("aiState", aiState);
    enemy.setData("stateUntil", stateUntil);
    enemy.setData("attackCooldownUntil", attackCooldownUntil);

    // Stuck recovery: if enemy is grounded and not advancing, hop out of cracks.
    const lastX = enemy.getData("lastX");
    let stuckSince = enemy.getData("stuckSince") || now;
    const moved = Math.abs(enemy.x - lastX) > 2;
    if (moved) {
      stuckSince = now;
    }

    if (grounded && !moved && Math.abs(enemy.body.velocity.x) < 14) {
      if (now - stuckSince > 320) {
        const jumpY = enemyType === "H" ? -210 : -260;
        enemy.setVelocityY(jumpY);
        dir *= -1;
        enemy.setData("direction", dir);
        enemy.setVelocityX(dir * speed);
        stuckSince = now;
      }
    }

    enemy.setData("lastX", enemy.x);
    enemy.setData("stuckSince", stuckSince);
  }

  showToast(message, color = 0xfef3c7) {
    this.game.events.emit("toast-message", { text: message, color });
    if (Platformer.Debug) Platformer.Debug.log("GameScene.toast", message);
  }

  applyCoinMilestoneReward(totalCoins) {
    if (this.coinRewardState[totalCoins]) return;

    if (totalCoins === 3) {
      const before = this.registry.get("health") || 0;
      const after = Math.min(3, before + 1);
      if (after > before) {
        this.registry.set("health", after);
        this.showToast("Reward: +1 Health", 0x86efac);
      } else {
        this.showToast("Reward: Health already full", 0xbbf7d0);
      }
      this.coinRewardState[totalCoins] = true;
      this.events.emit("hud-update");
      this.updatePlayerHealthBar();
      return;
    }

    if (totalCoins === 6) {
      this.levelTimeRemainingMs += 12000;
      const secondsLeft = Math.ceil(this.levelTimeRemainingMs / 1000);
      this.registry.set("timeLeft", secondsLeft);
      this.showToast("Reward: +12s Time", 0x93c5fd);
      this.coinRewardState[totalCoins] = true;
      this.events.emit("hud-update");
      return;
    }

    if (totalCoins === 9) {
      this.shieldCharges += 1;
      this.registry.set("shield", this.shieldCharges);
      this.showToast("Reward: Shield x1", 0xc4b5fd);
      this.coinRewardState[totalCoins] = true;
      this.events.emit("hud-update");
    }
  }

  tryStartDash(now, moveLeft, moveRight) {
    const PLAYER = this.playerTuning || Platformer.Config.PLAYER;
    const grounded = this.player.body.blocked.down || this.player.body.touching.down;
    const canDash = now - this.lastDashAt >= PLAYER.dashCooldownMs;
    if (!canDash || this.isDashing) return false;

    let dir = this.facingDir || 1;
    if (moveLeft && !moveRight) dir = -1;
    if (moveRight && !moveLeft) dir = 1;

    this.isDashing = true;
    this.lastDashAt = now;
    this.dashEndsAt = now + PLAYER.dashDurationMs;
    this.player.setDragX(0);
    this.player.setAccelerationX(0);
    this.player.setVelocityX(dir * PLAYER.dashSpeed);
    if (!grounded && this.player.body.velocity.y > 30) {
      this.player.setVelocityY(30);
    }
    this.player.setTint(0x93c5fd);
    this.registry.set("dashCd", Math.ceil(PLAYER.dashCooldownMs / 1000));
    Platformer.beeper.dash();
    return true;
  }

  stopDash() {
    if (!this.isDashing) return;
    this.isDashing = false;
    this.player.setDragX((this.playerTuning || Platformer.Config.PLAYER).drag);
    this.player.clearTint();
  }

  tryAttack(now) {
    const PLAYER = this.playerTuning || Platformer.Config.PLAYER;
    if (now - this.lastAttackAt < PLAYER.attackCooldownMs) return;

    this.lastAttackAt = now;
    this.attackActiveUntil = now + 120;
    this.player.setTint(0xfde68a);
    Platformer.beeper.attack();

    let hits = 0;
    this.enemies.children.each((enemy) => {
      if (!enemy || !enemy.active) return;
      const dx = enemy.x - this.player.x;
      const dy = Math.abs(enemy.y - this.player.y);
      const inFront = this.facingDir > 0 ? dx >= -6 : dx <= 6;
      const inRange = Math.abs(dx) <= PLAYER.attackRange && dy <= 28;
      if (!inFront || !inRange) return;

      const hp = enemy.getData("hp") || 1;
      if (hp <= 1) {
        enemy.disableBody(true, true);
      } else {
        enemy.setData("hp", hp - 1);
        enemy.setTint(0xfca5a5);
      }
      hits += 1;
    });

    if (hits > 0) {
      this.showToast(`Hit x${hits}`, 0xfef08a);
    }
  }

  updateLandingFeedback() {
    const grounded = this.player.body.blocked.down || this.player.body.touching.down;
    const currentDownSpeed = Math.max(0, this.player.body.velocity.y);
    if (!grounded) {
      this.airbornePeakSpeedY = Math.max(this.airbornePeakSpeedY, currentDownSpeed);
    } else if (!this.wasGroundedLastFrame) {
      const impact = this.airbornePeakSpeedY;
      if (impact > 200) {
        // Screen shake removed: keep landing audio feedback only.
        Platformer.beeper.land();
      }
      this.airbornePeakSpeedY = 0;
    }
    this.wasGroundedLastFrame = grounded;
  }

  updateAuxHud(now) {
    if (now - this.lastAuxHudAt < 120) return;
    this.lastAuxHudAt = now;

    const dashLeft = Math.max(0, (Platformer.Config.PLAYER.dashCooldownMs - (now - this.lastDashAt)) / 1000);
    this.registry.set("dashCd", dashLeft);
    this.registry.set("shield", this.shieldCharges);
    this.registry.set("jetpackFuel", this.jetpackFuelPercent);
  }

  collectCoin(coin) {
    coin.disableBody(true, true);
    const updatedCoins = this.registry.get("coins") + 1;
    this.registry.set("coins", updatedCoins);
    Platformer.beeper.coin();
    this.applyCoinMilestoneReward(updatedCoins);
    this.events.emit("hud-update");

    if (updatedCoins >= Platformer.Config.WIN_COIN_TARGET && !this.levelComplete) {
      this.completeLevel();
    }
  }

  activateCheckpoint(checkpoint) {
    if (checkpoint.getData("activeCheckpoint")) {
      return;
    }

    this.checkpoints.children.each((cp) => {
      cp.clearTint();
      cp.setData("activeCheckpoint", false);
    });

    checkpoint.setTint(0x22c55e);
    checkpoint.setData("activeCheckpoint", true);
    this.respawnPoint.set(checkpoint.x, checkpoint.y - (this.tinyGridMode ? 10 : 20));
  }

  onHazardHit() {
    this.applyDamage(this.hazardDamage);
  }

  handleEnemyContact(enemy) {
    const PLAYER = this.playerTuning || Platformer.Config.PLAYER;

    if (!enemy.active || this.isDead) {
      return;
    }

    if (this.isDashing) {
      const hp = enemy.getData("hp") || 1;
      if (hp <= 1) {
        enemy.disableBody(true, true);
      } else {
        enemy.setData("hp", hp - 1);
      }
      this.player.setVelocityY(-PLAYER.jumpVelocity * 0.3);
      this.showToast("Dash Break!", 0x93c5fd);
      return;
    }

    const playerBottom = this.player.body.bottom;
    const enemyTop = enemy.body.top;
    const isStomp = this.player.body.velocity.y > 40 && playerBottom <= enemyTop + 10;

    if (isStomp) {
      const hp = enemy.getData("hp") || 1;
      if (hp <= 1) {
        enemy.disableBody(true, true);
      } else {
        enemy.setData("hp", hp - 1);
        enemy.setTint(0xfca5a5);
      }
      this.player.setVelocityY(-PLAYER.jumpVelocity * 0.55);
      Platformer.beeper.stomp();
      return;
    }

    const enemyType = enemy.getData("enemyType") || "E";
    const aiState = enemy.getData("aiState") || "patrol";
    const contactDamage = (enemyType === "H" || aiState === "lunge") ? 2 : 1;
    this.applyDamage(contactDamage);
  }

  applyDamage(amount = 1) {
    const PLAYER = this.playerTuning || Platformer.Config.PLAYER;
    const settings = Platformer.Settings.current;

    const now = this.time.now;
    const invuln = Math.round(PLAYER.hurtInvulnMs * this.hazardCooldownScale);
    if (now - this.lastDamageTime < invuln || this.isDead) {
      return;
    }

    if (this.shieldCharges > 0) {
      this.shieldCharges -= 1;
      this.registry.set("shield", this.shieldCharges);
      this.lastDamageTime = now;
      this.player.setTintFill(0xc4b5fd);
      this.time.delayedCall(90, () => {
        if (this.player && this.player.active) this.player.clearTint();
      });
      this.showToast("Shield blocked damage", 0xc4b5fd);
      return;
    }

    this.lastDamageTime = now;
    const newHealth = this.registry.get("health") - amount;
    this.registry.set("health", newHealth);
    this.events.emit("hud-update");
    this.updatePlayerHealthBar();
    Platformer.beeper.damage();

    if (newHealth <= 0) {
      const remainingLives = this.registry.get("lives") - 1;
      this.registry.set("lives", remainingLives);

      if (remainingLives <= 0) {
        this.isDead = true;
        this.game.events.emit("game-over");
        this.scene.pause();
        return;
      }

      this.registry.set("health", 3);
      this.respawn();
    } else {
      this.player.setVelocity(-this.player.body.velocity.x * 0.35, this.tinyGridMode ? -75 : -220);
      // Screen shake removed entirely.
    }
  }

  respawn() {
    const a11y = Platformer.Settings.current.accessibility;
    this.player.setPosition(this.respawnPoint.x, this.respawnPoint.y);
    this.alignPlayerBodyToFeet();
    this.resolvePlayerEmbedding("respawn");
    this.player.setVelocity(0, 0);
    this.player.setAccelerationX(0);
    this.player.clearTint();
    this.jumpsUsed = 0;
    this.isJumpHeld = false;
    this.isDashing = false;
    this.attackActiveUntil = 0;
    this.jetpackActive = false;
    if (this.jetpack) this.jetpack.reset(true);
    this.jetpackFuelPercent = this.jetpack ? this.jetpack.fuelPercent : 100;
    this.registry.set("jetpackFuel", this.jetpackFuelPercent);
    this.player.setAccelerationY(0);
    this.player.body.setGravityY(0);
    if (this.jetpackFlame) this.jetpackFlame.setVisible(false);
    if (!a11y.flashReduction) {
      this.cameras.main.flash(120, 255, 255, 255);
    }
    this.updatePlayerHealthBar();
    this.events.emit("hud-update");
  }

  completeLevel() {
    const a11y = Platformer.Settings.current.accessibility;
    const timeLeft = Number(this.registry.get("timeLeft") || 0);
    const coins = Number(this.registry.get("coins") || 0);
    const payload = {
      nodeId: this.currentNodeId,
      worldId: this.currentWorldId,
      level: this.registry.get("level"),
      coins,
      timeLeft,
      targetCoins: Platformer.Config.WIN_COIN_TARGET,
    };

    this.levelComplete = true;
    this.player.setAccelerationX(0);
    this.player.setVelocity(0, this.tinyGridMode ? -52 : -140);
    this.jetpackActive = false;
    if (this.jetpack) this.jetpack.reset(false);
    this.jetpackFuelPercent = this.jetpack ? this.jetpack.fuelPercent : this.jetpackFuelPercent;
    this.player.setAccelerationY(0);
    this.player.body.setGravityY(0);
    if (this.jetpackFlame) this.jetpackFlame.setVisible(false);
    this.player.setTexture("player-run-1");
    this.player.setTint(0xfef08a);
    this.physics.world.pause();
    const baseZoom = this.cameras.main ? this.cameras.main.zoom : 1;
    const targetZoom = this.tinyGridMode
      ? baseZoom * (a11y.reducedMotion ? 1.01 : 1.05)
      : (a11y.reducedMotion ? 1.02 : 1.15);
    this.cameras.main.zoomTo(targetZoom, a11y.reducedMotion ? 220 : 550, "Quad.easeOut", true);
    if (!a11y.flashReduction) {
      this.cameras.main.flash(200, 255, 255, 255);
    }
    if (Platformer.Progress && typeof Platformer.Progress.markLevelCompleted === "function") {
      try {
        const resolvedNodeId = Platformer.Progress.markLevelCompleted(payload);
        payload.resolvedNodeId = resolvedNodeId;
      } catch (err) {
        if (Platformer.Debug) {
          Platformer.Debug.error("GameScene.completeLevel", err && err.stack ? err.stack : String(err));
        }
      }
    }

    this.game.events.emit("level-complete", payload);
  }

  update() {
    const PLAYER = this.playerTuning || Platformer.Config.PLAYER;
    const { WIN_COIN_TARGET } = Platformer.Config;

    if (!this.player || this.isDead || this.levelComplete) {
      return;
    }

    const now = this.time.now;
    if (now - this.diagLastAt >= 450) {
      this.diagLastAt = now;
      this.runRuntimeDiagnostics(now);
    }
    this.updateLevelTimer(now);
    this.spawnHazardProjectiles(now);
    this.updateProjectiles();
    this.updatePlayerHealthBar();
    const moveLeft = this.keys.left.isDown || this.cursors.left.isDown;
    const moveRight = this.keys.right.isDown || this.cursors.right.isDown;
    const jumpPressed = Phaser.Input.Keyboard.JustDown(this.cursors.up)
      || Phaser.Input.Keyboard.JustDown(this.cursors.space)
      || Phaser.Input.Keyboard.JustDown(this.keys.jump);
    const dashPressed = Phaser.Input.Keyboard.JustDown(this.keys.dash);
    const attackPressed = Phaser.Input.Keyboard.JustDown(this.keys.attack);
    const demoWinPressed = Phaser.Input.Keyboard.JustDown(this.keys.demoWin);
    const grounded = this.player.body.blocked.down || this.player.body.touching.down;
    const jumpHeld = this.cursors.up.isDown || this.cursors.space.isDown || this.keys.jump.isDown;
    // Jetpack thrust is explicit: hold SPACE only.
    const jetpackInputHeld = !grounded && (
      this.cursors.space.isDown
      || (this.keys.jetpack && this.keys.jetpack.isDown)
    );
    const dt = Math.max(0.001, this.game.loop.delta / 1000);

    if (demoWinPressed && !this.levelComplete) {
      this.registry.set("coins", WIN_COIN_TARGET);
      this.events.emit("hud-update");
      this.completeLevel();
      return;
    }

    if (grounded) {
      this.lastOnGroundTime = now;
      this.jumpsUsed = 0;
    }

    if (jumpPressed) {
      this.lastJumpPressedTime = now;
    }

    const canUseCoyote = now - this.lastOnGroundTime <= PLAYER.coyoteTimeMs;
    const hasBufferedJump = now - this.lastJumpPressedTime <= PLAYER.jumpBufferMs;

    // Prevent mid-air jump velocity resets: coyote jump is only valid before first jump is consumed.
    if (!this.isDashing && this.jumpsUsed === 0 && canUseCoyote && hasBufferedJump) {
      this.player.setVelocityY(-PLAYER.jumpVelocity);
      this.jumpsUsed = 1;
      this.lastOnGroundTime = -9999;
      this.lastJumpPressedTime = -9999;
      this.isJumpHeld = true;
      Platformer.beeper.jump();
    }
    const jetpackStatus = this.jetpack
      ? this.jetpack.update({
        scene: this,
        player: this.player,
        now,
        dt,
        grounded,
        jumpHeld,
        thrustHeld: jetpackInputHeld,
        worldGravity: PLAYER.gravity,
        jumpVelocity: PLAYER.jumpVelocity,
      })
      : { isThrusting: false, fuelPercent: 0 };
    this.jetpackActive = !!jetpackStatus.isThrusting;
    this.jetpackFuelPercent = Phaser.Math.Clamp(Number(jetpackStatus.fuelPercent || 0), 0, 100);
    if (this.jetpackActive) {
      this.isJumpHeld = false;
    }

    // Safety clamp: prevent rare vertical-speed spikes from interactions/stacked forces.
    const maxRiseSpeed = Math.max(120, Number(PLAYER.maxRiseSpeed || 520));
    const maxFallSpeed = Math.max(200, Number(PLAYER.maxFallSpeed || 760));
    if (this.player.body.velocity.y < -maxRiseSpeed) {
      this.player.setVelocityY(-maxRiseSpeed);
    } else if (this.player.body.velocity.y > maxFallSpeed) {
      this.player.setVelocityY(maxFallSpeed);
    }

    if (!this.isDashing && !jumpHeld && this.isJumpHeld && this.player.body.velocity.y < -120) {
      this.player.setVelocityY(this.player.body.velocity.y * 0.5);
      this.isJumpHeld = false;
    }

    if (dashPressed) {
      this.tryStartDash(now, moveLeft, moveRight);
    }
    if (attackPressed) {
      this.tryAttack(now);
    }

    const opposingInput = moveLeft && moveRight;

    if (this.isDashing) {
      const dashDir = this.player.body.velocity.x >= 0 ? 1 : -1;
      this.player.setVelocityX(dashDir * PLAYER.dashSpeed);
      this.player.setAccelerationX(0);
      this.player.setDragX(0);
      if (now >= this.dashEndsAt) {
        this.stopDash();
      }
    } else {
      const moveSpeed = grounded ? PLAYER.maxSpeed : Math.floor(PLAYER.maxSpeed * 0.9);
      this.player.setAccelerationX(0);
      this.player.setDragX(0);

      if (opposingInput || (!moveLeft && !moveRight)) {
        // Digital stop: no inertia, no glide, no opposite-key slide.
        this.player.setVelocityX(0);
        if (this.player.body) this.player.body.velocity.x = 0;
      } else if (moveLeft) {
        this.player.setVelocityX(-moveSpeed);
        this.player.setFlipX(false);
        this.facingDir = -1;
      } else if (moveRight) {
        this.player.setVelocityX(moveSpeed);
        this.player.setFlipX(true);
        this.facingDir = 1;
      }
    }
    if (this.tinyGridMode && this.player && this.player.body) {
      const body = this.player.body;
      if ((body.blocked.left && moveLeft && !moveRight) || (body.blocked.right && moveRight && !moveLeft)) {
        this.player.setVelocityX(0);
      }
      if (body.embedded) {
        this.resolvePlayerEmbedding("runtime");
      }
    }
    this.resolveGroundPenetration(now);
    this.logIfPlayerInsideTile(now);
    this.drawHitboxOverlay(now);
    if (!this.isDashing && now > this.attackActiveUntil) {
      this.player.clearTint();
    }

    this.updateJetpackFx(now, this.jetpackActive);

    if (this.useImportedCharacter) {
      if (!grounded) {
        if (this.player.anims && this.player.anims.isPlaying) {
          this.player.anims.stop();
        }
        if (this.player.texture && this.player.texture.key === "player-idle-sheet") {
          const airborneFrame = this.jetpackActive ? ((Math.floor(now / 90) % 2 === 0) ? 1 : 2) : 2;
          this.player.setFrame(airborneFrame);
        }
      } else if (this.anims.exists("playerIdleAnim")) {
        if (!this.player.anims.isPlaying || this.player.anims.getName() !== "playerIdleAnim") {
          this.player.setTexture("player-idle-sheet", 0);
          this.player.play("playerIdleAnim");
        }
      } else {
        if (!this.idleAnimWarned && Platformer.Debug) {
          Platformer.Debug.warn("GameScene.playerIdle", "playerIdleAnim not found; fallback idle in use.");
          this.idleAnimWarned = true;
        }
        this.player.setTexture((Math.floor(now / 360) % 2 === 0) ? "player-idle-1" : "player-idle-2");
      }
    } else if (this.jetpackActive || this.player.body.velocity.y < (this.tinyGridMode ? -8 : -25) || !this.player.body.blocked.down) {
      if (this.player.anims && this.player.anims.isPlaying) {
        this.player.anims.stop();
      }
      this.player.setTexture("player-jump");
    } else if (Math.abs(this.player.body.velocity.x) > (this.tinyGridMode ? 10 : 35)) {
      if (this.player.anims && this.player.anims.isPlaying) {
        this.player.anims.stop();
      }
      this.player.setTexture((Math.floor(now / 100) % 2 === 0) ? "player-run-1" : "player-run-2");
    } else {
      this.player.setTexture((Math.floor(now / 360) % 2 === 0) ? "player-idle-1" : "player-idle-2");
    }

    let anyAggressive = false;
    this.enemies.children.each((enemy) => {
      this.updateEnemyPatrol(enemy, now);
      if (enemy.getData("isAggressive")) {
        anyAggressive = true;
      }
    });
    const projectileThreat = this.hazardProjectiles && this.hazardProjectiles.countActive(true) > 0;
    const threat = anyAggressive || projectileThreat;
    if (threat !== this.threatActive) {
      this.threatActive = threat;
      this.registry.set("threat", threat ? "DANGER" : "CALM");
    }
    this.updateLandingFeedback();
    this.updateAuxHud(now);

    if (this.player.y > this.mapHeight * Platformer.Config.TILE + 140) {
      this.applyDamage();
      if (!this.isDead) {
        this.respawn();
      }
    }
  }

  shutdown() {
    if (this.onRestartLevel) {
      this.game.events.off("restart-level", this.onRestartLevel);
      this.onRestartLevel = null;
    }
    if (this.onSettingsChanged) {
      this.game.events.off("settings-changed", this.onSettingsChanged);
      this.onSettingsChanged = null;
    }
    this.scale.off("resize", this.updateCameraFraming, this);
    if (this.jetpackFlame && this.jetpackFlame.destroy) {
      this.jetpackFlame.destroy();
      this.jetpackFlame = null;
    }
    if (this.onHitboxesToggle) {
      window.removeEventListener("platformer:hitboxes-toggle", this.onHitboxesToggle);
      this.onHitboxesToggle = null;
    }
    if (this.onPlayerHitboxChanged) {
      window.removeEventListener("platformer:player-hitbox-changed", this.onPlayerHitboxChanged);
      this.onPlayerHitboxChanged = null;
    }
    if (this.hitboxOverlay && this.hitboxOverlay.destroy) {
      this.hitboxOverlay.destroy();
      this.hitboxOverlay = null;
    }
    if (Array.isArray(this.ldtkVisualTiles) && this.ldtkVisualTiles.length) {
      this.ldtkVisualTiles.forEach((o) => { if (o && o.destroy) o.destroy(); });
      this.ldtkVisualTiles = [];
    }
  }
};
  /* <<< scenes/game-scene.js */

  /* >>> scenes/ui-scene.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.UIScene = class extends Phaser.Scene {
  constructor() {
    super("UIScene");
    this.hudText = null;
    this.pauseText = null;
    this.gameOverText = null;
    this.victoryText = null;
    this.victorySubText = null;
    this.victoryBars = [];
    this.victorySpeedLines = [];
    this.victoryCharacter = null;
    this.transitionText = null;
    this.toastText = null;
    this.toastTween = null;
    this.pausePanel = null;
    this.pauseButtons = [];
    this.pauseMusic = null;
    this.pauseMusicHtml = null;
    this.resumePhaserGameMusic = false;
    this.resumeHtmlGameMusic = false;
    this.onRegistryChanged = null;
    this.gamePaused = false;
    this.gameOver = false;
    this.levelComplete = false;
    this.onPauseKey = null;
    this.onRestartKey = null;
    this.onEnterKey = null;
    this.onGameOver = null;
    this.onLevelComplete = null;
    this.onLevelTransition = null;
    this.onOptionsClosed = null;
    this.onToastMessage = null;
    this.pauseKeyEventName = null;
    this.lastLevelCompletePayload = null;
    this.jetpackFuelBg = null;
    this.jetpackFuelFill = null;
    this.jetpackFuelLabel = null;
    this.onResize = null;
  }

  init() {
    // Register pause key early so it's ready before GameScene becomes interactive
    const pauseKey = Platformer.Settings.current.controls.pause || "ESC";
    this.pauseKeyEventName = `keydown-${pauseKey}`;
  }

  create() {
    const textScale = Platformer.Settings.textScale();

    this.hudText = this.add.text(16, 14, "", {
      fontFamily: "Consolas",
      fontSize: `${Math.round(20 * textScale)}px`,
      color: "#f8fafc",
      stroke: "#111827",
      strokeThickness: 4,
    }).setScrollFactor(0);
    this.jetpackFuelLabel = this.add.text(16, 46, "Jetpack", {
      fontFamily: "Consolas",
      fontSize: `${Math.round(16 * textScale)}px`,
      color: "#bfdbfe",
      stroke: "#111827",
      strokeThickness: 3,
    }).setScrollFactor(0);
    this.jetpackFuelBg = this.add.rectangle(102, 58, 172, 12, 0x111827, 0.92)
      .setOrigin(0, 0.5)
      .setScrollFactor(0)
      .setStrokeStyle(1, 0x93c5fd, 0.85);
    this.jetpackFuelFill = this.add.rectangle(104, 58, 168, 8, 0x22d3ee, 1)
      .setOrigin(0, 0.5)
      .setScrollFactor(0);

    this.pauseText = this.add.text(this.scale.width / 2, this.scale.height / 2, "PAUSED", {
      fontFamily: "Verdana",
      fontSize: `${Math.round(56 * textScale)}px`,
      color: "#fcd34d",
      stroke: "#1f2937",
      strokeThickness: 6,
    }).setOrigin(0.5).setScrollFactor(0).setVisible(false);
    this.buildPauseMenu(textScale);

    this.gameOverText = this.add.text(this.scale.width / 2, this.scale.height / 2,
      "GAME OVER\nPress R to Restart", {
        fontFamily: "Verdana",
        fontSize: `${Math.round(44 * textScale)}px`,
        color: "#fca5a5",
        align: "center",
        stroke: "#1f2937",
        strokeThickness: 6,
      }
    ).setOrigin(0.5).setScrollFactor(0).setVisible(false);

    this.victoryText = this.add.text(this.scale.width / 2, this.scale.height / 2 - 24,
      "MISSION CLEAR!", {
        fontFamily: "Impact, Haettenschweiler, Arial Narrow Bold, sans-serif",
        fontSize: `${Math.round(74 * textScale)}px`,
        color: "#fde047",
        stroke: "#7f1d1d",
        strokeThickness: 12,
        shadow: { offsetX: 0, offsetY: 0, color: "#000000", blur: 10, fill: true },
      }
    ).setOrigin(0.5).setScrollFactor(0).setVisible(false).setAlpha(0);

    this.victorySubText = this.add.text(this.scale.width / 2, this.scale.height / 2 + 52,
      "Coins Secured. Press ENTER for World Map", {
        fontFamily: "Consolas",
        fontSize: `${Math.round(26 * textScale)}px`,
        color: "#f8fafc",
        stroke: "#111827",
        strokeThickness: 6,
      }
    ).setOrigin(0.5).setScrollFactor(0).setVisible(false).setAlpha(0);

    this.transitionText = this.add.text(this.scale.width / 2, this.scale.height / 2,
      "", {
        fontFamily: "Verdana",
        fontSize: `${Math.round(46 * textScale)}px`,
        color: "#fef08a",
        stroke: "#1f2937",
        strokeThickness: 7,
        align: "center",
      }
    ).setOrigin(0.5).setScrollFactor(0).setVisible(false).setDepth(120);

    this.toastText = this.add.text(this.scale.width / 2, 74, "", {
      fontFamily: "Consolas",
      fontSize: `${Math.round(24 * textScale)}px`,
      color: "#fef3c7",
      stroke: "#111827",
      strokeThickness: 5,
      align: "center",
    }).setOrigin(0.5).setScrollFactor(0).setVisible(false).setDepth(130);

    this.createVictoryFX();
    this.layoutHud();
    this.layoutPauseMenu();
    this.updateHud();

    this.onRegistryChanged = () => this.updateHud();
    this.registry.events.on("changedata", this.onRegistryChanged);

    this.onGameOver = () => {
      this.gameOver = true;
      if (Platformer.Debug) Platformer.Debug.warn("UIScene", "Game over shown.");
      this.gameOverText.setVisible(true);
      this.hidePauseMenu();
    };
    this.game.events.on("game-over", this.onGameOver);

    this.onLevelComplete = (payload) => {
      this.levelComplete = true;
      this.lastLevelCompletePayload = payload || null;
      if (Platformer.Debug) Platformer.Debug.log("UIScene", "Level complete overlay shown.");
      this.hidePauseMenu();
      this.showVictorySequence();
    };
    this.game.events.on("level-complete", this.onLevelComplete);

    this.onLevelTransition = (payload) => {
      this.hidePauseMenu();
      this.showLevelTransition(payload);
    };
    this.game.events.on("level-transition", this.onLevelTransition);

    this.onOptionsClosed = () => {
      if (!this.gameOver && !this.levelComplete && this.scene.isPaused("GameScene")) {
        this.showPauseMenu();
      }
    };
    this.game.events.on("options-closed-to-pause", this.onOptionsClosed);

    this.onToastMessage = (payload) => this.showToast(payload);
    this.game.events.on("toast-message", this.onToastMessage);

    this.onPauseKey = () => {
      if (this.scene.isActive("OptionsScene")) return;
      if (this.gameOver || this.levelComplete) return;
      this.togglePauseMenu();
    };
    this.input.keyboard.on(this.pauseKeyEventName, this.onPauseKey);

    this.onRestartKey = () => {
      if (!this.gameOver) return;
      this.gameOver = false;
      this.gamePaused = false;
      this.gameOverText.setVisible(false);
      this.hidePauseMenu();
      this.game.events.emit("restart-level");
    };
    this.input.keyboard.on("keydown-R", this.onRestartKey);

    this.onEnterKey = () => {
      if (!this.levelComplete) return;
      this.levelComplete = false;
      this.resetOverlayStates();
      this.stopGameplayMusic();
      this.scene.stop("GameScene");
      this.scene.stop();
      const focusNodeId = this.lastLevelCompletePayload && (this.lastLevelCompletePayload.resolvedNodeId || this.lastLevelCompletePayload.nodeId);
      this.scene.start("WorldMapScene", { focusNodeId: focusNodeId || null });
    };
    this.input.keyboard.on("keydown-ENTER", this.onEnterKey);

    this.onResize = () => {
      this.layoutHud();
      this.layoutPauseMenu();
    };
    this.scale.on("resize", this.onResize);
  }

  layoutHud() {
    if (this.hudText) this.hudText.setPosition(16, 14);
    if (this.jetpackFuelLabel) this.jetpackFuelLabel.setPosition(16, 46);
    if (this.jetpackFuelBg) this.jetpackFuelBg.setPosition(102, 58);
    if (this.jetpackFuelFill) this.jetpackFuelFill.setPosition(104, 58);
  }

  buildPauseMenu(textScale) {
    const cx = this.scale.width / 2;
    const cy = this.scale.height / 2;

    this.pausePanel = this.add.rectangle(cx, cy, 560, 340, 0x020617, 0.86)
      .setStrokeStyle(2, 0x94a3b8, 0.8)
      .setScrollFactor(0)
      .setVisible(false)
      .setDepth(100);

    this.pauseText.setDepth(101);
    this.pauseText.setY(cy - 118);

    const createBtn = (y, label, onClick) => {
      const offsetY = y - cy;
      const box = this.add.rectangle(cx, y, 280, 50, 0x1d4ed8, 0.96)
        .setStrokeStyle(2, 0x93c5fd, 0.9)
        .setDepth(101)
        .setScrollFactor(0)
        .setVisible(false)
        .setInteractive({ useHandCursor: true });
      const text = this.add.text(cx, y, label, {
        fontFamily: "Consolas",
        fontSize: `${Math.round(28 * textScale)}px`,
        color: "#f8fafc",
      }).setOrigin(0.5).setDepth(102).setScrollFactor(0).setVisible(false);

      box.on("pointerover", () => box.setFillStyle(0x2563eb, 0.98));
      box.on("pointerout", () => box.setFillStyle(0x1d4ed8, 0.96));
      box.on("pointerdown", onClick);

      this.pauseButtons.push({ box, text, offsetY, label });
    };

    createBtn(cy - 30, "Resume", () => this.resumeFromPause());
    createBtn(cy + 35, "Options", () => {
      this.hidePauseMenu();
      this.scene.launch("OptionsScene", { returnTo: "pause" });
    });
    createBtn(cy + 100, "Return to Menu", () => {
      if (Platformer.Debug) Platformer.Debug.warn("UIScene.pause", "Return to Menu clicked.");
      this.stopPauseMusic();
      this.stopGameplayMusic();
      this.hidePauseMenu();
      this.scene.stop("GameScene");
      if (this.scene.isActive("OptionsScene")) this.scene.stop("OptionsScene");
      this.scene.stop();
      this.scene.start("MenuScene");
    });
  }

  layoutPauseMenu() {
    const cx = this.scale.width / 2;
    const cy = this.scale.height / 2;
    if (this.pausePanel) this.pausePanel.setPosition(cx, cy);
    if (this.pauseText) this.pauseText.setPosition(cx, cy - 118);
    this.pauseButtons.forEach((b) => {
      if (!b) return;
      const targetY = cy + (Number.isFinite(b.offsetY) ? b.offsetY : 0);
      if (b.box) b.box.setPosition(cx, targetY);
      if (b.text) b.text.setPosition(cx, targetY);
    });
    if (this.gameOverText) this.gameOverText.setPosition(cx, cy);
    if (this.transitionText) this.transitionText.setPosition(cx, cy);
    if (this.toastText) this.toastText.setPosition(cx, 74);
    if (this.victoryText) this.victoryText.setPosition(cx, cy - 24);
    if (this.victorySubText) this.victorySubText.setPosition(cx, cy + 52);
  }

  showPauseMenu() {
    if (Platformer.Debug) Platformer.Debug.log("UIScene.pause", "Pause menu opened.");
    this.layoutPauseMenu();
    this.pauseGameplayMusic();
    this.playPauseMusic();
    this.pausePanel.setVisible(true);
    this.pauseText.setVisible(true);
    this.pauseButtons.forEach((b) => {
      b.box.setVisible(true);
      b.text.setVisible(true);
    });
    if (Platformer.Debug) {
      try {
        const ys = this.pauseButtons.map((b) => (b && b.box ? Math.round(b.box.y) : -1)).filter((y) => y >= 0);
        const sorted = ys.slice().sort((a, b) => a - b);
        const minGap = sorted.length > 1 ? Math.min(...sorted.slice(1).map((v, i) => v - sorted[i])) : 999;
        Platformer.Debug.log("UIScene.pause", `buttonYs=${ys.join(",")} minGap=${minGap}`);
        if (minGap < 28) {
          Platformer.Debug.warn("UIScene.pause.layout", "Pause buttons are too close/overlapping after layout.");
        }
      } catch (err) {
        Platformer.Debug.warn("UIScene.pause.layout", `Diagnostics failed: ${err && err.message ? err.message : err}`);
      }
    }
    this.gamePaused = true;
  }

  hidePauseMenu() {
    if (this.pausePanel) this.pausePanel.setVisible(false);
    this.pauseText.setVisible(false);
    this.pauseButtons.forEach((b) => {
      b.box.setVisible(false);
      b.text.setVisible(false);
    });
    this.gamePaused = false;
  }

  togglePauseMenu() {
    if (this.scene.isPaused("GameScene")) {
      this.resumeFromPause();
    } else {
      this.scene.pause("GameScene");
      this.showPauseMenu();
    }
  }

  resumeFromPause() {
    if (Platformer.Debug) Platformer.Debug.log("UIScene.pause", "Resuming gameplay from pause.");
    this.stopPauseMusic();
    this.resumeGameplayMusic();
    this.scene.resume("GameScene");
    this.hidePauseMenu();
  }

  pauseGameplayMusic() {
    if (Platformer.gameMusic && Platformer.gameMusic.isPlaying) {
      try {
        Platformer.gameMusic.pause();
        this.resumePhaserGameMusic = true;
      } catch (_e) {
        // Ignore; best effort.
      }
    }

    if (Platformer.gameMusicHtml && !Platformer.gameMusicHtml.paused) {
      try {
        Platformer.gameMusicHtml.pause();
        this.resumeHtmlGameMusic = true;
      } catch (_e) {
        // Ignore; best effort.
      }
    }
  }

  resumeGameplayMusic() {
    if (this.resumePhaserGameMusic && Platformer.gameMusic) {
      try {
        Platformer.gameMusic.resume();
      } catch (_e) {
        // Ignore; best effort.
      }
    }

    if (this.resumeHtmlGameMusic && Platformer.gameMusicHtml) {
      Platformer.gameMusicHtml.play().catch(() => {});
    }

    this.resumePhaserGameMusic = false;
    this.resumeHtmlGameMusic = false;
  }

  stopGameplayMusic() {
    if (Platformer.Debug) Platformer.Debug.log("UIScene.audio", "Stopping gameplay music for scene transition.");
    if (Platformer.gameMusic) {
      try {
        if (Platformer.gameMusic.isPlaying) {
          Platformer.gameMusic.stop();
        } else if (typeof Platformer.gameMusic.pause === "function") {
          Platformer.gameMusic.pause();
        }
      } catch (_e) {
        // best effort
      }
      Platformer.gameMusic = null;
    }
    if (Platformer.gameMusicHtml) {
      try {
        Platformer.gameMusicHtml.pause();
        Platformer.gameMusicHtml.currentTime = 0;
      } catch (_e) {
        // best effort
      }
      Platformer.gameMusicHtml = null;
    }
    this.resumePhaserGameMusic = false;
    this.resumeHtmlGameMusic = false;
  }

  playPauseMusic() {
    const audioSettings = Platformer.Settings.current.audio;
    const volume = Phaser.Math.Clamp((audioSettings.master / 100) * (audioSettings.music / 100), 0, 1);

    if (this.cache.audio.exists("pause-bgm")) {
      if (!this.pauseMusic) {
        this.pauseMusic = this.sound.get("pause-bgm");
        if (!this.pauseMusic) {
          try {
            this.pauseMusic = this.sound.add("pause-bgm", { loop: true, volume });
          } catch (_e) {
            this.pauseMusic = null;
          }
        }
      }
      if (this.pauseMusic) {
        this.pauseMusic.setLoop(true);
        this.pauseMusic.setVolume(volume);
        if (!this.pauseMusic.isPlaying) {
          try {
            this.pauseMusic.play();
          } catch (_e) {
            // Autoplay gating: user already pressed ESC, so retry on next input if needed.
          }
        }
        return;
      }
    }

    // HTML audio fallback.
    if (!this.pauseMusicHtml) {
      try {
        this.pauseMusicHtml = new Audio("assets/Elevator Music - So Chill (mp3cut.net).mp3");
        Platformer.pauseMusicHtml = this.pauseMusicHtml;
        this.pauseMusicHtml.loop = true;
      } catch (_e) {
        this.pauseMusicHtml = null;
      }
    }
    if (this.pauseMusicHtml) {
      this.pauseMusicHtml.volume = volume;
      this.pauseMusicHtml.play().catch(() => {});
    }
  }

  stopPauseMusic() {
    if (this.pauseMusic && this.pauseMusic.isPlaying) {
      this.pauseMusic.stop();
    }
    if (this.pauseMusicHtml) {
      this.pauseMusicHtml.pause();
      this.pauseMusicHtml.currentTime = 0;
      Platformer.pauseMusicHtml = null;
    }
  }

  updateHud() {
    if (!this.hudText || !this.hudText.active) {
      return;
    }
    if (!this.sys || !this.sys.settings || !this.sys.settings.active) {
      return;
    }

    const lives = this.registry.get("lives");
    const health = this.registry.get("health");
    const coins = this.registry.get("coins");
    const level = this.registry.get("level");
    const timeLeft = this.registry.get("timeLeft");
    const threat = this.registry.get("threat");
    const dashCd = Number(this.registry.get("dashCd") || 0);
    const shield = Math.max(0, Number(this.registry.get("shield") || 0));
    const jetpackFuel = Phaser.Math.Clamp(Number(this.registry.get("jetpackFuel") || 0), 0, 100);
    const { WIN_COIN_TARGET } = Platformer.Config;
    const dashTxt = dashCd <= 0.06 ? "READY" : `${dashCd.toFixed(1)}s`;

    try {
      this.hudText.setText(
        `Level: ${level}   Lives: ${Math.max(0, lives)}   Health: ${Math.max(0, health)}   Coins: ${coins}/${WIN_COIN_TARGET}   Time: ${Math.max(0, timeLeft || 0)}   Threat: ${threat || "CALM"}   Dash: ${dashTxt}   Shield: ${shield}   Fuel: ${Math.round(jetpackFuel)}%`
      );
      if (this.jetpackFuelFill && this.jetpackFuelBg) {
        const fillW = Math.max(0, Math.round(168 * (jetpackFuel / 100)));
        this.jetpackFuelFill.width = fillW;
        const color = jetpackFuel > 60 ? 0x22d3ee : (jetpackFuel > 28 ? 0xf59e0b : 0xef4444);
        this.jetpackFuelFill.setFillStyle(color, 1);
      }
    } catch (err) {
      const msg = err && err.stack ? err.stack : String(err);
      if (Platformer.Debug && Platformer.Debug.error) {
        Platformer.Debug.error("UIScene.updateHud", msg);
      }
    }
  }

  showToast(payload) {
    if (!payload || !this.toastText) return;
    const text = String(payload.text || "").trim();
    if (!text) return;
    const color = payload.color || 0xfef3c7;
    this.toastText.setText(text);
    this.toastText.setColor(`#${color.toString(16).padStart(6, "0")}`);
    this.toastText.setAlpha(1);
    this.toastText.setVisible(true);
    if (this.toastTween) {
      this.toastTween.stop();
      this.toastTween = null;
    }
    this.toastTween = this.tweens.add({
      targets: this.toastText,
      y: 58,
      alpha: 0,
      duration: 900,
      ease: "Quad.easeOut",
      onComplete: () => {
        if (this.toastText) {
          this.toastText.setVisible(false);
          this.toastText.setY(74);
        }
      },
    });
  }

  createVictoryFX() {
    const topBar = this.add.rectangle(this.scale.width / 2, -45, this.scale.width, 90, 0x020617, 0.92)
      .setScrollFactor(0).setVisible(false);
    const bottomBar = this.add.rectangle(this.scale.width / 2, this.scale.height + 45, this.scale.width, 90, 0x020617, 0.92)
      .setScrollFactor(0).setVisible(false);
    this.victoryBars = [topBar, bottomBar];

    const lineColor = 0xffffff;
    for (let i = 0; i < 16; i += 1) {
      const y = 40 + i * 30;
      const line = this.add.rectangle(-220, y, 190, 4, lineColor, 0.22)
        .setAngle(-16)
        .setScrollFactor(0)
        .setVisible(false);
      this.victorySpeedLines.push(line);
    }

    this.victoryCharacter = this.buildVictoryCharacter(this.scale.width - 210, this.scale.height - 210);
    this.victoryCharacter.setVisible(false).setAlpha(0).setScale(0.8);
  }

  buildVictoryCharacter(x, y) {
    const style = [
      "width:236px",
      "height:236px",
      "border:4px solid #fde047",
      "background:rgba(15,23,42,0.86)",
      "display:flex",
      "align-items:center",
      "justify-content:center",
      "overflow:hidden",
      "box-sizing:border-box",
    ].join(";");

    const dom = this.add.dom(x, y, "div", style, "").setScrollFactor(0);
    const img = document.createElement("img");
    img.src = "./assets/kawaii-anime-girl.gif";
    img.alt = "Victory Girl";
    img.style.width = "220px";
    img.style.height = "220px";
    img.style.objectFit = "cover";
    img.onerror = () => {
      dom.node.innerHTML = "<span style='font-family:Consolas;color:#f8fafc;font-size:32px'>VICTORY</span>";
    };
    dom.node.appendChild(img);

    return dom;
  }

  showVictorySequence() {
    if (this.victoryCharacter) {
      this.victoryCharacter.destroy();
    }
    this.victoryCharacter = this.buildVictoryCharacter(this.scale.width - 210, this.scale.height - 210);
    this.victoryCharacter.setVisible(false).setAlpha(0).setScale(0.8);

    this.pauseText.setVisible(false);
    this.gameOverText.setVisible(false);
    this.victoryBars.forEach((bar) => bar.setVisible(true));
    this.victorySpeedLines.forEach((line) => line.setVisible(true));
    this.victoryText.setVisible(true);
    this.victorySubText.setVisible(true);
    this.victoryCharacter.setVisible(true);

    this.tweens.add({
      targets: this.victoryBars[0],
      y: 40,
      duration: 320,
      ease: "Cubic.easeOut",
    });
    this.tweens.add({
      targets: this.victoryBars[1],
      y: this.scale.height - 40,
      duration: 320,
      ease: "Cubic.easeOut",
    });

    this.victorySpeedLines.forEach((line, idx) => {
      line.x = -220 - idx * 36;
      this.tweens.add({
        targets: line,
        x: this.scale.width + 220,
        duration: 360 + idx * 22,
        ease: "Linear",
        repeat: -1,
        delay: idx * 20,
      });
    });

    this.tweens.add({
      targets: this.victoryText,
      alpha: 1,
      scaleX: { from: 1.65, to: 1 },
      scaleY: { from: 0.35, to: 1 },
      angle: { from: -8, to: 0 },
      duration: 280,
      ease: "Back.easeOut",
    });

    this.tweens.add({
      targets: this.victorySubText,
      alpha: 1,
      y: this.victorySubText.y + 10,
      duration: 240,
      delay: 180,
      ease: "Quad.easeOut",
    });

    this.tweens.add({
      targets: this.victoryText,
      scale: 1.05,
      yoyo: true,
      duration: 620,
      repeat: -1,
      ease: "Sine.easeInOut",
    });

    this.tweens.add({
      targets: this.victoryCharacter,
      alpha: 1,
      scale: 1,
      x: this.scale.width - 196,
      duration: 300,
      ease: "Back.easeOut",
    });

    this.tweens.add({
      targets: this.victoryCharacter,
      y: this.victoryCharacter.y - 8,
      yoyo: true,
      repeat: -1,
      duration: 900,
      ease: "Sine.easeInOut",
    });
  }

  showLevelTransition(payload) {
    const from = payload && payload.from ? payload.from : "?";
    const to = payload && payload.to ? payload.to : "?";
    this.transitionText
      .setText(`LEVEL ${from} CLEAR\\nNEXT: LEVEL ${to}`)
      .setVisible(true)
      .setAlpha(0)
      .setScale(1.1);

    this.tweens.add({
      targets: this.transitionText,
      alpha: 1,
      scale: 1,
      duration: 220,
      yoyo: true,
      hold: 350,
      onComplete: () => this.transitionText.setVisible(false),
    });
  }

  resetOverlayStates() {
    this.gameOverText.setVisible(false);
    this.pauseText.setVisible(false);
    this.hidePauseMenu();
    this.stopPauseMusic();
    this.victoryText.setVisible(false).setAlpha(0).setScale(1).setAngle(0);
    if (this.transitionText) {
      this.transitionText.setVisible(false).setAlpha(0).setScale(1);
    }
    this.victorySubText.setVisible(false).setAlpha(0).setY(this.scale.height / 2 + 52);
    this.victoryBars[0].setVisible(false).setY(-45);
    this.victoryBars[1].setVisible(false).setY(this.scale.height + 45);
    this.victorySpeedLines.forEach((line) => line.setVisible(false));

    if (this.victoryCharacter) {
      this.victoryCharacter.setVisible(false).setAlpha(0).setScale(0.8);
      this.victoryCharacter.setPosition(this.scale.width - 210, this.scale.height - 210);
    }

    this.tweens.killAll();
  }

  shutdown() {
    this.stopPauseMusic();
    this.resumePhaserGameMusic = false;
    this.resumeHtmlGameMusic = false;
    if (this.toastTween) {
      this.toastTween.stop();
      this.toastTween = null;
    }
    if (this.onRegistryChanged) {
      this.registry.events.off("changedata", this.onRegistryChanged);
      this.onRegistryChanged = null;
    }
    if (this.onGameOver) this.game.events.off("game-over", this.onGameOver);
    if (this.onLevelComplete) this.game.events.off("level-complete", this.onLevelComplete);
    if (this.onLevelTransition) this.game.events.off("level-transition", this.onLevelTransition);
    if (this.onOptionsClosed) this.game.events.off("options-closed-to-pause", this.onOptionsClosed);
    if (this.onToastMessage) this.game.events.off("toast-message", this.onToastMessage);
    if (this.onPauseKey && this.pauseKeyEventName) this.input.keyboard.off(this.pauseKeyEventName, this.onPauseKey);
    if (this.onRestartKey) this.input.keyboard.off("keydown-R", this.onRestartKey);
    if (this.onEnterKey) this.input.keyboard.off("keydown-ENTER", this.onEnterKey);
    if (this.onResize) this.scale.off("resize", this.onResize);
    this.onPauseKey = null;
    this.onRestartKey = null;
    this.onEnterKey = null;
    this.onGameOver = null;
    this.onLevelComplete = null;
    this.onLevelTransition = null;
    this.onOptionsClosed = null;
    this.onToastMessage = null;
    this.pauseKeyEventName = null;
    this.onResize = null;
  }
};
  /* <<< scenes/ui-scene.js */

  /* >>> main.js */
// [bundle] namespace init removed; using local Platformer namespace.

(async () => {
  if (!Platformer.BUILD_VERSION || typeof Platformer.BUILD_VERSION !== "string") {
    document.body.innerHTML = "<div style='font-family:Consolas,monospace;padding:24px;color:#fee2e2;background:#1f2937'>Build metadata missing. Rebuild the game package.</div>";
    throw new Error("BUILD_VERSION missing.");
  }
  await Platformer.Settings.bootstrap();
  const { PLAYER } = Platformer.Config;
  const settings = Platformer.Settings.current;
  const fpsTarget = settings.video.fpsCap === "unlimited" ? 0 : Number(settings.video.fpsCap);
  const isFileProtocol = window.location.protocol === "file:";
  const isDesktopHost = !!(window.pywebview && window.pywebview.api);
  const dpr = isDesktopHost ? 1 : Math.max(1, Math.min(2, Math.round((window.devicePixelRatio || 1) * 100) / 100));
  const getViewportSize = () => {
    const root = document.getElementById("game-root");
    const rootW = root && root.clientWidth ? root.clientWidth : 0;
    const rootH = root && root.clientHeight ? root.clientHeight : 0;
    const docW = document.documentElement && document.documentElement.clientWidth ? document.documentElement.clientWidth : 0;
    const docH = document.documentElement && document.documentElement.clientHeight ? document.documentElement.clientHeight : 0;
    const w = Math.max(rootW, docW, 640);
    const h = Math.max(rootH, docH, 360);
    return { w, h };
  };
  const initial = getViewportSize();
  Platformer.Debug.init();
  if (Platformer.BUILD_VERSION) {
    Platformer.Debug.log("Build", `version=${Platformer.BUILD_VERSION} time=${Platformer.BUILD_TIME_UTC || "n/a"}`);
  }
  if (isFileProtocol && !isDesktopHost) Platformer.Debug.log("Runtime", "file:// mode detected.");
  if (isDesktopHost) Platformer.Debug.log("Runtime", "Desktop host mode detected.");

  const SafeBootScene = Platformer.wrapSceneSafety(Platformer.BootScene, "BootScene");
  const SafeMenuScene = Platformer.wrapSceneSafety(Platformer.MenuScene, "MenuScene");
  const SafeWorldMapScene = Platformer.wrapSceneSafety(Platformer.WorldMapScene, "WorldMapScene");
  const SafeExtrasScene = Platformer.wrapSceneSafety(Platformer.ExtrasScene, "ExtrasScene");
  const SafeIntroScene = Platformer.wrapSceneSafety(Platformer.IntroScene, "IntroScene");
  const SafeOptionsScene = Platformer.wrapSceneSafety(Platformer.OptionsScene, "OptionsScene");
  const SafeGameScene = Platformer.wrapSceneSafety(Platformer.GameScene, "GameScene");
  const SafeUIScene = Platformer.wrapSceneSafety(Platformer.UIScene, "UIScene");

  const config = {
    type: Phaser.AUTO,
    width: initial.w,
    height: initial.h,
    parent: "game-root",
    pixelArt: settings.video.pixelPerfect,
    resolution: dpr,
    scale: {
      mode: Phaser.Scale.RESIZE,
      width: initial.w,
      height: initial.h,
      zoom: 1,
    },
    backgroundColor: "#7dd3fc",
    autoRound: true,
    render: {
      antialias: false,
      antialiasGL: false,
      pixelArt: true,
      roundPixels: true,
      powerPreference: "high-performance",
    },
    physics: {
      default: "arcade",
      arcade: {
        gravity: { y: PLAYER.gravity },
        debug: false,
      },
    },
    fps: {
      target: fpsTarget || 60,
      forceSetTimeOut: !settings.video.vsync,
    },
    dom: {
      createContainer: true,
    },
    scene: [
      SafeBootScene,
      SafeMenuScene,
      SafeWorldMapScene,
      SafeExtrasScene,
      SafeIntroScene,
      SafeOptionsScene,
      SafeGameScene,
      SafeUIScene,
    ],
  };

  const game = new Phaser.Game(config);
  window.AnimePlatformerGame = {
    play() { if (game && game.scene) game.scene.resume("GameScene"); },
    pause() { if (game && game.scene) game.scene.pause("GameScene"); },
    settings() { return Platformer.Settings.current; },
  };
  Platformer.Debug.attachGameMonitors(game);
  let lastW = initial.w;
  let lastH = initial.h;

  const forceActiveSceneRelayout = (w, h) => {
    if (!(game && game.scene && game.scene.getScenes)) return;
    const activeScenes = game.scene.getScenes(true);
    activeScenes.forEach((scene) => {
      if (!scene || !scene.sys || !scene.sys.settings || !scene.sys.settings.active) return;
      try {
        if (typeof scene.handleResize === "function") scene.handleResize(w, h);
        else if (typeof scene.layoutMenu === "function") scene.layoutMenu();
        else if (typeof scene.layoutOptions === "function") scene.layoutOptions();
        if (scene.ui && typeof scene.ui.resize === "function") scene.ui.resize();
      } catch (e) {
        if (Platformer.Debug && Platformer.Debug.warn) {
          Platformer.Debug.warn("ResizeSync", `Scene relayout failed (${scene.scene ? scene.scene.key : "unknown"}): ${e && e.message ? e.message : e}`);
        }
      }
    });
  };

  const applySize = (wRaw, hRaw, source = "window") => {
    const vp = getViewportSize();
    const w = Math.max(640, Number(wRaw) || vp.w);
    const h = Math.max(360, Number(hRaw) || vp.h);
    if (w === lastW && h === lastH) return;
    lastW = w;
    lastH = h;
    Platformer.Debug.log("ResizeSync", `${source} -> ${w}x${h}`);

    if (game && game.scale) {
      game.scale.resize(w, h);
      if (typeof game.scale.refresh === "function") {
        game.scale.refresh();
      }
      if (game.input && game.input.manager && typeof game.input.manager.resize === "function") {
        game.input.manager.resize(w, h);
      }
      forceActiveSceneRelayout(w, h);
    }
  };
  const syncGameSize = () => {
    const vp = getViewportSize();
    applySize(vp.w, vp.h, "viewport");
  };

  window.addEventListener("resize", syncGameSize);
  window.addEventListener("orientationchange", syncGameSize);
  window.addEventListener("online", () => {
    const scene = game && game.scene ? game.scene.getScene("MenuScene") : null;
    if (scene && typeof scene.autoCheckUpdatesForBottomLeft === "function") {
      scene.autoCheckUpdatesForBottomLeft();
    }
  });
  // Keep a lightweight heartbeat for wrappers that occasionally miss resize events.
  setInterval(syncGameSize, 1200);
  // Startup relayout pulses for desktop wrappers where initial viewport can be stale until first input.
  setTimeout(syncGameSize, 60);
  setTimeout(syncGameSize, 180);
  setTimeout(syncGameSize, 420);
  setTimeout(syncGameSize, 900);

  const startupDisplayMode = settings.video.displayMode || (settings.video.fullscreen ? "fullscreen" : "windowed");
  // Desktop wrapper controls fullscreen natively; avoid browser fullscreen API there.
  if (!isDesktopHost && startupDisplayMode === "fullscreen") {
    game.events.once("ready", () => {
      if (!game.scale.isFullscreen) {
        game.scale.startFullscreen();
      }
    });
  } else if (isDesktopHost && startupDisplayMode === "fullscreen" && Platformer.Debug) {
    Platformer.Debug.log("StartupDisplay", "Desktop host fullscreen handled natively.");
  }
})();


  /* <<< main.js */

})(window);
//# sourceMappingURL=app.bundle.js.map
