(function (global) {
  // Auto-generated bundle. Do not edit directly.
  var Platformer = global.AnimePlatformer || (global.AnimePlatformer = {});

  /* >>> core/constants.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.Config = {
  GAME_WIDTH: 960,
  GAME_HEIGHT: 540,
  TILE: 32,
  WIN_COIN_TARGET: 10,
  PLAYER: {
    maxSpeed: 220,
    acceleration: 950,
    drag: 1300,
    jumpVelocity: 420,
    maxJumps: 2,
    gravity: 1100,
    coyoteTimeMs: 110,
    jumpBufferMs: 130,
    hurtInvulnMs: 900,
    dashSpeed: 460,
    dashDurationMs: 140,
    dashCooldownMs: 900,
    attackRange: 44,
    attackCooldownMs: 320,
  },
};
  /* <<< core/constants.js */

  /* >>> core/build-info.js */
// [bundle] namespace init removed; using local Platformer namespace.

// Auto-generated by scripts/write_build_info.py during packaging.
Platformer.BUILD_VERSION = "2026.02.15.1537";
Platformer.BUILD_TIME_UTC = "2026-02-15T15:37:54.095410Z";
Platformer.BUILD_UPDATE_REPO = "zyynx-hub/Platformer";
Platformer.BUILD_UPDATE_CHANNEL = "stable";
Platformer.BUILD_UPDATE_ENABLED = true;
Platformer.BUILD_DEBUG = false;
  /* <<< core/build-info.js */

  /* >>> core/settings.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.DEFAULT_SETTINGS = {
  settingsVersion: 2,
  gameplay: {
    difficulty: "normal",
  },
  controls: {
    left: "A",
    right: "D",
    jump: "W",
    dash: "SHIFT",
    attack: "J",
    interact: "E",
    pause: "ESC",
  },
  accessibility: {
    textSize: "medium",
    colorblindMode: "off",
    reduceScreenShake: 50,
    reducedMotion: false,
    flashReduction: false,
    subtitles: true,
    audioCues: true,
  },
  video: {
    fullscreen: false,
    resolutionScale: 100,
    pixelPerfect: true,
    vsync: true,
    fpsCap: "60",
    cameraSmoothing: 35,
    brightness: 1.0,
  },
  audio: {
    master: 80,
    music: 60,
    sfx: 85,
    ui: 70,
    dynamicRange: "normal",
    muteWhenUnfocused: false,
  },
  convenience: {
    autoSave: true,
    checkpointFrequency: "standard",
    speedrunMode: false,
    introSeen: false,
  },
  updates: {
    enabled: true,
    autoUpdate: true,
    currentVersion: "1.0.0",
    source: "GitHub Releases",
    manifestUrl: "",
    downloadUrl: "",
  },
};

Platformer.deepClone = function deepClone(obj) {
  return JSON.parse(JSON.stringify(obj));
};

Platformer.deepMerge = function deepMerge(base, incoming) {
  const out = Platformer.deepClone(base);
  const mergeInto = (target, source) => {
    if (!source || typeof source !== "object") return;
    Object.keys(source).forEach((key) => {
      const src = source[key];
      if (src && typeof src === "object" && !Array.isArray(src)) {
        if (!target[key] || typeof target[key] !== "object") {
          target[key] = {};
        }
        mergeInto(target[key], src);
      } else {
        target[key] = src;
      }
    });
  };
  mergeInto(out, incoming);
  return out;
};

Platformer.Settings = {
  key: "anime_platformer_settings_v2",
  legacyKeys: ["anime_platformer_settings_v1"],
  prefix: "anime_platformer_settings_",
  current: Platformer.deepClone(Platformer.DEFAULT_SETTINGS),
  _bootstrapped: false,

  waitForBridgeReady(timeoutMs = 2500) {
    return new Promise((resolve) => {
      const isReady = () => !!(window.pywebview && window.pywebview.api);
      if (isReady()) {
        resolve(true);
        return;
      }
      let done = false;
      const finish = (ok) => {
        if (done) return;
        done = true;
        try { window.removeEventListener("pywebviewready", onReady); } catch (_e) {}
        clearInterval(timer);
        clearTimeout(expire);
        resolve(ok);
      };
      const onReady = () => finish(true);
      try { window.addEventListener("pywebviewready", onReady, { once: true }); } catch (_e) {}
      const timer = setInterval(() => {
        if (isReady()) finish(true);
      }, 100);
      const expire = setTimeout(() => finish(isReady()), Math.max(200, Number(timeoutMs) || 2500));
    });
  },

  migrate(parsed) {
    const input = parsed && typeof parsed === "object" ? Platformer.deepClone(parsed) : {};
    const ver = Number(input.settingsVersion || 1);
    const out = input;

    if (ver < 2) {
      // v2: deprecate player-editable update URLs and lock source label.
      if (!out.updates || typeof out.updates !== "object") out.updates = {};
      out.updates.source = "GitHub Releases";
      out.updates.manifestUrl = "";
      out.updates.downloadUrl = "";
      out.settingsVersion = 2;
    }
    out.settingsVersion = 2;
    return out;
  },

  archiveLegacySnapshot(raw) {
    if (!raw || !window.indexedDB) return;
    try {
      const req = window.indexedDB.open("anime_platformer_archive", 1);
      req.onupgradeneeded = (e) => {
        const db = e.target.result;
        if (!db.objectStoreNames.contains("settings")) {
          db.createObjectStore("settings", { keyPath: "id", autoIncrement: true });
        }
      };
      req.onsuccess = () => {
        try {
          const db = req.result;
          const tx = db.transaction("settings", "readwrite");
          tx.objectStore("settings").add({ at: Date.now(), payload: String(raw).slice(0, 2048) });
          tx.oncomplete = () => db.close();
          tx.onerror = () => db.close();
        } catch (_e) {
          // best effort
        }
      };
    } catch (_e) {
      // best effort
    }
  },

  cleanupObsoleteStorage() {
    try {
      const keep = new Set([this.key, ...this.legacyKeys]);
      Object.keys(localStorage).forEach((k) => {
        if (k && k.startsWith(this.prefix) && !keep.has(k)) {
          localStorage.removeItem(k);
        }
      });
    } catch (_e) {
      // ignore
    }
  },

  load() {
    try {
      const buildVersion = (Platformer.BUILD_VERSION && String(Platformer.BUILD_VERSION).trim()) || "1.0.0";
      const buildUpdateEnabled = Platformer.BUILD_UPDATE_ENABLED !== false;
      let raw = localStorage.getItem(this.key);
      if (!raw) {
        for (const legacy of this.legacyKeys) {
          raw = localStorage.getItem(legacy);
          if (raw) break;
        }
      }
      if (!raw) {
        this.current = Platformer.deepClone(Platformer.DEFAULT_SETTINGS);
        this.current.updates.currentVersion = buildVersion;
        this.current.updates.enabled = buildUpdateEnabled;
        this.current.updates.source = "GitHub Releases";
        return this.current;
      }
      this.archiveLegacySnapshot(raw);
      const parsed = this.migrate(JSON.parse(raw));
      this.current = Platformer.deepMerge(Platformer.DEFAULT_SETTINGS, parsed);
      // Session-only flag: always reset on full page refresh.
      this.current.convenience.introSeen = false;
      // Always bind current version to packaged build, not stale localStorage.
      this.current.updates.currentVersion = buildVersion;
      // Build config is authoritative for whether updates are enabled.
      this.current.updates.enabled = buildUpdateEnabled;
      this.current.updates.source = "GitHub Releases";
      this.cleanupObsoleteStorage();
      this.persistLocal();
      return this.current;
    } catch (_e) {
      const buildVersion = (Platformer.BUILD_VERSION && String(Platformer.BUILD_VERSION).trim()) || "1.0.0";
      const buildUpdateEnabled = Platformer.BUILD_UPDATE_ENABLED !== false;
      this.current = Platformer.deepClone(Platformer.DEFAULT_SETTINGS);
      this.current.convenience.introSeen = false;
      this.current.updates.currentVersion = buildVersion;
      this.current.updates.enabled = buildUpdateEnabled;
      this.current.updates.source = "GitHub Releases";
      return this.current;
    }
  },

  persistLocal() {
    // Do not persist introSeen; keep it session-only.
    const toSave = Platformer.deepClone(this.current);
    toSave.convenience.introSeen = false;
    toSave.updates.currentVersion = (Platformer.BUILD_VERSION && String(Platformer.BUILD_VERSION).trim()) || "1.0.0";
    toSave.updates.source = "GitHub Releases";
    // Legacy player-editable URLs are intentionally not persisted anymore.
    toSave.updates.manifestUrl = "";
    toSave.updates.downloadUrl = "";
    this.current.updates.currentVersion = toSave.updates.currentVersion;
    this.current.updates.source = toSave.updates.source;
    this.current.updates.manifestUrl = "";
    this.current.updates.downloadUrl = "";
    const compact = JSON.stringify(toSave);
    localStorage.setItem(this.key, compact);
    this.legacyKeys.forEach((k) => localStorage.removeItem(k));
    this.cleanupObsoleteStorage();
  },

  async save() {
    this.persistLocal();
    await this.persistHost();
  },

  async persistHost() {
    try {
      await this.waitForBridgeReady(2000);
      if (!(window.pywebview && window.pywebview.api && typeof window.pywebview.api.write_settings_blob === "function")) {
        return;
      }
      const payload = JSON.stringify(this.current);
      const res = await window.pywebview.api.write_settings_blob(payload);
      if (Platformer.Debug && (!res || !res.ok)) {
        Platformer.Debug.warn("Settings.host", (res && res.message) || "Failed writing host settings.");
      }
    } catch (e) {
      if (Platformer.Debug) Platformer.Debug.warn("Settings.host", `write failed: ${e && e.message ? e.message : e}`);
    }
  },

  async bootstrap() {
    this.load();
    if (this._bootstrapped) return this.current;
    this._bootstrapped = true;
    try {
      await this.waitForBridgeReady(3000);
      if (!(window.pywebview && window.pywebview.api && typeof window.pywebview.api.read_settings_blob === "function")) {
        return this.current;
      }
      const res = await window.pywebview.api.read_settings_blob();
      if (!res || !res.ok || !res.data) return this.current;
      const parsed = this.migrate(JSON.parse(String(res.data)));
      this.current = Platformer.deepMerge(Platformer.DEFAULT_SETTINGS, parsed);
      this.current.convenience.introSeen = false;
      this.current.updates.currentVersion = (Platformer.BUILD_VERSION && String(Platformer.BUILD_VERSION).trim()) || "1.0.0";
      this.current.updates.enabled = Platformer.BUILD_UPDATE_ENABLED !== false;
      this.current.updates.source = "GitHub Releases";
      this.persistLocal();
      if (Platformer.Debug) Platformer.Debug.log("Settings.host", "Loaded persisted settings from desktop host.");
    } catch (e) {
      if (Platformer.Debug) Platformer.Debug.warn("Settings.host", `bootstrap failed: ${e && e.message ? e.message : e}`);
    }
    return this.current;
  },

  reset() {
    this.current = Platformer.deepClone(Platformer.DEFAULT_SETTINGS);
    this.current.convenience.introSeen = false;
    this.current.updates.currentVersion = (Platformer.BUILD_VERSION && String(Platformer.BUILD_VERSION).trim()) || "1.0.0";
    this.current.updates.enabled = Platformer.BUILD_UPDATE_ENABLED !== false;
    this.current.updates.source = "GitHub Releases";
    this.current.updates.manifestUrl = "";
    this.current.updates.downloadUrl = "";
    this.save();
    return this.current;
  },

  textScale() {
    const size = this.current.accessibility.textSize;
    if (size === "small") return 0.9;
    if (size === "large") return 1.2;
    return 1;
  },
};

Platformer.Settings.load();
  /* <<< core/settings.js */

  /* >>> core/debug.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.Debug = {
  initialized: false,
  enabled: false,
  lines: [],
  maxLines: 300,
  panel: null,
  logEl: null,
  statusEl: null,
  copyBtn: null,
  latestErrorBlock: "",
  _monitorsAttached: false,
  _nativeLogInFlight: 0,
  _nativeLogDropped: 0,
  _lastMismatchKey: "",
  _lastMismatchAt: 0,

  init() {
    if (this.initialized) return;
    this.initialized = true;
    const desktopHost = !!(window.pywebview && window.pywebview.api);
    this.enabled = !!(window.DEBUG_MODE || Platformer.BUILD_DEBUG || desktopHost);
    if (!this.enabled) return;

    const root = document.createElement("div");
    root.style.position = "fixed";
    root.style.right = "12px";
    root.style.bottom = "12px";
    root.style.zIndex = "999999";
    root.style.fontFamily = "Consolas, monospace";

    const toggle = document.createElement("button");
    toggle.textContent = "DEBUG";
    toggle.style.padding = "8px 10px";
    toggle.style.background = "#111827";
    toggle.style.color = "#e5e7eb";
    toggle.style.border = "1px solid #374151";
    toggle.style.cursor = "pointer";
    toggle.style.borderRadius = "6px";

    const panel = document.createElement("div");
    panel.style.display = "none";
    panel.style.marginTop = "8px";
    panel.style.width = "min(920px, 92vw)";
    panel.style.height = "min(46vh, 420px)";
    panel.style.background = "rgba(0,0,0,0.92)";
    panel.style.color = "#86efac";
    panel.style.border = "1px solid #374151";
    panel.style.borderRadius = "8px";
    panel.style.padding = "10px";
    panel.style.boxSizing = "border-box";
    panel.style.display = "none";

    const topBar = document.createElement("div");
    topBar.style.display = "flex";
    topBar.style.justifyContent = "space-between";
    topBar.style.alignItems = "center";
    topBar.style.marginBottom = "8px";

    const title = document.createElement("div");
    title.textContent = "Runtime Debug Console";
    title.style.color = "#f9fafb";

    const right = document.createElement("div");
    right.style.display = "flex";
    right.style.gap = "8px";

    const copyBtn = document.createElement("button");
    copyBtn.textContent = "Copy latest error";
    copyBtn.style.padding = "6px 8px";
    copyBtn.style.background = "#1f2937";
    copyBtn.style.color = "#f9fafb";
    copyBtn.style.border = "1px solid #4b5563";
    copyBtn.style.cursor = "pointer";

    const clearBtn = document.createElement("button");
    clearBtn.textContent = "Clear";
    clearBtn.style.padding = "6px 8px";
    clearBtn.style.background = "#1f2937";
    clearBtn.style.color = "#f9fafb";
    clearBtn.style.border = "1px solid #4b5563";
    clearBtn.style.cursor = "pointer";

    right.appendChild(copyBtn);
    right.appendChild(clearBtn);

    topBar.appendChild(title);
    topBar.appendChild(right);

    const status = document.createElement("div");
    status.style.marginBottom = "6px";
    status.style.color = "#93c5fd";
    status.textContent = "No errors yet.";

    const log = document.createElement("pre");
    log.style.margin = "0";
    log.style.height = "calc(100% - 58px)";
    log.style.overflow = "auto";
    log.style.whiteSpace = "pre-wrap";
    log.style.fontSize = "12px";
    log.style.lineHeight = "1.32";
    log.textContent = "Debug console ready.\n";

    panel.appendChild(topBar);
    panel.appendChild(status);
    panel.appendChild(log);
    root.appendChild(toggle);
    root.appendChild(panel);
    document.body.appendChild(root);

    toggle.addEventListener("click", () => {
      panel.style.display = panel.style.display === "none" ? "block" : "none";
    });
    window.addEventListener("keydown", (e) => {
      if (e.key === "F1") {
        e.preventDefault();
        panel.style.display = panel.style.display === "none" ? "block" : "none";
      }
    });

    clearBtn.addEventListener("click", () => {
      this.lines = [];
      log.textContent = "";
      status.textContent = "Cleared.";
    });

    copyBtn.addEventListener("click", async () => {
      const text = this.latestErrorBlock || "No captured error block yet.";
      try {
        await navigator.clipboard.writeText(text);
        status.textContent = "Latest error copied to clipboard.";
      } catch (_e) {
        status.textContent = "Copy failed. Select text manually from logs.";
      }
    });

    this.panel = panel;
    this.logEl = log;
    this.statusEl = status;
    this.copyBtn = copyBtn;

    window.addEventListener("error", (event) => {
      // Resource load failures (scripts, audio, images) come through error events too.
      if (event && event.target && event.target !== window) {
        const t = event.target;
        const tag = t.tagName || "UNKNOWN";
        const src = t.src || t.href || "(no src/href)";
        this.error("resource.error", `TAG: ${tag}\nSOURCE: ${src}`);
        return;
      }

      const msg = event.message || "Unknown window error";
      const file = event.filename || "(no filename)";
      const line = event.lineno || 0;
      const col = event.colno || 0;
      const stack = event.error && event.error.stack ? event.error.stack : "(no stack)";
      this.error("window.onerror", `MESSAGE: ${msg}\nFILE: ${file}:${line}:${col}\n${stack}`);
    }, true);

    window.addEventListener("unhandledrejection", (event) => {
      const reason = event.reason;
      const msg = reason && reason.message ? reason.message : String(reason);
      const stack = reason && reason.stack ? reason.stack : "(no stack)";
      this.error("unhandledrejection", `${msg}\n${stack}`);
    });

    this.patchConsole();
  },

  patchConsole() {
    if (console.__platformerDebugPatched) return;
    console.__platformerDebugPatched = true;

    const origLog = console.log.bind(console);
    const origWarn = console.warn.bind(console);
    const origErr = console.error.bind(console);

    console.log = (...args) => {
      this.log("console.log", this.stringifyArgs(args));
      origLog(...args);
    };
    console.warn = (...args) => {
      this.warn("console.warn", this.stringifyArgs(args));
      origWarn(...args);
    };
    console.error = (...args) => {
      this.error("console.error", this.stringifyArgs(args));
      origErr(...args);
    };
  },

  stringifyArgs(args) {
    return args.map((a) => {
      if (typeof a === "string") return a;
      try {
        return JSON.stringify(a);
      } catch (_e) {
        return String(a);
      }
    }).join(" ");
  },

  timestamp() {
    return new Date().toISOString().slice(11, 19);
  },

  append(type, label, message) {
    if (!this.enabled) return;
    const line = `[${this.timestamp()}] [${type}] ${label}: ${message}`;
    this.lines.push(line);
    if (this.lines.length > this.maxLines) {
      this.lines.shift();
    }
    if (this.logEl) {
      this.logEl.textContent = this.lines.join("\n");
      this.logEl.scrollTop = this.logEl.scrollHeight;
    }
    this.forwardToNativeConsole(type, label, message);
  },

  forwardToNativeConsole(type, label, message) {
    try {
      if (!(window.pywebview && window.pywebview.api && typeof window.pywebview.api.log_event === "function")) {
        return;
      }
      // Avoid flooding host bridge on high-frequency logs.
      if (this._nativeLogInFlight > 10) {
        this._nativeLogDropped += 1;
        if (this._nativeLogDropped % 25 === 0) {
          window.pywebview.api.log_event("WARN", "DebugBridge", `Dropped ${this._nativeLogDropped} log lines (bridge saturated)`).catch(() => {});
        }
        return;
      }
      this._nativeLogInFlight += 1;
      window.pywebview.api.log_event(type, label, String(message)).catch(() => {})
        .finally(() => {
          this._nativeLogInFlight = Math.max(0, this._nativeLogInFlight - 1);
        });
    } catch (_e) {
      // best effort
    }
  },

  log(label, message) {
    this.append("INFO", label, message);
  },

  warn(label, message) {
    this.append("WARN", label, message);
  },

  error(label, message) {
    this.append("ERROR", label, message);
    this.latestErrorBlock = [
      "=== COPY_THIS_TO_ASSISTANT ===",
      `TIME: ${new Date().toISOString()}`,
      `SOURCE: ${label}`,
      "DETAILS:",
      message,
      "=== END_COPY ===",
    ].join("\n");
    if (this.statusEl) {
      this.statusEl.textContent = "Error captured. Click 'Copy latest error'.";
      this.statusEl.style.color = "#fca5a5";
    }
  },

  attachGameMonitors(game) {
    if (!this.enabled) return;
    if (this._monitorsAttached || !game) return;
    this._monitorsAttached = true;

    try {
      const sm = game.scene && game.scene.events ? game.scene.events : null;
      if (sm) {
        const sceneEvent = (name) => (scene) => {
          const key = scene && scene.scene && scene.scene.key ? scene.scene.key : "unknown";
          this.log("Scene", `${name}: ${key}`);
        };
        sm.on("start", sceneEvent("start"));
        sm.on("ready", sceneEvent("ready"));
        sm.on("pause", sceneEvent("pause"));
        sm.on("resume", sceneEvent("resume"));
        sm.on("sleep", sceneEvent("sleep"));
        sm.on("wake", sceneEvent("wake"));
        sm.on("shutdown", sceneEvent("shutdown"));
        sm.on("destroy", sceneEvent("destroy"));
      }
    } catch (e) {
      this.warn("Debug.attachGameMonitors", `Scene monitor attach failed: ${e && e.message ? e.message : e}`);
    }

    try {
      if (game.scale && game.scale.on) {
        game.scale.on("resize", (sz) => {
          this.log("Scale.resize", `${Math.round(sz.width)}x${Math.round(sz.height)}`);
        });
      }
    } catch (e) {
      this.warn("Debug.attachGameMonitors", `Scale monitor attach failed: ${e && e.message ? e.message : e}`);
    }

    try {
      document.addEventListener("visibilitychange", () => {
        this.log("Visibility", document.hidden ? "hidden" : "visible");
      });
    } catch (_e) {
      // best effort
    }

    // Detect black bars / stale canvas sizing (common in desktop wrappers).
    setInterval(() => {
      try {
        if (!game.canvas) return;
        const root = document.getElementById("game-root");
        const vw = (root && root.clientWidth) || (document.documentElement && document.documentElement.clientWidth) || window.innerWidth || 0;
        const vh = (root && root.clientHeight) || (document.documentElement && document.documentElement.clientHeight) || window.innerHeight || 0;
        const cw = game.canvas.clientWidth || game.canvas.width || 0;
        const ch = game.canvas.clientHeight || game.canvas.height || 0;
        const dx = Math.abs(cw - vw);
        const dy = Math.abs(ch - vh);
        if (dx > 8 || dy > 8) {
          const now = Date.now();
          const key = `${vw}x${vh}|${cw}x${ch}`;
          if (key !== this._lastMismatchKey || now - this._lastMismatchAt > 5000) {
            this._lastMismatchKey = key;
            this._lastMismatchAt = now;
            this.warn("ViewportMismatch", `viewport=${vw}x${vh} canvas=${cw}x${ch} (dx=${dx},dy=${dy})`);
          }
        }
      } catch (_e) {
        // best effort
      }
    }, 1200);
  },

  safe(label, fn, ctx, args) {
    if (!this.enabled) {
      return fn.apply(ctx, args || []);
    }
    try {
      return fn.apply(ctx, args || []);
    } catch (err) {
      const stack = err && err.stack ? err.stack : String(err);
      this.error(label, stack);
      return undefined;
    }
  },
};

Platformer.wrapSceneSafety = function wrapSceneSafety(SceneClass, sceneName) {
  if (!SceneClass || SceneClass.__safeWrapped) return SceneClass;

  class SafeScene extends SceneClass {
    preload(...args) {
      const fn = SceneClass.prototype.preload;
      if (typeof fn !== "function") return undefined;
      return Platformer.Debug.safe(`${sceneName}.preload`, fn, this, args);
    }

    init(...args) {
      const fn = SceneClass.prototype.init;
      if (typeof fn !== "function") return undefined;
      return Platformer.Debug.safe(`${sceneName}.init`, fn, this, args);
    }

    create(...args) {
      const fn = SceneClass.prototype.create;
      if (typeof fn !== "function") return undefined;
      return Platformer.Debug.safe(`${sceneName}.create`, fn, this, args);
    }

    update(...args) {
      const fn = SceneClass.prototype.update;
      if (typeof fn !== "function") return undefined;
      return Platformer.Debug.safe(`${sceneName}.update`, fn, this, args);
    }

    shutdown(...args) {
      const fn = SceneClass.prototype.shutdown;
      if (typeof fn !== "function") return undefined;
      return Platformer.Debug.safe(`${sceneName}.shutdown`, fn, this, args);
    }
  }

  SafeScene.__safeWrapped = true;
  return SafeScene;
};
  /* <<< core/debug.js */

  /* >>> core/updater.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.Updater = {
  resolveSource() {
    const cfg = Platformer.Settings.current.updates || {};
    const defaultRepo = "zyynx-hub/Platformer";
    const buildRepo = String(Platformer.BUILD_UPDATE_REPO || "").trim().replace(/^\/+|\/+$/g, "");
    const buildChannel = String(Platformer.BUILD_UPDATE_CHANNEL || "stable").trim() || "stable";
    const buildEnabled = Platformer.BUILD_UPDATE_ENABLED !== false;
    const repo = buildRepo || defaultRepo;
    return {
      enabled: buildEnabled && cfg.enabled !== false,
      kind: "github",
      repo,
      channel: buildChannel,
      currentVersion: cfg.currentVersion || "0.0.0",
      fallbackDownloadUrl: cfg.downloadUrl || "",
    };
  },

  friendlyError(message) {
    const raw = String(message || "").toLowerCase();
    if (!raw) return "Update check failed.";
    if (raw.includes("no public release")) {
      return "No public release found yet.";
    }
    if (raw.includes("winerror 87") || raw.includes("parameter is incorrect")) {
      return "Network/proxy config issue. Retry or disable proxy/VPN.";
    }
    if (raw.includes("timed out") || raw.includes("network") || raw.includes("offline") || raw.includes("failed to fetch")) {
      return "Offline, retrying later.";
    }
    if (raw.includes("rate limit") || raw.includes("403")) {
      return "Update server busy, try later.";
    }
    if (raw.includes("404")) {
      return "No public release found yet.";
    }
    return "Can't reach update server.";
  },

  wait(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  },

  compareVersions(a, b) {
    const norm = (v) => String(v || "0")
      .split(".")
      .map((p) => parseInt(p, 10))
      .map((n) => (Number.isFinite(n) ? n : 0));

    const aa = norm(a);
    const bb = norm(b);
    const len = Math.max(aa.length, bb.length);
    for (let i = 0; i < len; i += 1) {
      const av = aa[i] || 0;
      const bv = bb[i] || 0;
      if (av > bv) return 1;
      if (av < bv) return -1;
    }
    return 0;
  },

  async check() {
    const source = this.resolveSource();
    if (!source.enabled) {
      return { ok: true, enabled: false, message: "Auto updates are off." };
    }

    if (source.kind === "github" && window.pywebview && window.pywebview.api) {
      if (typeof window.pywebview.api.check_update_github !== "function") {
        return { ok: false, enabled: true, transient: true, message: "Update bridge not ready yet." };
      }
      try {
        const res = await window.pywebview.api.check_update_github(
          source.repo,
          source.currentVersion,
          source.channel,
        );
        if (res && res.ok) {
          return {
            ok: true,
            enabled: true,
            hasUpdate: !!res.hasUpdate,
            latestVersion: res.latestVersion || source.currentVersion,
            downloadUrl: res.downloadUrl || source.fallbackDownloadUrl || "",
            checksumSha256: res.checksumSha256 || "",
            releaseNotes: res.releaseNotes || "",
            releasePublishedAt: res.releasePublishedAt || "",
            message: res.message || (res.hasUpdate ? "Update found." : "You're up to date."),
          };
        }
        return {
          ok: false,
          enabled: true,
          message: this.friendlyError((res && res.message) || "Can't reach update server."),
        };
      } catch (e) {
        return { ok: false, enabled: true, message: this.friendlyError(e && e.message ? e.message : e) };
      }
    }

    return { ok: false, enabled: true, message: "Update service not ready in this runtime." };
  },

  openDownload(url) {
    if (!url) return false;
    if (window.pywebview && window.pywebview.api && typeof window.pywebview.api.open_url === "function") {
      window.pywebview.api.open_url(url);
      return true;
    }
    try {
      window.open(url, "_blank", "noopener,noreferrer");
      return true;
    } catch (_e) {
      return false;
    }
  },

  canInAppApply() {
    return !!(
      window.pywebview
      && window.pywebview.api
      && typeof window.pywebview.api.start_update_download === "function"
      && typeof window.pywebview.api.get_update_progress === "function"
      && typeof window.pywebview.api.apply_downloaded_update === "function"
    );
  },

  async updateAndRestart(downloadUrl, onProgress) {
    if (!this.canInAppApply()) {
      return { ok: false, message: "In-app updater API unavailable." };
    }
    if (!downloadUrl) {
      return { ok: false, message: "Update package URL missing." };
    }

    const sendProgress = (payload) => {
      if (typeof onProgress === "function") onProgress(payload);
    };

    try {
      if (Platformer.Debug) Platformer.Debug.log("Updater", `Starting in-app update: ${downloadUrl}`);
      const start = await window.pywebview.api.start_update_download(
        downloadUrl,
        Platformer.Updater.latestChecksumSha256 || "",
      );
      if (!start || !start.ok) {
        const msg = (start && start.message) || "Failed to start update download.";
        if (Platformer.Debug) Platformer.Debug.error("Updater", msg);
        return { ok: false, message: msg };
      }

      sendProgress({ stage: "downloading", progress: 0, message: "Downloading update..." });

      for (let i = 0; i < 1200; i += 1) {
        const status = await window.pywebview.api.get_update_progress();
        if (!status || !status.ok) {
          const msg = (status && status.message) || "Failed to read update progress.";
          if (Platformer.Debug) Platformer.Debug.error("Updater", msg);
          return { ok: false, message: msg };
        }

        sendProgress(status);

        if (status.stage === "error") {
          const msg = status.message || "Update download failed.";
          if (Platformer.Debug) Platformer.Debug.error("Updater", msg);
          return { ok: false, message: msg };
        }
        if (status.stage === "downloaded") {
          break;
        }
        await this.wait(250);
      }

      sendProgress({ stage: "applying", progress: 100, message: "Restarting to finish update..." });
      if (Platformer.Debug) Platformer.Debug.log("Updater", "Download complete. Applying update.");
      const applied = await window.pywebview.api.apply_downloaded_update();
      if (!applied || !applied.ok) {
        const msg = (applied && applied.message) || "Failed to apply update.";
        if (Platformer.Debug) Platformer.Debug.error("Updater", msg);
        return { ok: false, message: msg };
      }

      if (Platformer.Debug) Platformer.Debug.log("Updater", "Updater helper launched; app is restarting.");
      return { ok: true, message: applied.message || "Restarting to finish update..." };
    } catch (e) {
      const msg = `Update flow failed: ${e && e.message ? e.message : e}`;
      if (Platformer.Debug) Platformer.Debug.error("Updater", msg);
      return { ok: false, message: msg };
    }
  },
};
  /* <<< core/updater.js */

  /* >>> systems/beeper.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.Beeper = class {
  constructor() {
    this.ctx = null;
    this.enabled = true;
  }

  unlock() {
    if (!this.enabled) return;
    if (!this.ctx) {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) {
        this.enabled = false;
        return;
      }
      this.ctx = new AudioCtx();
    }
    if (this.ctx.state === "suspended") {
      this.ctx.resume();
    }
  }

  tone(freq, duration, type = "square", gainValue = 0.05) {
    if (!this.ctx || !this.enabled) return;
    const settings = Platformer.Settings ? Platformer.Settings.current : null;
    if (settings && !settings.accessibility.audioCues) return;

    let mix = 1;
    if (settings) {
      mix = (settings.audio.master / 100) * (settings.audio.sfx / 100);
      if (settings.audio.muteWhenUnfocused && document.hidden) {
        mix = 0;
      }
    }
    if (mix <= 0) return;

    const now = this.ctx.currentTime;
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    osc.type = type;
    osc.frequency.setValueAtTime(freq, now);
    gain.gain.setValueAtTime(gainValue * mix, now);
    gain.gain.exponentialRampToValueAtTime(0.0001, now + duration);
    osc.connect(gain);
    gain.connect(this.ctx.destination);
    osc.start(now);
    osc.stop(now + duration);
  }

  jump() {
    this.tone(420, 0.08, "square", 0.05);
  }

  coin() {
    this.tone(880, 0.06, "triangle", 0.06);
    this.tone(1320, 0.08, "triangle", 0.045);
  }

  damage() {
    this.tone(180, 0.14, "sawtooth", 0.06);
  }

  stomp() {
    this.tone(240, 0.09, "square", 0.055);
  }

  dash() {
    this.tone(520, 0.05, "triangle", 0.05);
    this.tone(340, 0.06, "square", 0.035);
  }

  attack() {
    this.tone(300, 0.04, "sawtooth", 0.045);
    this.tone(220, 0.05, "square", 0.03);
  }

  land() {
    this.tone(140, 0.05, "square", 0.03);
  }
};

Platformer.beeper = new Platformer.Beeper();
  /* <<< systems/beeper.js */

  /* >>> level/level-1.js */
// [bundle] namespace init removed; using local Platformer namespace.
Platformer.LevelBuilders = Platformer.LevelBuilders || {};

Platformer.LevelBuilders[1] = function buildLevel1(api) {
  const { line, rect, many, manyEnemies } = api;

  // Ground with wide, readable gaps.
  line(12, 15, 17, ".");
  line(34, 37, 17, ".");
  line(58, 61, 17, ".");
  line(78, 81, 17, ".");

  // Broad patrol islands.
  rect(0, 16, 7, 16, "#");
  rect(18, 16, 25, 16, "#");
  rect(40, 16, 47, 16, "#");
  rect(64, 16, 71, 16, "#");
  rect(84, 16, 89, 16, "#");

  // Platforms.
  line(8, 13, 12, "=");
  line(23, 29, 11, "=");
  line(44, 50, 10, "=");
  line(66, 73, 9, "=");

  many([[3, 16]], "S");
  many([[27, 10], [69, 8]], "K");
  many([[10, 11], [24, 10], [28, 10], [45, 9], [49, 9], [67, 8], [72, 8], [86, 15], [88, 15], [20, 15]], "C");
  many([[25, 10], [46, 9], [68, 8], [86, 15]], "^");
  manyEnemies([[20, 16, "E"], [43, 16, "E"], [66, 16, "E"], [86, 16, "E"]]);
};

  /* <<< level/level-1.js */

  /* >>> level/level-2.js */
// [bundle] namespace init removed; using local Platformer namespace.
Platformer.LevelBuilders = Platformer.LevelBuilders || {};

Platformer.LevelBuilders[2] = function buildLevel2(api) {
  const { line, rect, many, manyEnemies } = api;

  // Vertical rooftop style with wide landing zones.
  line(14, 18, 17, ".");
  line(38, 42, 17, ".");
  line(62, 66, 17, ".");

  rect(0, 16, 10, 16, "#");
  rect(22, 16, 30, 16, "#");
  rect(46, 16, 54, 16, "#");
  rect(70, 16, 89, 16, "#");

  rect(14, 14, 18, 14, "#");
  rect(38, 13, 42, 13, "#");
  rect(62, 12, 66, 12, "#");

  line(9, 15, 12, "=");
  line(27, 34, 10, "=");
  line(49, 56, 8, "=");
  line(71, 79, 7, "=");

  many([[4, 16]], "S");
  many([[33, 9], [74, 6]], "K");
  many([[12, 11], [29, 9], [33, 9], [50, 7], [55, 7], [72, 6], [78, 6], [86, 15], [25, 15], [47, 15]], "C");
  many([[31, 9], [53, 7], [75, 6], [85, 15]], "^");
  manyEnemies([[24, 16, "F"], [48, 16, "F"], [72, 16, "F"], [84, 16, "F"]]);
};

  /* <<< level/level-2.js */

  /* >>> level/level-3.js */
// [bundle] namespace init removed; using local Platformer namespace.
Platformer.LevelBuilders = Platformer.LevelBuilders || {};

Platformer.LevelBuilders[3] = function buildLevel3(api) {
  const { line, rect, many, manyEnemies } = api;

  // Dash-pressure lanes, but no trap cracks for enemies.
  line(10, 13, 17, ".");
  line(28, 31, 17, ".");
  line(46, 49, 17, ".");
  line(64, 67, 17, ".");
  line(80, 83, 17, ".");

  rect(0, 16, 6, 16, "#");
  rect(16, 16, 23, 16, "#");
  rect(34, 16, 41, 16, "#");
  rect(52, 16, 59, 16, "#");
  rect(70, 16, 77, 16, "#");
  rect(86, 16, 89, 16, "#");

  line(7, 12, 13, "=");
  line(21, 27, 12, "=");
  line(39, 45, 11, "=");
  line(57, 63, 10, "=");
  line(75, 82, 9, "=");

  many([[2, 16]], "S");
  many([[27, 11], [77, 8]], "K");
  many([[9, 12], [23, 11], [26, 11], [40, 10], [44, 10], [58, 9], [62, 9], [76, 8], [81, 8], [88, 15]], "C");
  many([[24, 11], [42, 10], [60, 9], [78, 8]], "^");
  manyEnemies([[18, 16, "G"], [36, 16, "G"], [54, 16, "G"], [72, 16, "G"]]);
};

  /* <<< level/level-3.js */

  /* >>> level/level-4.js */
// [bundle] namespace init removed; using local Platformer namespace.
Platformer.LevelBuilders = Platformer.LevelBuilders || {};

Platformer.LevelBuilders[4] = function buildLevel4(api) {
  const { line, rect, many, manyEnemies } = api;

  // Fortress layout: layered routes, tank enemies, clean patrol lanes.
  line(12, 16, 17, ".");
  line(36, 40, 17, ".");
  line(60, 64, 17, ".");

  rect(0, 16, 8, 16, "#");
  rect(20, 16, 28, 16, "#");
  rect(44, 16, 52, 16, "#");
  rect(68, 16, 76, 16, "#");
  rect(84, 16, 89, 16, "#");

  rect(30, 14, 34, 14, "#");
  rect(54, 13, 58, 13, "#");
  rect(78, 12, 82, 12, "#");

  line(9, 16, 12, "=");
  line(26, 34, 10, "=");
  line(48, 57, 8, "=");
  line(70, 80, 7, "=");

  many([[3, 16]], "S");
  many([[32, 9], [74, 6]], "K");
  many([[11, 11], [28, 9], [33, 9], [49, 7], [56, 7], [71, 6], [79, 6], [86, 15], [22, 15], [45, 15]], "C");
  many([[30, 9], [52, 7], [75, 6], [86, 15]], "^");
  manyEnemies([[22, 16, "H"], [46, 16, "H"], [70, 16, "H"], [85, 16, "H"]]);
};

  /* <<< level/level-4.js */

  /* >>> level/level-data.js */
// [bundle] namespace init removed; using local Platformer namespace.
Platformer.LevelBuilders = Platformer.LevelBuilders || {};
Platformer.LevelJsonCache = Platformer.LevelJsonCache || {};

Platformer.createLevelData = function createLevelData(level = 1) {
  const jsonLevel = Platformer.LevelJsonCache[level] || null;
  const width = Number((jsonLevel && jsonLevel.width) || 90);
  const height = Number((jsonLevel && jsonLevel.height) || 18);
  const rows = Array.from({ length: height }, () => Array.from({ length: width }, () => "."));

  const inBounds = (x, y) => x >= 0 && x < width && y >= 0 && y < height;
  const put = (x, y, ch) => {
    if (inBounds(x, y)) rows[y][x] = ch;
  };
  const line = (x1, x2, y, ch) => {
    for (let x = x1; x <= x2; x += 1) put(x, y, ch);
  };
  const rect = (x1, y1, x2, y2, ch) => {
    for (let y = y1; y <= y2; y += 1) {
      for (let x = x1; x <= x2; x += 1) put(x, y, ch);
    }
  };
  const many = (items, ch) => items.forEach(([x, y]) => put(x, y, ch));
  const manyEnemies = (items) => items.forEach(([x, y, ch]) => put(x, y, ch));

  // Base floor.
  line(0, width - 1, height - 1, "#");

  if (jsonLevel && Array.isArray(jsonLevel.commands)) {
    jsonLevel.commands.forEach((cmd) => {
      const op = String((cmd && cmd.op) || "");
      if (op === "line") line(Number(cmd.x1), Number(cmd.x2), Number(cmd.y), String(cmd.ch || "."));
      if (op === "rect") rect(Number(cmd.x1), Number(cmd.y1), Number(cmd.x2), Number(cmd.y2), String(cmd.ch || "."));
      if (op === "many") many(Array.isArray(cmd.items) ? cmd.items : [], String(cmd.ch || "."));
      if (op === "manyEnemies") manyEnemies(Array.isArray(cmd.items) ? cmd.items : []);
    });
  } else {
    const builder = Platformer.LevelBuilders[level] || Platformer.LevelBuilders[1];
    if (builder) {
      builder({
        width,
        height,
        put,
        line,
        rect,
        many,
        manyEnemies,
      });
    }
  }

  return rows.map((r) => r.join(""));
};
  /* <<< level/level-data.js */

  /* >>> scenes/boot-scene.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.BootScene = class extends Phaser.Scene {
  constructor() {
    super("BootScene");
    this.playerIdleLoadFailed = false;
    this.playerIdleWarned = false;
  }

  preload() {
    this.load.audio("game-bgm", "assets/Slaughter to Prevail - K (mp3cut.net).mp3");
    this.load.audio("pause-bgm", "assets/Elevator Music - So Chill (mp3cut.net).mp3");
    this.load.image("player-idle-raw", "assets/IFFY_IDLE.png");
    this.load.json("level-1", "assets/levels/level-1.json");
    this.load.json("level-2", "assets/levels/level-2.json");
    this.load.json("level-3", "assets/levels/level-3.json");
    this.load.json("level-4", "assets/levels/level-4.json");
    this.load.on("loaderror", (fileObj) => {
      if (fileObj && fileObj.key === "player-idle-raw") {
        this.playerIdleLoadFailed = true;
        if (Platformer.Debug && !this.playerIdleWarned) {
          this.playerIdleWarned = true;
          Platformer.Debug.warn("BootScene.playerIdle", "Optional asset missing: assets/IFFY_IDLE.png. Using built-in fallback character.");
        }
      }
      if (fileObj && /^level-\d+$/.test(fileObj.key || "")) {
        Platformer.Debug.warn("BootScene.levels", `Level JSON missing for ${fileObj.key}; using built-in fallback.`);
      }
    });
  }

  createRectTexture(key, width, height, fillColor, borderColor = null) {
    const g = this.add.graphics();
    g.fillStyle(fillColor, 1);
    g.fillRect(0, 0, width, height);
    if (borderColor !== null) {
      g.lineStyle(2, borderColor, 1);
      g.strokeRect(1, 1, width - 2, height - 2);
    }
    g.generateTexture(key, width, height);
    g.destroy();
  }

  createCircleTexture(key, diameter, fillColor, borderColor = null) {
    const g = this.add.graphics();
    g.fillStyle(fillColor, 1);
    g.fillCircle(diameter / 2, diameter / 2, diameter / 2);
    if (borderColor !== null) {
      g.lineStyle(2, borderColor, 1);
      g.strokeCircle(diameter / 2, diameter / 2, diameter / 2 - 1);
    }
    g.generateTexture(key, diameter, diameter);
    g.destroy();
  }

  createHazardTexture(key, size, baseColor, accentColor) {
    const g = this.add.graphics();
    // Base mount
    g.fillStyle(0x111827, 1);
    g.fillRoundedRect(2, size - 12, size - 4, 10, 3);

    // Turret body
    g.fillStyle(baseColor, 1);
    g.fillRoundedRect(5, 8, size - 10, size - 10, 4);

    // Barrel and muzzle glow
    g.fillStyle(0x1f2937, 1);
    g.fillRect(size / 2 - 2, 2, 4, 8);
    g.fillStyle(accentColor, 1);
    g.fillCircle(size / 2, 4, 3);
    g.fillStyle(0xfef08a, 0.85);
    g.fillCircle(size / 2, 4, 1.3);

    // Warning chevrons
    g.fillStyle(0x450a0a, 1);
    g.fillTriangle(8, size - 6, 12, size - 10, 16, size - 6);
    g.fillTriangle(size - 16, size - 6, size - 12, size - 10, size - 8, size - 6);

    g.lineStyle(2, 0x0b1220, 1);
    g.strokeRoundedRect(5, 8, size - 10, size - 10, 4);
    g.lineStyle(1, 0xe2e8f0, 0.6);
    g.strokeCircle(size / 2, 4, 3);
    g.generateTexture(key, size, size);
    g.destroy();
  }

  drawCreatureEnemy(g, size, palette) {
    const outline = palette.outline || 0x0f172a;
    const hood = palette.body || 0x6477ff;
    const hoodDark = palette.inner || 0x4652d9;
    const face = palette.face || 0xf8fafc;
    const skin = palette.skin || 0xf4cda6;
    const eye = palette.eye || 0x020617;

    // Hood/body.
    g.fillStyle(hood, 1);
    g.fillRoundedRect(3, 7, size - 6, size - 9, 8);
    g.fillEllipse(size * 0.50, size * 0.46, size * 0.86, size * 0.82);
    g.fillTriangle(size * 0.50, 1, size * 0.36, 9, size * 0.62, 9);

    // Face area.
    g.fillStyle(face, 1);
    g.fillEllipse(size * 0.50, size * 0.52, size * 0.54, size * 0.56);

    // Eyes.
    g.fillStyle(eye, 1);
    g.fillEllipse(size * 0.37, size * 0.51, size * 0.16, size * 0.24);
    g.fillEllipse(size * 0.63, size * 0.51, size * 0.16, size * 0.24);
    g.fillStyle(0xffffff, 0.95);
    g.fillCircle(size * 0.35, size * 0.45, 1.2);
    g.fillCircle(size * 0.61, size * 0.45, 1.2);

    // Mouth/muzzle area.
    g.fillStyle(skin, 1);
    g.fillRoundedRect(size * 0.41, size * 0.60, size * 0.18, size * 0.10, 2);

    // Legs.
    g.fillStyle(hoodDark, 1);
    g.fillRoundedRect(size * 0.30, size - 8, size * 0.14, 7, 2);
    g.fillRoundedRect(size * 0.56, size - 8, size * 0.14, 7, 2);

    // Outline.
    g.lineStyle(2, outline, 1);
    g.strokeRoundedRect(3, 7, size - 6, size - 9, 8);
    g.lineStyle(2, outline, 0.95);
    g.strokeEllipse(size * 0.50, size * 0.46, size * 0.86, size * 0.82);
    g.lineStyle(1.5, outline, 0.95);
    g.strokeEllipse(size * 0.50, size * 0.52, size * 0.54, size * 0.56);
  }

  createEnemyTexture(key, size, bodyColor, accentColor) {
    const g = this.add.graphics();
    this.drawCreatureEnemy(g, size, {
      body: bodyColor,
      inner: Phaser.Display.Color.IntegerToColor(bodyColor).darken(25).color,
      face: 0xf8fafc,
      skin: 0xf4cda6,
      eye: 0x020617,
      outline: accentColor || 0x0f172a,
    });
    g.generateTexture(key, size, size);
    g.destroy();
  }

  createEnemyTextureVariant(key, size, palette) {
    const g = this.add.graphics();
    this.drawCreatureEnemy(g, size, {
      body: palette.body,
      inner: palette.inner,
      face: 0xf8fafc,
      skin: 0xf4cda6,
      eye: 0x020617,
      outline: palette.horns || 0x0f172a,
    });
    g.generateTexture(key, size, size);
    g.destroy();
  }

  createProjectileTexture(key, size) {
    const g = this.add.graphics();
    g.fillStyle(0x7f1d1d, 1);
    g.fillCircle(size / 2, size / 2, size / 2);
    g.fillStyle(0xf97316, 1);
    g.fillCircle(size / 2, size / 2, size / 2 - 2);
    g.fillStyle(0xfef08a, 1);
    g.fillCircle(size / 2 + 1, size / 2 - 1, size / 2 - 5);
    g.lineStyle(1, 0x111827, 0.8);
    g.strokeCircle(size / 2, size / 2, size / 2 - 1);
    g.generateTexture(key, size, size);
    g.destroy();
  }

  createAnimeGirlTexture(key, pose) {
    const g = this.add.graphics();
    const hairColor = pose.jump ? 0xf59e0b : 0xfbbf24;
    const dressColor = pose.jump ? 0x1d4ed8 : 0x2563eb;
    const skin = 0xffddc7;

    g.fillStyle(hairColor, 1);
    g.fillEllipse(14, 10, 20, 16);
    g.fillEllipse(8, 11, 8, 8);
    g.fillEllipse(20, 11, 8, 8);

    g.fillStyle(skin, 1);
    g.fillEllipse(14, 11, 13, 12);

    g.fillStyle(0x111827, 1);
    g.fillCircle(11, pose.blink ? 11 : 10, pose.blink ? 1 : 1.6);
    g.fillCircle(17, pose.blink ? 11 : 10, pose.blink ? 1 : 1.6);

    g.lineStyle(1.5, 0xe11d48, 1);
    g.beginPath();
    g.moveTo(12, 14);
    g.lineTo(16, 14);
    g.strokePath();

    g.fillStyle(dressColor, 1);
    g.fillRoundedRect(9, 17, 10, 10, 2);

    g.fillStyle(0xffffff, 1);
    g.fillRect(11, 19, 6, 3);

    const armLeftY = pose.armLeftY ?? 21;
    const armRightY = pose.armRightY ?? 21;
    g.fillStyle(skin, 1);
    g.fillRect(6, armLeftY, 3, 8);
    g.fillRect(19, armRightY, 3, 8);

    g.fillStyle(0x0f172a, 1);
    g.fillRect(8, 27, 12, 5);

    const legLeftY = pose.legLeftY ?? 32;
    const legRightY = pose.legRightY ?? 32;
    g.fillStyle(0x111827, 1);
    g.fillRect(10, legLeftY, 3, 6);
    g.fillRect(15, legRightY, 3, 6);

    g.fillStyle(0xec4899, 1);
    g.fillRect(6, 4, 4, 2);
    g.fillRect(18, 4, 4, 2);

    g.generateTexture(key, 28, 38);
    g.destroy();
  }

  createPlayerTextures() {
    this.createAnimeGirlTexture("player-idle-1", {
      armLeftY: 21, armRightY: 21, legLeftY: 32, legRightY: 32, blink: false, jump: false,
    });
    this.createAnimeGirlTexture("player-idle-2", {
      armLeftY: 22, armRightY: 22, legLeftY: 32, legRightY: 32, blink: true, jump: false,
    });
    this.createAnimeGirlTexture("player-run-1", {
      armLeftY: 19, armRightY: 23, legLeftY: 31, legRightY: 33, blink: false, jump: false,
    });
    this.createAnimeGirlTexture("player-run-2", {
      armLeftY: 23, armRightY: 19, legLeftY: 33, legRightY: 31, blink: false, jump: false,
    });
    this.createAnimeGirlTexture("player-jump", {
      armLeftY: 17, armRightY: 17, legLeftY: 30, legRightY: 30, blink: false, jump: true,
    });
  }

  create() {
    const { TILE } = Platformer.Config;
    const cbMode = Platformer.Settings.current.accessibility.colorblindMode;
    const hazardColor = cbMode === "off" ? 0xdc2626 : (cbMode === "tritanopia" ? 0xf59e0b : 0x2563eb);
    const laserAccent = cbMode === "off" ? 0xfca5a5 : 0xfef08a;
    const coinColor = cbMode === "deuteranopia" ? 0xf9a8d4 : 0xfacc15;
    const enemyColor = cbMode === "protanopia" ? 0x22d3ee : 0xfb923c;
    const enemyFangColor = cbMode === "protanopia" ? 0xfef08a : 0xffffff;

    this.createPlayerTextures();
    this.createRectTexture("ground", TILE, TILE, 0x8b5a2b, 0x5a3a1d);
    this.createRectTexture("platform", TILE, TILE, 0x6b7280, 0x374151);
    this.createRectTexture("oneway", TILE, 12, 0x38bdf8, 0x0369a1);
    this.createHazardTexture("hazard", TILE, hazardColor, laserAccent);
    this.setupPlayerIdleAnimation();
    this.createCircleTexture("coin", 16, coinColor, 0xa16207);
    this.createEnemyTexture("enemy", 24, enemyColor, enemyFangColor);
    this.createEnemyTextureVariant("enemy-e", 24, { body: 0xfb923c, inner: 0x7f1d1d, accent: 0xffffff, horns: 0xfef08a });
    this.createEnemyTextureVariant("enemy-f", 24, { body: 0x22d3ee, inner: 0x164e63, accent: 0xfef08a, horns: 0xe2e8f0 });
    this.createEnemyTextureVariant("enemy-g", 24, { body: 0xf43f5e, inner: 0x4c0519, accent: 0xfef2f2, horns: 0xfda4af });
    this.createEnemyTextureVariant("enemy-h", 24, { body: 0xa855f7, inner: 0x3b0764, accent: 0xfef08a, horns: 0xd8b4fe });
    this.createProjectileTexture("hazard-projectile", 14);
    this.createRectTexture("checkpoint", 16, 40, 0xa855f7, 0x581c87);

    this.registry.set("coins", 0);
    this.registry.set("health", 3);
    this.registry.set("lives", 2);
    this.registry.set("level", 1);
    Platformer.LevelJsonCache = {};
    [1, 2, 3, 4].forEach((n) => {
      const key = `level-${n}`;
      const json = this.cache.json.get(key);
      if (json && typeof json === "object") {
        Platformer.LevelJsonCache[n] = json;
      }
    });

    this.scene.start("MenuScene");
  }

  setupPlayerIdleAnimation() {
    if (!this.textures.exists("player-idle-raw")) {
      if (Platformer.Debug && !this.playerIdleWarned) {
        this.playerIdleWarned = true;
        const msg = this.playerIdleLoadFailed
          ? "Player idle spritesheet failed to preload. Using built-in fallback character."
          : "Player idle spritesheet not found. Using built-in fallback character.";
        Platformer.Debug.warn("BootScene.playerIdle", msg);
      }
      return;
    }

    const source = this.textures.get("player-idle-raw").getSourceImage();
    if (!source || !source.width || !source.height) {
      if (Platformer.Debug) Platformer.Debug.warn("BootScene.playerIdle", "player-idle-raw source has invalid dimensions.");
      return;
    }

    const frames = 4;
    const frameWidth = Math.floor(source.width / frames);
    const frameHeight = source.height;
    if (frameWidth < 1 || frameHeight < 1) {
      if (Platformer.Debug) Platformer.Debug.warn("BootScene.playerIdle", `Invalid frame size: ${frameWidth}x${frameHeight}`);
      return;
    }

    if (this.textures.exists("player-idle-sheet")) {
      this.textures.remove("player-idle-sheet");
    }
    this.textures.addSpriteSheet("player-idle-sheet", source, {
      frameWidth,
      frameHeight,
      endFrame: frames - 1,
    });

    if (this.anims.exists("playerIdleAnim")) {
      this.anims.remove("playerIdleAnim");
    }
    this.anims.create({
      key: "playerIdleAnim",
      frames: this.anims.generateFrameNumbers("player-idle-sheet", { start: 0, end: frames - 1 }),
      frameRate: 6,
      repeat: -1,
    });
    if (Platformer.Debug) Platformer.Debug.log("BootScene.playerIdle", `Loaded IFFY idle sheet ${source.width}x${source.height}, frames=${frames}`);
  }
};
  /* <<< scenes/boot-scene.js */

  /* >>> scenes/menu-scene.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.MenuScene = class extends Phaser.Scene {
  constructor() {
    super("MenuScene");
    this.menuMusic = null;
    this.menuMusicHtml = null;
    this.updateButton = null;
    this.updateButtonText = null;
    this.versionInfoText = null;
    this.changeButton = null;
    this.changeButtonText = null;
    this.changePanel = null;
    this.changePanelTitle = null;
    this.changePanelBody = null;
    this.changePanelOpen = false;
    this.latestReleaseNotes = [
      "No update details yet.",
      "",
      "Recent changes:",
      "- Live animated menu lane (runner + enemy stomps)",
      "- Menu hit feedback (red blink + knockback, non-lethal)",
      "- Menu ambient state persists after Options return",
      "- Options opens as live overlay over animated menu",
      "- Reworked Options into standalone category cards",
      "- Resize-safe Options layout and anchored back button",
      "- Stable Options scrolling with fixed action footer",
      "- Save + Back / Reset defaults always visible",
      "",
      "If online notes are available, this panel auto-refreshes from GitHub Releases.",
    ].join("\n");
    this.latestReleaseTag = "";
    this.pendingUpdateUrl = "";
    this.updateInProgress = false;
    this.bgSky = null;
    this.bgMid = null;
    this.bgGround = null;
    this.bgAccentTop = null;
    this.bgAccentBottom = null;
    this.bgOrbs = [];
    this.menuCard = null;
    this.titleText = null;
    this.titleShadow = null;
    this.comingSoonText = null;
    this.menuButtons = {};
    this.onResize = null;
    this.menuUiElements = [];
    this.menuInteractive = false;
    this.introFx = null;
    this.introParticles = null;
    this.introLines = [];
    this.introGlow = null;
    this.menuIntroInProgress = false;
    this.menuIntroUiFadeCall = null;
    this.menuIntroDoneCall = null;
    this.menuStage = null;
    this.menuRunner = null;
    this.menuRunnerFace = 1;
    this.menuRunnerGroundY = 0;
    this.menuRunnerSpeed = 82;
    this.menuRunnerJumpVy = -270;
    this.menuRunnerVy = 0;
    this.menuRunnerGravity = 700;
    this.menuRunnerJumpCooldown = 0;
    this.menuRunnerActionTimer = 0;
    this.menuRunnerDamageCooldown = 0;
    this.menuRunnerDamageFlashUntil = 0;
    this.menuEnemies = [];
    this.introConfig = {
      totalMs: 1800,
      uiFadeMs: 260,
      titleRevealDelayMs: 80,
      titleRevealMs: 420,
      buttonStaggerMs: 90,
      buttonMovePx: 18,
      skyColor: 0x081336,
      midColor: 0x132a56,
      groundColor: 0x0b6f49,
      glowCyan: 0x53e0ff,
      glowPink: 0xff71c7,
    };
  }

  create() {
    const textScale = Platformer.Settings.textScale();

    this.bgSky = this.add.rectangle(0, 0, 10, 10, this.introConfig.skyColor, 1).setOrigin(0, 0);
    this.bgMid = this.add.rectangle(0, 0, 10, 10, this.introConfig.midColor, 1).setOrigin(0, 0);
    this.bgGround = this.add.rectangle(0, 0, 10, 10, this.introConfig.groundColor, 1).setOrigin(0, 0);
    this.bgAccentTop = this.add.rectangle(0, 0, 10, 10, 0x1e3a8a, 0.24).setOrigin(0, 0);
    this.bgAccentBottom = this.add.rectangle(0, 0, 10, 10, 0x34d399, 0.22).setOrigin(0, 0);
    this.createPrettyBackdrop();

    this.titleShadow = this.add.text(0, 74, "ANIME PLATFORMER", {
      fontFamily: "Verdana",
      fontSize: `${Math.round(46 * textScale)}px`,
      color: "#67e8f9",
      stroke: "#020617",
      strokeThickness: 12,
    }).setOrigin(0.5).setDepth(13).setAlpha(0.26);

    this.titleText = this.add.text(0, 72, "ANIME PLATFORMER", {
      fontFamily: "Verdana",
      fontSize: `${Math.round(46 * textScale)}px`,
      color: "#f8fafc",
      stroke: "#1e293b",
      strokeThickness: 7,
    }).setOrigin(0.5).setDepth(14);
    this.setupMenuMusic();

    const makeButton = (id, y, label, onClick, opts = {}) => {
      const disabled = !!opts.disabled;
      const glow = this.add.rectangle(0, y, 286, 56, 0x22d3ee, disabled ? 0.08 : 0.14)
        .setDepth(9)
        .setBlendMode(Phaser.BlendModes.ADD);
      const box = this.add.rectangle(0, y, 280, 50, disabled ? 0x475569 : 0x243b67, 0.96)
        .setStrokeStyle(3, disabled ? 0x64748b : 0x7dd3fc, 0.95)
        .setDepth(10);
      const txt = this.add.text(0, y, label, {
        fontFamily: "Consolas",
        fontSize: `${Math.round(30 * textScale)}px`,
        color: disabled ? "#cbd5e1" : "#f8fafc",
        stroke: disabled ? "#334155" : "#0f172a",
        strokeThickness: 2,
      }).setOrigin(0.5).setDepth(11);

      if (!disabled) {
        box.setInteractive({ useHandCursor: true });
        box.on("pointerover", () => {
          box.setFillStyle(0x2f4f86, 1);
          glow.setAlpha(0.26);
          this.tweens.add({ targets: [box, txt, glow], scaleX: 1.03, scaleY: 1.03, duration: 120, ease: "Sine.Out" });
        });
        box.on("pointerout", () => {
          box.setFillStyle(0x243b67, 0.96);
          glow.setAlpha(0.14);
          this.tweens.add({ targets: [box, txt, glow], scaleX: 1, scaleY: 1, duration: 120, ease: "Sine.Out" });
        });
        box.on("pointerdown", onClick);
      }

      this.menuButtons[id] = { box, txt, glow };
      return this.menuButtons[id];
    };

    const launchGameplay = () => {
      this.stopMenuMusic();
      const difficulty = Platformer.Settings.current.gameplay.difficulty;
      const baseLives = difficulty === "easy" ? 3 : (difficulty === "hard" ? 1 : 2);

      if (this.scene.isActive("UIScene") || this.scene.isPaused("UIScene")) {
        this.scene.stop("UIScene");
      }
      if (this.scene.isActive("GameScene") || this.scene.isPaused("GameScene")) {
        this.scene.stop("GameScene");
      }

      this.registry.set("coins", 0);
      this.registry.set("health", 3);
      this.registry.set("lives", baseLives);
      this.registry.set("level", 1);
          this.scene.start("GameScene", { level: 1 });
      this.scene.launch("UIScene");
      if (Platformer.Debug) Platformer.Debug.log("MenuScene", "Play -> GameScene launched.");
    };

    const startGame = () => {
      if (!this.menuInteractive) return;
      Platformer.beeper.unlock();
      if (Platformer.Debug) Platformer.Debug.log("MenuScene", "Play clicked.");
      if (this.sound && this.sound.context && this.sound.context.state === "suspended") {
        this.sound.context.resume().catch(() => {});
      }

      const seen = !!Platformer.Settings.current.convenience.introSeen;
      if (seen) {
        if (Platformer.Debug) Platformer.Debug.log("MenuScene", "Intro already seen; starting gameplay directly.");
        launchGameplay();
      } else {
        this.stopMenuMusic();
        if (Platformer.Debug) Platformer.Debug.log("MenuScene", "Starting IntroScene before gameplay.");
        this.scene.start("IntroScene");
      }
    };

    makeButton("play", 0, "PLAY", startGame);
    makeButton("continue", 0, "CONTINUE", null, { disabled: true });
    this.comingSoonText = this.add.text(0, 0, "Coming soon ^^", {
      fontFamily: "Consolas",
      fontSize: `${Math.round(17 * textScale)}px`,
      color: "#fef3c7",
      stroke: "#78350f",
      strokeThickness: 3,
    }).setOrigin(0.5).setDepth(12);

    makeButton("options", 0, "OPTIONS", () => {
      if (Platformer.Debug) Platformer.Debug.log("MenuScene", "Opening OptionsScene from menu.");
      this.setMenuUiVisible(false);
      this.setMenuInteractive(false);
      this.scene.launch("OptionsScene", { returnTo: "menuOverlay" });
    });
    makeButton("credits", 0, "CREDITS", () => this.showCredits());
    makeButton("exit", 0, "EXIT", () => this.handleExit());
    this.createBottomLeftVersionInfo();
    this.createMenuUpdateWidget();
    this.createWhatsChangedWidget();
    this.createMenuMiniStage();
    this.menuCard = this.add.rectangle(0, 0, 360, 390, 0x0b1731, 0.46)
      .setStrokeStyle(2, 0x7dd3fc, 0.38)
      .setDepth(8.5);
    this.collectMenuUiElements();
    const shouldPlayMenuIntro = !Platformer._menuBootIntroPlayed;
    if (shouldPlayMenuIntro) {
      Platformer._menuBootIntroPlayed = true;
      this.setMenuUiVisible(false);
      this.setMenuInteractive(false);
    } else {
      this.setMenuUiVisible(true);
      this.setMenuInteractive(true);
    }
    this.createMenuIntroFx();
    this.layoutMenu();
    this.onResize = () => this.handleResize();
    this.scale.on("resize", this.onResize);
    if (shouldPlayMenuIntro) this.playMenuIntro();

    this.input.keyboard.on("keydown-ENTER", startGame);
  }

  layoutMenu() {
    const w = this.scale.width;
    const h = this.scale.height;
    const cx = w / 2;
    const cy = h / 2;

    this.bgSky.setSize(w, h).setPosition(0, 0);
    this.bgMid.setSize(w, 220).setPosition(0, cy + 160);
    this.bgGround.setSize(w, 120).setPosition(0, cy + 220);
    this.bgAccentTop.setSize(w, Math.round(h * 0.42)).setPosition(0, 0);
    this.bgAccentBottom.setSize(w, Math.round(h * 0.2)).setPosition(0, h - Math.round(h * 0.24));
    this.titleShadow.setPosition(cx, 74);
    this.titleText.setPosition(cx, 72);

    const y0 = cy - 40;
    const spacing = 60;
    const p = this.menuButtons.play;
    const c = this.menuButtons.continue;
    const o = this.menuButtons.options;
    const cr = this.menuButtons.credits;
    const e = this.menuButtons.exit;
    const place = (item, y) => {
      if (!item) return;
      if (item.glow) item.glow.setPosition(cx, y);
      item.box.setPosition(cx, y);
      item.txt.setPosition(cx, y);
    };
    place(p, y0);
    place(c, y0 + spacing);
    place(o, y0 + spacing * 2);
    place(cr, y0 + spacing * 3);
    place(e, y0 + spacing * 4);
    if (this.menuCard) this.menuCard.setPosition(cx, y0 + spacing * 2).setSize(360, 356);
    if (this.comingSoonText) this.comingSoonText.setPosition(cx + 210, y0 + spacing);

    if (this.updateButton && this.updateButtonText) {
      const ux = w - 96;
      const uy = 38;
      this.updateButton.setPosition(ux, uy);
      this.updateButtonText.setPosition(ux, uy);
    }
    if (this.changeButton && this.changeButtonText) {
      const cxRight = w - 96;
      const cyTop = 84;
      this.changeButton.setPosition(cxRight, cyTop);
      this.changeButtonText.setPosition(cxRight, cyTop);
    }
    if (this.changePanel && this.changePanelTitle && this.changePanelBody) {
      const panelW = Math.min(560, Math.max(380, Math.round(w * 0.34)));
      const panelH = Math.min(430, Math.max(240, Math.round(h * 0.5)));
      const px = w - panelW / 2 - 20;
      const py = Math.min(116 + panelH / 2, h - panelH / 2 - 20);
      this.changePanel.setSize(panelW, panelH).setPosition(px, py);
      this.changePanelTitle.setPosition(px - panelW / 2 + 16, py - panelH / 2 + 12);
      this.changePanelBody
        .setPosition(px - panelW / 2 + 16, py - panelH / 2 + 44)
        .setWordWrapWidth(panelW - 32);
    }
    if (this.versionInfoText) this.versionInfoText.setPosition(14, h - 12);
    this.layoutMenuMiniStage();
    this.layoutMenuIntroFx();
  }

  createMenuMiniStage() {
    this.menuStage = this.add.container(0, 0).setDepth(7.8);

    // Invisible logical lane: runner/enemies stay inside the existing green menu band.
    const lane = this.add.rectangle(0, 0, 10, 10, 0x12815f, 0).setOrigin(0, 0.5);
    const topStrip = this.add.rectangle(0, 0, 10, 8, 0x4ade80, 0).setOrigin(0, 1);
    const laneShade = this.add.rectangle(0, 0, 10, 10, 0x0c5e45, 0).setOrigin(0, 0.5);
    this.menuStage.add([lane, topStrip]);
    this.menuStage.lane = lane;
    this.menuStage.topStrip = topStrip;
    this.menuStage.laneShade = laneShade;
    this.menuStage.add(laneShade);

    this.menuRunner = this.add.sprite(0, 0, this.textureOr("player-run-1", "player")).setDepth(8.2);
    this.menuRunner.setDisplaySize(48, 64);
    this.menuStage.add(this.menuRunner);

    this.menuEnemies = [];
    for (let i = 0; i < 4; i += 1) {
      const enemy = this.add.sprite(0, 0, this.textureOr("enemy-e", "enemy")).setDepth(8.15);
      enemy.setDisplaySize(34, 34);
      enemy.menuX = 0;
      enemy.menuDir = i % 2 === 0 ? 1 : -1;
      enemy.menuSpeed = 30 + (i * 8);
      enemy.alive = true;
      enemy.respawnAt = 0;
      this.menuEnemies.push(enemy);
      this.menuStage.add(enemy);
    }
    this.restoreMenuMiniStageState();
  }

  layoutMenuMiniStage() {
    if (!this.menuStage || !this.menuStage.lane || !this.menuStage.topStrip) return;
    const w = this.scale.width;
    const h = this.scale.height;
    const baseGroundTop = this.bgGround ? this.bgGround.y : (h - 160);
    const baseGroundH = this.bgGround ? this.bgGround.height : 120;
    const laneY = baseGroundTop + Math.round(baseGroundH * 0.44);
    const laneH = Math.max(30, Math.round(baseGroundH * 0.34));
    const margin = 26;
    const laneX = margin;
    const laneW = Math.max(280, w - margin * 2);
    this.menuRunnerGroundY = laneY - 6;

    this.menuStage.lane.setPosition(laneX, laneY).setSize(laneW, laneH);
    this.menuStage.topStrip.setPosition(laneX, laneY).setSize(laneW, 8);
    this.menuStage.laneShade.setPosition(laneX, laneY + 12).setSize(laneW, laneH - 12);

    if (this.menuRunner) {
      if (!Number.isFinite(this.menuRunner.menuX)) {
        this.menuRunner.menuX = laneX + 60;
      }
      this.menuRunner.y = this.menuRunnerGroundY;
    }

    const slot = laneW / (this.menuEnemies.length + 1);
    this.menuEnemies.forEach((enemy, idx) => {
      if (!enemy) return;
      if (!enemy.alive && this.time.now < enemy.respawnAt) return;
      enemy.alive = true;
      enemy.menuX = laneX + slot * (idx + 1) + Phaser.Math.Between(-26, 26);
      enemy.y = this.menuRunnerGroundY + 2;
      enemy.setVisible(true);
      enemy.setAlpha(1);
    });
  }

  restoreMenuMiniStageState() {
    const s = Platformer._menuAmbientState;
    if (!s) return;
    if (this.menuRunner && Number.isFinite(s.runnerX)) {
      this.menuRunner.menuX = s.runnerX;
      this.menuRunner.y = Number.isFinite(s.runnerY) ? s.runnerY : this.menuRunnerGroundY;
      this.menuRunnerFace = s.runnerFace === -1 ? -1 : 1;
      this.menuRunnerVy = Number.isFinite(s.runnerVy) ? s.runnerVy : 0;
      this.menuRunnerJumpCooldown = Number.isFinite(s.runnerJumpCooldown) ? s.runnerJumpCooldown : 0;
      this.menuRunnerDamageCooldown = Number.isFinite(s.runnerDamageCooldown) ? s.runnerDamageCooldown : 0;
      this.menuRunnerActionTimer = Number.isFinite(s.runnerActionTimer) ? s.runnerActionTimer : 0;
    }
    if (Array.isArray(s.enemies) && this.menuEnemies && this.menuEnemies.length) {
      this.menuEnemies.forEach((enemy, idx) => {
        const se = s.enemies[idx];
        if (!enemy || !se) return;
        enemy.menuX = Number.isFinite(se.x) ? se.x : enemy.menuX;
        enemy.menuDir = se.dir === -1 ? -1 : 1;
        enemy.alive = se.alive !== false;
        enemy.respawnAt = Number.isFinite(se.respawnAt) ? se.respawnAt : 0;
        enemy.setVisible(enemy.alive);
        if (enemy.alive) {
          enemy.setAlpha(1);
          enemy.setScale(1, 1);
        }
      });
    }
  }

  saveMenuMiniStageState() {
    Platformer._menuAmbientState = {
      runnerX: this.menuRunner && Number.isFinite(this.menuRunner.menuX) ? this.menuRunner.menuX : null,
      runnerY: this.menuRunner ? this.menuRunner.y : null,
      runnerFace: this.menuRunnerFace,
      runnerVy: this.menuRunnerVy,
      runnerJumpCooldown: this.menuRunnerJumpCooldown,
      runnerDamageCooldown: this.menuRunnerDamageCooldown,
      runnerActionTimer: this.menuRunnerActionTimer,
      enemies: (this.menuEnemies || []).map((enemy) => ({
        x: enemy && Number.isFinite(enemy.menuX) ? enemy.menuX : null,
        dir: enemy && enemy.menuDir === -1 ? -1 : 1,
        alive: !!(enemy && enemy.alive),
        respawnAt: enemy && Number.isFinite(enemy.respawnAt) ? enemy.respawnAt : 0,
      })),
    };
  }

  handleResize() {
    this.layoutMenu();
    if (this.menuIntroInProgress) {
      this.forceCompleteMenuIntro();
    }
  }

  createMenuUpdateWidget() {
    const x = this.scale.width - 96;
    const y = 38;
    this.updateButton = this.add.rectangle(x, y, 160, 38, 0x334155, 0.95)
      .setStrokeStyle(2, 0x67e8f9, 0.95)
      .setDepth(20)
      .setInteractive({ useHandCursor: true });
    this.updateButtonText = this.add.text(x, y, "Update", {
      fontFamily: "Consolas",
      fontSize: "22px",
      color: "#f8fafc",
    }).setOrigin(0.5).setDepth(21);
    this.updateButton.on("pointerover", () => this.updateButton.setFillStyle(0x3b4f73, 0.98));
    this.updateButton.on("pointerout", () => this.updateButton.setFillStyle(0x334155, 0.95));
    this.updateButton.on("pointerdown", async () => {
      if (this.updateInProgress) {
        // Top-right status text intentionally hidden; bottom-left remains source of truth.
        return;
      }

      if (this.pendingUpdateUrl) {
        if (Platformer.Updater.canInAppApply()) {
          const result = await this.startInAppUpdate(this.pendingUpdateUrl, "Updating game...");
          if (!result.ok && Platformer.Debug) {
            Platformer.Debug.error("MenuScene.update", result.message || "Update failed.");
          }
          return;
        }

        if (Platformer.Debug) Platformer.Debug.log("MenuScene.update", `In-app updater unavailable; opening URL: ${this.pendingUpdateUrl}`);
        const opened = Platformer.Updater.openDownload(this.pendingUpdateUrl);
        this.setBottomLeftUpdateStatus(opened ? "Downloading update..." : "Update download failed");
        return;
      }

      this.setBottomLeftUpdateStatus("Checking for updates...");
      if (Platformer.Debug) Platformer.Debug.log("MenuScene.update", "Manual update check requested.");
      const result = await Platformer.Updater.check();
      if (!result.ok) {
        this.setBottomLeftUpdateStatus(result.message || "Can't reach update server.");
        return;
      }
      this.setLatestChangesFromResult(result);
      if (!result.enabled) {
        this.setBottomLeftUpdateStatus("Auto updates are off.");
        return;
      }
      if (result.hasUpdate) {
        this.pendingUpdateUrl = result.downloadUrl || "";
        Platformer.Updater.latestChecksumSha256 = result.checksumSha256 || "";
        this.updateButtonText.setText(this.pendingUpdateUrl ? "Update + Restart" : "Update");
        const v = result.latestVersion ? `v${result.latestVersion}` : "new";
        this.setBottomLeftUpdateStatus(`Update found (${v}).`);
        if (Platformer.Debug) Platformer.Debug.warn("MenuScene.update", `Update available: ${v}`);
      } else {
        this.pendingUpdateUrl = "";
        Platformer.Updater.latestChecksumSha256 = "";
        this.updateButtonText.setText("Update");
        this.setBottomLeftUpdateStatus("You're up to date.");
        if (Platformer.Debug) Platformer.Debug.log("MenuScene.update", "No update available.");
      }
    });

    this.time.delayedCall(100, () => this.autoCheckUpdatesForBottomLeft());
  }

  async startInAppUpdate(downloadUrl, startMessage = "Preparing update...") {
    this.updateInProgress = true;
    this.updateButton.disableInteractive();
    this.updateButtonText.setText("Updating...");
    this.setBottomLeftUpdateStatus(startMessage);
    if (Platformer.Debug) Platformer.Debug.log("MenuScene.update", startMessage);

    const result = await Platformer.Updater.updateAndRestart(downloadUrl, (status) => {
      const pct = Number(status.progress || 0);
      const msg = status.message || status.stage || "Updating...";
      const compact = status.stage === "downloading" && Number.isFinite(pct)
        ? `${msg} (${pct.toFixed(1)}%)`
        : msg;
      this.setBottomLeftUpdateStatus(compact);
    });

    if (!result.ok) {
      this.updateInProgress = false;
      this.updateButton.setInteractive({ useHandCursor: true });
      this.updateButtonText.setText("Update + Restart");
      this.setBottomLeftUpdateStatus(result.message || "Update failed.");
      return { ok: false, message: result.message || "Update failed." };
    }

    this.setBottomLeftUpdateStatus(result.message || "Restarting to finish update...");
    return { ok: true, message: result.message || "Restarting to finish update..." };
  }

  createBottomLeftVersionInfo() {
    const currentVersion = ((Platformer.Settings.current.updates || {}).currentVersion || "1.0.0").trim();
    this.versionInfoText = this.add.text(14, this.scale.height - 12, "", {
      fontFamily: "Consolas",
      fontSize: "18px",
      color: "#e2e8f0",
      stroke: "#0f172a",
      strokeThickness: 4,
      align: "left",
    }).setOrigin(0, 1).setDepth(25);

    this.setBottomLeftUpdateStatus("Checking for updates...");
    this.versionInfoText.setText(`Version: ${currentVersion}\nUpdate: Checking for updates...`);
  }

  setBottomLeftUpdateStatus(statusText) {
    if (!this.versionInfoText) return;
    const currentVersion = ((Platformer.Settings.current.updates || {}).currentVersion || "1.0.0").trim();
    const safeStatus = statusText || "Unknown";
    this.versionInfoText.setText(`Version: ${currentVersion}\nUpdate: ${safeStatus}`);
  }

  async autoCheckUpdatesForBottomLeft() {
    const cfg = Platformer.Settings.current.updates || {};
    if (!cfg.enabled) {
      this.setBottomLeftUpdateStatus("Auto updates are off.");
      return;
    }

      this.setBottomLeftUpdateStatus("Checking for updates...");
    const result = await Platformer.Updater.check();
    if (!result.ok) {
      if (result.transient) {
        this.setBottomLeftUpdateStatus("Checking for updates...");
        this.time.delayedCall(1200, () => this.autoCheckUpdatesForBottomLeft());
        return;
      }
      this.setBottomLeftUpdateStatus(result.message || "Can't reach update server.");
      return;
    }
    if (!result.enabled) {
      this.setBottomLeftUpdateStatus("Auto updates are off.");
      return;
    }
    this.setLatestChangesFromResult(result);

    if (result.hasUpdate) {
      const v = result.latestVersion ? `v${result.latestVersion}` : "new version";
      this.pendingUpdateUrl = result.downloadUrl || "";
      Platformer.Updater.latestChecksumSha256 = result.checksumSha256 || "";
      this.updateButtonText.setText(this.pendingUpdateUrl ? "Update + Restart" : "Update");
      this.setBottomLeftUpdateStatus(`Update found (${v}). Press Update.`);
    } else {
      this.setBottomLeftUpdateStatus("You're up to date.");
      Platformer.Updater.latestChecksumSha256 = "";
      this.updateButtonText.setText("Update");
    }
  }

  createWhatsChangedWidget() {
    const x = this.scale.width - 96;
    const y = 84;
    this.changeButton = this.add.rectangle(x, y, 160, 34, 0x1e293b, 0.95)
      .setStrokeStyle(2, 0x67e8f9, 0.95)
      .setDepth(20)
      .setInteractive({ useHandCursor: true });
    this.changeButtonText = this.add.text(x, y, "What's Changed", {
      fontFamily: "Consolas",
      fontSize: "18px",
      color: "#e2e8f0",
    }).setOrigin(0.5).setDepth(21);

    this.changePanel = this.add.rectangle(0, 0, 480, 290, 0x0f172a, 0.92)
      .setStrokeStyle(2, 0x67e8f9)
      .setDepth(22)
      .setVisible(false);
    this.changePanelTitle = this.add.text(0, 0, "What's Changed", {
      fontFamily: "Consolas",
      fontSize: "20px",
      color: "#f8fafc",
    }).setOrigin(0, 0).setDepth(23).setVisible(false);
    this.changePanelBody = this.add.text(0, 0, this.latestReleaseNotes, {
      fontFamily: "Consolas",
      fontSize: "15px",
      color: "#cbd5e1",
      align: "left",
      wordWrap: { width: 440, useAdvancedWrap: true },
    }).setOrigin(0, 0).setDepth(23).setVisible(false);

    this.changeButton.on("pointerover", () => this.changeButton.setFillStyle(0x334155, 0.98));
    this.changeButton.on("pointerout", () => this.changeButton.setFillStyle(0x1e293b, 0.95));
    this.changeButton.on("pointerdown", () => {
      this.changePanelOpen = !this.changePanelOpen;
      const on = this.changePanelOpen;
      this.changePanel.setVisible(on);
      this.changePanelTitle.setVisible(on);
      this.changePanelBody.setVisible(on);
      if (on) {
        this.changeButtonText.setText("Hide Changes");
      } else {
        this.changeButtonText.setText("What's Changed");
      }
    });
  }

  collectMenuUiElements() {
    this.menuUiElements = [];
    if (this.titleText) this.menuUiElements.push(this.titleText);
    if (this.titleShadow) this.menuUiElements.push(this.titleShadow);
    if (this.menuCard) this.menuUiElements.push(this.menuCard);
    Object.values(this.menuButtons).forEach((b) => {
      if (b && b.glow) this.menuUiElements.push(b.glow);
      if (b && b.box) this.menuUiElements.push(b.box);
      if (b && b.txt) this.menuUiElements.push(b.txt);
    });
    if (this.comingSoonText) this.menuUiElements.push(this.comingSoonText);
    if (this.updateButton) this.menuUiElements.push(this.updateButton);
    if (this.updateButtonText) this.menuUiElements.push(this.updateButtonText);
    if (this.changeButton) this.menuUiElements.push(this.changeButton);
    if (this.changeButtonText) this.menuUiElements.push(this.changeButtonText);
    if (this.changePanel) this.menuUiElements.push(this.changePanel);
    if (this.changePanelTitle) this.menuUiElements.push(this.changePanelTitle);
    if (this.changePanelBody) this.menuUiElements.push(this.changePanelBody);
    if (this.versionInfoText) this.menuUiElements.push(this.versionInfoText);
  }

  setMenuUiVisible(visible) {
    const a = visible ? 1 : 0;
    this.menuUiElements.forEach((el) => {
      if (!el || !el.active) return;
      el.setAlpha(a);
      if (this.changePanelOpen && (el === this.changePanel || el === this.changePanelTitle || el === this.changePanelBody)) {
        el.setVisible(visible);
      }
    });
  }

  setMenuInteractive(enabled) {
    this.menuInteractive = !!enabled;
    const interactiveIds = ["play", "options", "credits", "exit"];
    interactiveIds.forEach((id) => {
      const b = this.menuButtons[id];
      if (!b || !b.box) return;
      if (enabled) b.box.setInteractive({ useHandCursor: true });
      else b.box.disableInteractive();
    });
    if (this.updateButton) {
      if (enabled) this.updateButton.setInteractive({ useHandCursor: true });
      else this.updateButton.disableInteractive();
    }
    if (this.changeButton) {
      if (enabled) this.changeButton.setInteractive({ useHandCursor: true });
      else this.changeButton.disableInteractive();
    }
  }

  ensureMenuIntroTextures() {
    if (!this.textures.exists("menu-intro-dot")) {
      const g = this.make.graphics({ x: 0, y: 0, add: false });
      g.fillStyle(0xffffff, 1);
      g.fillCircle(4, 4, 4);
      g.generateTexture("menu-intro-dot", 8, 8);
      g.destroy();
    }
    if (!this.textures.exists("menu-intro-line")) {
      const g = this.make.graphics({ x: 0, y: 0, add: false });
      g.fillStyle(0xffffff, 1);
      g.fillRect(0, 0, 140, 2);
      g.generateTexture("menu-intro-line", 140, 2);
      g.destroy();
    }
  }

  createMenuIntroFx() {
    this.ensureMenuIntroTextures();
    const w = this.scale.width;
    const h = this.scale.height;
    this.introFx = this.add.container(0, 0).setDepth(9);
    this.introLines = [];

    for (let i = 0; i < 12; i += 1) {
      const isPink = i % 3 === 0;
      const line = this.add.image(
        Phaser.Math.Between(0, w),
        Phaser.Math.Between(40, h - 80),
        "menu-intro-line"
      )
        .setOrigin(0, 0.5)
        .setTint(isPink ? this.introConfig.glowPink : this.introConfig.glowCyan)
        .setAlpha(isPink ? 0.18 : 0.24)
        .setBlendMode(Phaser.BlendModes.SCREEN);
      line.introSpeed = Phaser.Math.FloatBetween(38, 90);
      line.introParallax = Phaser.Math.FloatBetween(0.3, 1);
      this.introLines.push(line);
      this.introFx.add(line);
    }

    this.introParticles = this.add.particles(0, 0, "menu-intro-dot", {
      x: { min: 0, max: w },
      y: { min: 0, max: h * 0.72 },
      lifespan: { min: 1500, max: 3600 },
      speedX: { min: -8, max: 8 },
      speedY: { min: -36, max: -10 },
      scale: { start: 0.55, end: 0 },
      alpha: { start: 0.36, end: 0 },
      tint: [this.introConfig.glowCyan, this.introConfig.glowPink, 0xffffff],
      blendMode: "ADD",
      frequency: 90,
      quantity: 1,
    }).setDepth(10);
  }

  layoutMenuIntroFx() {
    if (!this.introParticles) return;
    const w = this.scale.width;
    const h = this.scale.height;
    this.introParticles.setConfig({
      x: { min: 0, max: w },
      y: { min: 0, max: h * 0.72 },
    });
  }

  playMenuIntro() {
    if (!this.titleText) return;
    this.menuIntroInProgress = true;

    this.titleText.setAlpha(0).setScale(0.94).setY(42);
    this.cameras.main.fadeIn(520, 0, 0, 0);

    this.tweens.add({
      targets: this.titleText,
      delay: this.introConfig.titleRevealDelayMs,
      y: 72,
      alpha: 1,
      scaleX: 1,
      scaleY: 1,
      ease: "Cubic.Out",
      duration: this.introConfig.titleRevealMs,
    });

    this.introGlow = this.add.circle(this.scale.width / 2, 86, 220, this.introConfig.glowCyan, 0.08)
      .setBlendMode(Phaser.BlendModes.ADD)
      .setDepth(13);
    this.tweens.add({
      targets: this.introGlow,
      alpha: { from: 0.15, to: 0.03 },
      scale: { from: 0.8, to: 1.14 },
      ease: "Sine.InOut",
      yoyo: true,
      repeat: -1,
      duration: 2200,
    });

    const orderedButtons = ["play", "continue", "options", "credits", "exit"]
      .map((id) => this.menuButtons[id])
      .filter((b) => !!b);
    const buttonTargets = [];
    orderedButtons.forEach((b) => {
      if (b.glow) buttonTargets.push(b.glow);
      if (b.box) buttonTargets.push(b.box);
      if (b.txt) buttonTargets.push(b.txt);
    });

    buttonTargets.forEach((obj) => {
      obj.y += this.introConfig.buttonMovePx;
      obj.setAlpha(0);
    });

    const titleEndAt = this.introConfig.titleRevealDelayMs + this.introConfig.titleRevealMs;
    orderedButtons.forEach((b, idx) => {
      const delay = titleEndAt + idx * this.introConfig.buttonStaggerMs;
      this.tweens.add({
        targets: [b.box, b.txt].filter(Boolean),
        y: `-=${this.introConfig.buttonMovePx}`,
        alpha: 1,
        duration: this.introConfig.uiFadeMs,
        ease: "Cubic.Out",
        delay,
      });
    });

    const remainingUi = this.menuUiElements.filter((el) => {
      if (el === this.titleText) return false;
      if (buttonTargets.includes(el)) return false;
      return true;
    });
    this.menuIntroUiFadeCall = this.time.delayedCall(titleEndAt + orderedButtons.length * this.introConfig.buttonStaggerMs - 40, () => {
      this.tweens.add({
        targets: remainingUi,
        alpha: 1,
        duration: this.introConfig.uiFadeMs,
        ease: "Sine.Out",
      });
    });

    this.menuIntroDoneCall = this.time.delayedCall(this.introConfig.totalMs, () => {
      this.menuIntroInProgress = false;
      this.setMenuInteractive(true);
      if (Platformer.Debug) Platformer.Debug.log("MenuScene", "Menu intro complete. UI interactive.");
    });
  }

  forceCompleteMenuIntro() {
    if (!this.menuIntroInProgress) return;
    this.menuIntroInProgress = false;

    if (this.menuIntroUiFadeCall) this.menuIntroUiFadeCall.remove(false);
    if (this.menuIntroDoneCall) this.menuIntroDoneCall.remove(false);
    this.menuIntroUiFadeCall = null;
    this.menuIntroDoneCall = null;

    const targets = [
      this.titleText,
      this.titleShadow,
      this.menuCard,
      this.comingSoonText,
      this.updateButton,
      this.updateButtonText,
      this.changeButton,
      this.changeButtonText,
      this.changePanel,
      this.changePanelTitle,
      this.changePanelBody,
      this.versionInfoText,
    ];
    Object.values(this.menuButtons).forEach((b) => {
      if (!b) return;
      targets.push(b.glow, b.box, b.txt);
    });
    this.tweens.killTweensOf(targets.filter(Boolean));
    if (this.introGlow) this.tweens.killTweensOf(this.introGlow);

    this.layoutMenu();
    this.setMenuUiVisible(true);
    this.setMenuInteractive(true);
    if (Platformer.Debug) Platformer.Debug.warn("MenuScene", "Intro auto-completed due to resize.");
  }

  createPrettyBackdrop() {
    const w = this.scale.width;
    const h = this.scale.height;
    const orbA = this.add.circle(w * 0.78, h * 0.22, 150, this.introConfig.glowCyan, 0.11)
      .setBlendMode(Phaser.BlendModes.ADD)
      .setDepth(2);
    const orbB = this.add.circle(w * 0.2, h * 0.3, 110, this.introConfig.glowPink, 0.1)
      .setBlendMode(Phaser.BlendModes.ADD)
      .setDepth(2);
    this.bgOrbs = [orbA, orbB];
    this.bgOrbs.forEach((orb, idx) => {
      this.tweens.add({
        targets: orb,
        alpha: { from: orb.alpha * 0.8, to: orb.alpha * 1.35 },
        scale: { from: 0.88 + idx * 0.08, to: 1.12 + idx * 0.12 },
        duration: 2800 + idx * 800,
        yoyo: true,
        repeat: -1,
        ease: "Sine.InOut",
      });
    });
  }

  normalizeReleaseNotes(rawText) {
    const text = String(rawText || "").replace(/\r/g, "").trim();
    const isPlaceholder = text.toLowerCase() === "none" || text.toLowerCase() === "null" || text === "-";
    if (!text || isPlaceholder) {
      return "Changelog unavailable for this check.\n\nOpen GitHub Releases for full patch notes.";
    }

    const withoutTail = text
      .replace(/\*\*?\s*full\s*changelog\s*\*?\s*:?\s*[\s\S]*$/i, "")
      .replace(/full\s*changelog\s*:?\s*[\s\S]*$/i, "")
      .trim();

    const lines = withoutTail
      .split("\n")
      .filter((line) => !/full\s*changelog/i.test(line))
      .filter((line) => !/github\.com\/.+\/compare\//i.test(line))
      .filter((line) => !/github\.com\/.+\/releases\/download\//i.test(line))
      .filter((line) => !/^\s*https?:\/\/\S+\s*$/i.test(line))
      .map((line) => line.replace(/https?:\/\/\S+/g, ""))
      .map((line) => line.length > 68 ? `${line.slice(0, 68)}...` : line)
      .filter((line) => line.trim().length > 0);

    const compact = lines.join("\n").trim();
    const capped = compact.length > 460 ? `${compact.slice(0, 460)}\n...` : compact;
    return capped || "Changelog unavailable for this check.\n\nOpen GitHub Releases for full patch notes.";
  }

  setLatestChangesFromResult(result) {
    if (!result) return;
    const v = result.latestVersion ? String(result.latestVersion) : "";
    const notes = this.normalizeReleaseNotes(result.releaseNotes || "");
    this.latestReleaseTag = v;
    this.latestReleaseNotes = v ? `Release ${v}\n\n${notes}` : notes;
    if (this.changePanelBody) this.changePanelBody.setText(this.latestReleaseNotes);
  }

  showCredits() {
    if (Platformer.Debug) Platformer.Debug.log("MenuScene", "Credits opened.");
    const cx = this.scale.width / 2;
    const cy = this.scale.height / 2;
    const back = this.add.rectangle(cx, cy, 640, 250, 0x0f172a, 0.88)
      .setStrokeStyle(2, 0x94a3b8)
      .setDepth(30)
      .setInteractive();
    const txt = this.add.text(cx, cy - 10,
      "Credits\nCode + Design: Robin + Codex\nFramework: Phaser 3\n\nClick panel to close", {
        fontFamily: "Consolas",
        fontSize: "28px",
        color: "#e2e8f0",
        align: "center",
      }
    ).setOrigin(0.5).setDepth(31);

    back.on("pointerdown", () => {
      back.destroy();
      txt.destroy();
      if (Platformer.Debug) Platformer.Debug.log("MenuScene", "Credits closed.");
    });
  }

  handleExit() {
    if (Platformer.Debug) Platformer.Debug.log("MenuScene", "Exit requested.");
    if (window.pywebview && window.pywebview.api && typeof window.pywebview.api.exit_app === "function") {
      window.pywebview.api.exit_app();
      return;
    }

    const hint = this.add.text(this.scale.width / 2, this.scale.height - 36,
      "Exit is disabled in browser. Close tab/window.", {
        fontFamily: "Consolas",
        fontSize: "20px",
        color: "#0f172a",
        stroke: "#f8fafc",
        strokeThickness: 4,
      }
    ).setOrigin(0.5);

    this.time.delayedCall(2200, () => hint.destroy());
  }

  setupMenuMusic() {
    const settings = Platformer.Settings.current.audio;
    const volume = (settings.master / 100) * (settings.music / 100);

    this.sound.stopByKey("pause-bgm");
    if (Platformer.pauseMusicHtml) {
      Platformer.pauseMusicHtml.pause();
      Platformer.pauseMusicHtml.currentTime = 0;
      Platformer.pauseMusicHtml = null;
    }

    if (Platformer.gameMusic) {
      Platformer.gameMusic.stop();
      Platformer.gameMusic = null;
    }
    if (Platformer.gameMusicHtml) {
      Platformer.gameMusicHtml.pause();
      Platformer.gameMusicHtml.currentTime = 0;
      Platformer.gameMusicHtml = null;
    }

    const wirePlayback = () => {
      this.menuMusic = this.sound.get("menu-bgm");
      if (!this.menuMusic) {
        try {
          this.menuMusic = this.sound.add("menu-bgm", { loop: true, volume });
        } catch (_e) {
          return;
        }
      } else {
        this.menuMusic.setVolume(volume);
        this.menuMusic.setLoop(true);
      }

      const tryPlay = () => {
        if (!this.menuMusic) return;
        if (settings.muteWhenUnfocused && document.hidden) return;
        if (this.menuMusic.isPlaying) return;
        try {
          this.menuMusic.play();
        } catch (_e) {
          // Autoplay restrictions are expected; user input handler below retries.
        }
      };

      this.input.once("pointerdown", tryPlay);
      this.input.keyboard.once("keydown", tryPlay);
      tryPlay();
    };

    // If HTML fallback is already active, just update its volume and keep playing.
    if (Platformer.menuMusicHtml) {
      this.menuMusicHtml = Platformer.menuMusicHtml;
      this.menuMusicHtml.volume = Phaser.Math.Clamp(volume, 0, 1);
      return;
    }

    if (this.cache.audio.exists("menu-bgm")) {
      wirePlayback();
      return;
    }

    this.load.audio("menu-bgm", "assets/nickpanek-energetic-chiptune-video-game-music-platformer-8-bit-318348.mp3");
    this.load.once("complete", wirePlayback);
    this.load.once("loaderror", () => {
      this.setupHtmlAudioFallback(volume, settings);
    });
    this.load.start();
  }

  setupHtmlAudioFallback(volume, settings) {
    try {
      if (Platformer.menuMusicHtml) {
        this.menuMusicHtml = Platformer.menuMusicHtml;
        this.menuMusicHtml.volume = Phaser.Math.Clamp(volume, 0, 1);
        return;
      }

      this.menuMusicHtml = new Audio("assets/nickpanek-energetic-chiptune-video-game-music-platformer-8-bit-318348.mp3");
      Platformer.menuMusicHtml = this.menuMusicHtml;
      this.menuMusicHtml.loop = true;
      this.menuMusicHtml.volume = Phaser.Math.Clamp(volume, 0, 1);

      const tryPlay = () => {
        if (!this.menuMusicHtml) return;
        if (settings.muteWhenUnfocused && document.hidden) return;
        this.menuMusicHtml.play().catch(() => {});
      };

      this.input.once("pointerdown", tryPlay);
      this.input.keyboard.once("keydown", tryPlay);
      tryPlay();
    } catch (_e) {
      // Keep menu functional with no music.
    }
  }

  stopMenuMusic() {
    if (this.menuMusic && this.menuMusic.isPlaying) {
      this.menuMusic.stop();
    }
    if (this.menuMusicHtml) {
      this.menuMusicHtml.pause();
      this.menuMusicHtml.currentTime = 0;
      this.menuMusicHtml = null;
    }
    if (Platformer.menuMusicHtml) {
      Platformer.menuMusicHtml.pause();
      Platformer.menuMusicHtml.currentTime = 0;
      Platformer.menuMusicHtml = null;
    }
  }

  update(_time, delta) {
    if (!this.introLines || this.introLines.length === 0) return;
    const w = this.scale.width;
    const dt = Math.max(0.001, delta / 1000);
    this.introLines.forEach((line) => {
      if (!line || !line.active) return;
      line.x -= line.introSpeed * line.introParallax * dt;
      if (line.x < -line.width - 10) {
        line.x = w + Phaser.Math.Between(10, 80);
      }
    });
    const t = _time * 0.001;
    if (this.bgOrbs && this.bgOrbs.length === 2) {
      this.bgOrbs[0].x = this.scale.width * 0.78 + Math.cos(t * 0.6) * 16;
      this.bgOrbs[1].x = this.scale.width * 0.2 + Math.sin(t * 0.75) * 18;
    }
    this.updateMenuMiniStage(delta);
  }

  updateMenuMiniStage(delta) {
    if (!this.menuRunner || !this.menuStage || !this.menuStage.lane) return;
    const dt = Math.max(0.001, delta / 1000);
    const lane = this.menuStage.lane;
    const minX = lane.x + 26;
    const maxX = lane.x + lane.width - 26;

    if (!Number.isFinite(this.menuRunner.menuX)) this.menuRunner.menuX = minX + 40;
    this.menuRunner.menuX += this.menuRunnerFace * this.menuRunnerSpeed * dt;
    if (this.menuRunner.menuX <= minX) {
      this.menuRunner.menuX = minX;
      this.menuRunnerFace = 1;
    } else if (this.menuRunner.menuX >= maxX) {
      this.menuRunner.menuX = maxX;
      this.menuRunnerFace = -1;
    }

    this.menuRunnerJumpCooldown -= delta;
    this.menuRunnerDamageCooldown -= delta;
    this.menuRunnerActionTimer -= delta;
    const target = this.menuEnemies.find((e) => {
      if (!e || !e.alive) return false;
      const dx = e.menuX - this.menuRunner.menuX;
      if (Math.abs(dx) > 120) return false;
      return dx * this.menuRunnerFace > 0;
    });
    const grounded = this.menuRunner.y >= this.menuRunnerGroundY - 0.5;
    const freestyleJump = grounded && this.menuRunnerActionTimer <= 0 && this.menuRunnerJumpCooldown <= 0 && Phaser.Math.Between(0, 100) < 12;
    if ((target || freestyleJump) && grounded && this.menuRunnerJumpCooldown <= 0) {
      this.menuRunnerVy = this.menuRunnerJumpVy;
      this.menuRunnerJumpCooldown = target ? 520 : 900;
      this.menuRunnerActionTimer = Phaser.Math.Between(650, 1300);
    }

    this.menuRunnerVy += this.menuRunnerGravity * dt;
    this.menuRunner.y += this.menuRunnerVy * dt;
    if (this.menuRunner.y > this.menuRunnerGroundY) {
      this.menuRunner.y = this.menuRunnerGroundY;
      this.menuRunnerVy = 0;
    }

    this.menuRunner.setFlipX(this.menuRunnerFace < 0);
    if (this.menuRunnerVy < -30) this.menuRunner.setTexture(this.textureOr("player-jump", "player"));
    else if (this.menuRunnerVy > 70 && this.menuRunner.y < this.menuRunnerGroundY) this.menuRunner.setTexture(this.textureOr("player-jump", "player"));
    else this.menuRunner.setTexture(this.textureOr(Math.floor(this.time.now / 130) % 2 === 0 ? "player-run-1" : "player-run-2", "player"));
    this.menuRunner.x = this.menuRunner.menuX;
    if (this.time.now < this.menuRunnerDamageFlashUntil) {
      const blinkOn = Math.floor(this.time.now / 70) % 2 === 0;
      if (blinkOn) this.menuRunner.setTint(0xff4d4d);
      else this.menuRunner.clearTint();
    } else {
      this.menuRunner.clearTint();
    }

    this.menuEnemies.forEach((enemy) => {
      if (!enemy) return;
      if (!enemy.alive) {
        if (this.time.now >= enemy.respawnAt) {
          enemy.alive = true;
          enemy.setVisible(true);
          enemy.setAlpha(1);
          enemy.setScale(1, 1);
          enemy.y = this.menuRunnerGroundY + 2;
          enemy.menuX = Phaser.Math.Between(minX + 40, maxX - 40);
          enemy.menuDir = Phaser.Math.Between(0, 1) ? 1 : -1;
        }
        return;
      }

      enemy.menuX += enemy.menuDir * enemy.menuSpeed * dt;
      if (enemy.menuX <= minX + 18) {
        enemy.menuX = minX + 18;
        enemy.menuDir = 1;
      } else if (enemy.menuX >= maxX - 18) {
        enemy.menuX = maxX - 18;
        enemy.menuDir = -1;
      }
      enemy.x = enemy.menuX;
      enemy.setFlipX(enemy.menuDir < 0);
      const stomp = Math.abs(this.menuRunner.x - enemy.x) < 18
        && this.menuRunner.y < enemy.y - 10
        && this.menuRunnerVy > 60;
      if (stomp) {
        enemy.alive = false;
        enemy.respawnAt = this.time.now + Phaser.Math.Between(1300, 2200);
        this.tweens.add({
          targets: enemy,
          scaleX: 1.35,
          scaleY: 0.45,
          alpha: 0.25,
          duration: 120,
          onComplete: () => {
            if (enemy && enemy.active) enemy.setVisible(false);
          },
        });
        const puff = this.add.circle(enemy.x, enemy.y - 6, 6, 0xffffff, 0.95).setDepth(8.25).setBlendMode(Phaser.BlendModes.ADD);
        this.menuStage.add(puff);
        this.tweens.add({
          targets: puff,
          scale: 3.1,
          alpha: 0,
          duration: 260,
          ease: "Cubic.Out",
          onComplete: () => puff.destroy(),
        });
        this.menuRunnerVy = -190;
        return;
      }

      const sideHit = Math.abs(this.menuRunner.x - enemy.x) < 22
        && Math.abs(this.menuRunner.y - enemy.y) < 24
        && this.menuRunnerDamageCooldown <= 0;
      if (sideHit) {
        this.menuRunnerDamageCooldown = 700;
        this.menuRunnerDamageFlashUntil = this.time.now + 420;
        this.menuRunnerVy = -120;
        this.menuRunnerFace = this.menuRunner.x < enemy.x ? -1 : 1;
        this.menuRunner.menuX += this.menuRunnerFace * 20;
        this.menuRunner.menuX = Phaser.Math.Clamp(this.menuRunner.menuX, minX, maxX);
      }
    });
    this.saveMenuMiniStageState();
  }

  textureOr(textureKey, fallbackKey) {
    if (textureKey && this.textures.exists(textureKey)) return textureKey;
    if (fallbackKey && this.textures.exists(fallbackKey)) return fallbackKey;
    return "__WHITE";
  }

  shutdown() {
    // Keep menu music alive across Menu <-> Options transitions.
    this.saveMenuMiniStageState();
    if (this.onResize) {
      this.scale.off("resize", this.onResize);
      this.onResize = null;
    }
    if (this.introParticles) {
      this.introParticles.destroy();
      this.introParticles = null;
    }
    if (this.introFx) {
      this.introFx.destroy(true);
      this.introFx = null;
    }
    if (this.introGlow) {
      this.introGlow.destroy();
      this.introGlow = null;
    }
    if (this.menuStage) {
      this.menuStage.destroy(true);
      this.menuStage = null;
    }
    this.menuRunner = null;
    this.menuEnemies = [];
    this.bgOrbs = [];
    this.introLines = [];
  }
};
  /* <<< scenes/menu-scene.js */

  /* >>> scenes/intro-scene.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.IntroScene = class extends Phaser.Scene {
  constructor() {
    super("IntroScene");
    this.slideIndex = 0;
    this.slides = [];
  }

  create() {
    const cx = this.scale.width / 2;
    const cy = this.scale.height / 2;
    const textScale = Platformer.Settings.textScale();

    this.slides = [
      {
        title: "Mission Briefing",
        body: "Complete 4 levels by collecting 10 coins each.\nBeat the timer and use checkpoints to survive.",
      },
      {
        title: "Hazards + Enemies",
        body: "Laser turrets launch fireballs.\nEnemy types per level: Walker, Hopper, Dasher, Tank.\nStomp enemies from above to defeat.",
      },
      {
        title: "Controls",
        body: "Move: Left/Right\nJump: Jump key (rebindable)\nDash: Dash key (burst + enemy break)\nAttack: Attack key (close-range hit)\nPause: Pause key\nTip: F2 = demo instant win",
      },
      {
        title: "Coin Rewards",
        body: "3 Coins: +1 Health\n6 Coins: +12s Time\n9 Coins: +1 Shield block\n10 Coins: Level clear",
      },
    ];

    this.add.rectangle(cx, cy, this.scale.width, this.scale.height, 0x020617, 0.55);

    this.add.text(cx, 70, "LEVEL PREVIEW", {
      fontFamily: "Verdana",
      fontSize: `${Math.round(42 * textScale)}px`,
      color: "#f8fafc",
      stroke: "#0f172a",
      strokeThickness: 6,
    }).setOrigin(0.5);

    this.panel = this.add.rectangle(cx, cy + 10, 760, 320, 0x0f172a, 0.58)
      .setStrokeStyle(2, 0x94a3b8, 0.9);

    this.titleText = this.add.text(cx, cy - 86, "", {
      fontFamily: "Verdana",
      fontSize: `${Math.round(34 * textScale)}px`,
      color: "#f8fafc",
      stroke: "#111827",
      strokeThickness: 4,
    }).setOrigin(0.5);

    this.bodyText = this.add.text(cx, cy - 4, "", {
      fontFamily: "Consolas",
      fontSize: `${Math.round(24 * textScale)}px`,
      color: "#e2e8f0",
      align: "center",
      lineSpacing: 10,
    }).setOrigin(0.5);

    this.pageText = this.add.text(cx - 340, cy + 136, "", {
      fontFamily: "Consolas",
      fontSize: `${Math.round(18 * textScale)}px`,
      color: "#cbd5e1",
    }).setOrigin(0, 0.5);

    this.nextBtn = this.add.rectangle(cx + 280, cy + 136, 170, 44, 0x1d4ed8, 0.98)
      .setStrokeStyle(2, 0x93c5fd)
      .setInteractive({ useHandCursor: true });
    this.nextBtnText = this.add.text(cx + 280, cy + 136, "Next >", {
      fontFamily: "Consolas",
      fontSize: `${Math.round(25 * textScale)}px`,
      color: "#f8fafc",
    }).setOrigin(0.5);

    this.skipBtn = this.add.rectangle(cx + 90, cy + 136, 140, 44, 0x475569, 0.96)
      .setStrokeStyle(2, 0x94a3b8)
      .setInteractive({ useHandCursor: true });
    this.skipText = this.add.text(cx + 90, cy + 136, "Skip", {
      fontFamily: "Consolas",
      fontSize: `${Math.round(24 * textScale)}px`,
      color: "#f8fafc",
    }).setOrigin(0.5);

    this.nextBtn.on("pointerdown", () => this.next());
    this.skipBtn.on("pointerdown", () => this.startGame());

    this.input.keyboard.on("keydown-ENTER", () => this.next());
    this.input.keyboard.on("keydown-SPACE", () => this.next());
    this.input.keyboard.on("keydown-ESC", () => this.scene.start("MenuScene"));

    this.renderSlide();
  }

  renderSlide() {
    const s = this.slides[this.slideIndex];
    this.titleText.setText(s.title);
    this.bodyText.setText(s.body);
    this.pageText.setText(`Preview ${this.slideIndex + 1}/${this.slides.length}`);

    const isLast = this.slideIndex === this.slides.length - 1;
    this.nextBtn.setFillStyle(isLast ? 0x16a34a : 0x1d4ed8, 0.98);
    this.nextBtnText.setText(isLast ? "Start Game" : "Next >");
  }

  next() {
    if (this.slideIndex < this.slides.length - 1) {
      this.slideIndex += 1;
      this.renderSlide();
      return;
    }
    this.startGame();
  }

  startGame() {
    Platformer.Settings.current.convenience.introSeen = true;
    Platformer.Settings.save();

    Platformer.beeper.unlock();
    const difficulty = Platformer.Settings.current.gameplay.difficulty;
    const baseLives = difficulty === "easy" ? 3 : (difficulty === "hard" ? 1 : 2);

    if (this.scene.isActive("UIScene") || this.scene.isPaused("UIScene")) {
      this.scene.stop("UIScene");
    }
    if (this.scene.isActive("GameScene") || this.scene.isPaused("GameScene")) {
      this.scene.stop("GameScene");
    }

    this.registry.set("coins", 0);
    this.registry.set("health", 3);
    this.registry.set("lives", baseLives);
    this.registry.set("level", 1);
    this.scene.start("GameScene", { level: 1 });
    this.scene.launch("UIScene");
  }
};
  /* <<< scenes/intro-scene.js */

  /* >>> scenes/options-scene.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.OptionsScene = class extends Phaser.Scene {
  constructor() {
    super("OptionsScene");
    this.awaitingControl = null;
    this.rebindHint = null;
    this.dom = null;
    this.boundKeydown = null;
    this.returnTo = "menu";
    this.backBtn = null;
    this.bgSky = null;
    this.bgMid = null;
    this.bgGround = null;
    this.bgAccentTop = null;
    this.bgAccentBottom = null;
    this.bgOrbs = [];
    this.bgLines = [];
    this.onResize = null;
    this.overlayShade = null;
    this.titleText = null;
    this.hintText = null;
    this.backBtnText = null;
    this.domWrap = null;
    this.optScrollEl = null;
    this.boundDomWheel = null;
  }

  init(data) {
    this.returnTo = data && data.returnTo ? data.returnTo : "menu";
    if (Platformer.Debug) Platformer.Debug.log("OptionsScene", `Opened (returnTo=${this.returnTo}).`);
  }

  create() {
    const s = Platformer.Settings.current;
    const cx = this.scale.width / 2;
    const cy = this.scale.height / 2;

    if (this.returnTo === "menuOverlay") {
      // Menu scene stays running underneath for a live transparent backdrop.
      this.overlayShade = this.add.rectangle(cx, cy, this.scale.width, this.scale.height, 0x020617, 0.42)
        .setDepth(0)
        .setInteractive();
    } else {
      this.createMenuLikeBackdrop();
      this.layoutBackdrop();
    }
    this.titleText = this.add.text(cx, 48, "OPTIONS", {
      fontFamily: "Verdana",
      fontSize: "42px",
      color: "#f8fafc",
      stroke: "#0f172a",
      strokeThickness: 6,
    }).setOrigin(0.5);

    this.rebindHint = this.add.text(cx, 92, "Click a key button to rebind. Press ESC to return.", {
      fontFamily: "Consolas",
      fontSize: "18px",
      color: "#cbd5e1",
    }).setOrigin(0.5);

    const wrap = document.createElement("div");
    wrap.style.width = "min(1180px, 94vw)";
    wrap.style.maxHeight = "74vh";
    wrap.style.overflowY = "hidden";
    wrap.style.padding = "6px";
    wrap.style.display = "flex";
    wrap.style.flexDirection = "column";
    wrap.style.position = "relative";
    wrap.style.fontFamily = "Consolas, monospace";
    wrap.style.color = "#e2e8f0";

    const css = `
      <style>
        .opt-grid { display:grid; grid-template-columns: repeat(2, minmax(340px, 1fr)); gap: 12px; }
        .opt-scroll {
          overflow-y:auto;
          flex:1 1 auto;
          min-height: 0;
          height: 100%;
          padding-right: 10px;
          padding-bottom: 84px;
          box-sizing: border-box;
        }
        .opt-card { background: rgba(15,23,42,0.82); border:2px solid #334155; border-radius:10px; padding: 12px; box-shadow: 0 6px 18px rgba(2,6,23,0.35); }
        .opt-title { margin: 0 0 10px 0; color:#f8fafc; font-size: 22px; letter-spacing: 0.5px; }
        .opt-row { display:flex; justify-content:space-between; align-items:center; gap:10px; margin: 8px 0; }
        .opt-row > span { color:#cbd5e1; }
        .opt-card select, .opt-card input[type="text"], .opt-card button {
          background:#1e293b; color:#e2e8f0; border:1px solid #475569; border-radius:6px; padding: 4px 8px; font-family:inherit;
        }
        .opt-card input[type="range"] { width: 170px; }
        .opt-actions {
          display:flex; gap:10px; justify-content:flex-end;
          position: absolute; left: 8px; right: 8px; bottom: 8px; z-index: 5;
          background: rgba(2,6,23,0.92); border: 1px solid #334155; border-radius: 8px; padding: 10px;
        }
        .opt-actions button { background:#0f172a; color:#f8fafc; border:2px solid #64748b; border-radius:8px; padding:8px 12px; cursor:pointer; }
        .opt-actions #saveBack { border-color:#22d3ee; }
        @media (max-width: 900px) { .opt-grid { grid-template-columns: 1fr; } }
      </style>
    `;
    const cardStart = (title) => `<section class="opt-card"><h3 class="opt-title">${title}</h3>`;
    const cardEnd = () => `</section>`;
    const row = (label, control) => `<div class="opt-row"><span>${label}</span><span>${control}</span></div>`;

    wrap.innerHTML = [
      css,
      `<div class="opt-scroll"><div class="opt-grid">`,
      cardStart("Gameplay"),
      row("Difficulty", `<select id="difficulty"><option value="easy">Easy</option><option value="normal">Normal</option><option value="hard">Hard</option></select>`),
      cardEnd(),

      cardStart("Controls"),
      row("Left", `<button data-bind="left">${s.controls.left}</button>`),
      row("Right", `<button data-bind="right">${s.controls.right}</button>`),
      row("Jump", `<button data-bind="jump">${s.controls.jump}</button>`),
      row("Dash", `<button data-bind="dash">${s.controls.dash}</button>`),
      row("Attack", `<button data-bind="attack">${s.controls.attack}</button>`),
      row("Interact", `<button data-bind="interact">${s.controls.interact}</button>`),
      row("Pause", `<button data-bind="pause">${s.controls.pause}</button>`),
      cardEnd(),

      cardStart("Accessibility"),
      row("Text size", `<select id="textSize"><option value="small">Small</option><option value="medium">Medium</option><option value="large">Large</option></select>`),
      row("Colorblind mode", `<select id="colorblindMode"><option value="off">Off</option><option value="protanopia">Protanopia</option><option value="deuteranopia">Deuteranopia</option><option value="tritanopia">Tritanopia</option></select>`),
      row("Reduce screen shake", `<input id="reduceScreenShake" type="range" min="0" max="100" step="1" /><span id="reduceScreenShakeVal"></span>`),
      row("Reduced motion", `<select id="reducedMotion"><option value="off">Off</option><option value="on">On</option></select>`),
      row("Flash reduction", `<select id="flashReduction"><option value="off">Off</option><option value="on">On</option></select>`),
      row("Subtitles", `<select id="subtitles"><option value="off">Off</option><option value="on">On</option></select>`),
      row("Audio cues", `<select id="audioCues"><option value="off">Off</option><option value="on">On</option></select>`),
      cardEnd(),

      cardStart("Video"),
      row("Fullscreen", `<select id="fullscreen"><option value="off">Off</option><option value="on">On</option></select>`),
      row("Resolution scale", `<input id="resolutionScale" type="range" min="50" max="100" step="1" /><span id="resolutionScaleVal"></span>`),
      row("Pixel-perfect", `<select id="pixelPerfect"><option value="off">Off</option><option value="on">On</option></select>`),
      row("VSync", `<select id="vsync"><option value="off">Off</option><option value="on">On</option></select>`),
      row("FPS cap", `<select id="fpsCap"><option value="30">30</option><option value="60">60</option><option value="unlimited">Unlimited</option></select>`),
      row("Camera smoothing", `<input id="cameraSmoothing" type="range" min="0" max="100" step="1" /><span id="cameraSmoothingVal"></span>`),
      row("Brightness", `<input id="brightness" type="range" min="0.8" max="1.2" step="0.01" /><span id="brightnessVal"></span>`),
      cardEnd(),

      cardStart("Audio"),
      row("Master volume", `<input id="master" type="range" min="0" max="100" step="1" /><span id="masterVal"></span>`),
      row("Music volume", `<input id="music" type="range" min="0" max="100" step="1" /><span id="musicVal"></span>`),
      row("SFX volume", `<input id="sfx" type="range" min="0" max="100" step="1" /><span id="sfxVal"></span>`),
      row("UI volume", `<input id="ui" type="range" min="0" max="100" step="1" /><span id="uiVal"></span>`),
      row("Dynamic range", `<select id="dynamicRange"><option value="night">Night</option><option value="normal">Normal</option><option value="wide">Wide</option></select>`),
      row("Mute when unfocused", `<select id="muteWhenUnfocused"><option value="off">Off</option><option value="on">On</option></select>`),
      cardEnd(),

      cardStart("Save / Convenience"),
      row("Auto-save", `<select id="autoSave"><option value="off">Off</option><option value="on">On</option></select>`),
      row("Checkpoint frequency", `<select id="checkpointFrequency"><option value="sparse">Sparse</option><option value="standard">Standard</option><option value="frequent">Frequent</option></select>`),
      row("Speedrun mode", `<select id="speedrunMode"><option value="off">Off</option><option value="on">On</option></select>`),
      cardEnd(),

      cardStart("Updates"),
      row("Online update check", `<select id="updatesEnabled"><option value="off">Off</option><option value="on">On</option></select>`),
      row("Auto update + restart", `<select id="autoUpdate"><option value="on">On</option><option value="off">Off</option></select>`),
      row("Update source", `<input id="updateSource" type="text" readonly style="opacity:0.85" />`),
      row("Current version", `<input id="currentVersion" type="text" readonly style="opacity:0.85" />`),
      cardEnd(),
      `</div></div>`,

      `<div class="opt-actions">`,
      `<button id="resetDefaults">Reset defaults</button>`,
      `<button id="saveBack">Save + Back</button>`,
      `</div>`,
    ].join("");

    this.domWrap = wrap;
    this.dom = this.add.dom(cx, cy + 28, wrap);
    this.backBtn = this.add.rectangle(96, 44, 156, 46, 0xdc2626, 0.98)
      .setStrokeStyle(3, 0xfee2e2)
      .setOrigin(0, 0.5)
      .setScrollFactor(0)
      .setDepth(40)
      .setInteractive({ useHandCursor: true });
    this.backBtnText = this.add.text(96, 44, "< BACK", {
      fontFamily: "Consolas",
      fontSize: "28px",
      color: "#ffffff",
      stroke: "#450a0a",
      strokeThickness: 5,
    }).setOrigin(0, 0.5).setDepth(41);
    this.backBtn.on("pointerdown", async () => {
      await applyAndSave();
      if (Platformer.Debug) Platformer.Debug.log("OptionsScene", "Back button pressed.");
      this.goBack();
    });

    const val = (id) => wrap.querySelector(`#${id}`);
    this.optScrollEl = wrap.querySelector(".opt-scroll");
    if (this.optScrollEl) {
      this.boundDomWheel = (event) => {
        this.optScrollEl.scrollTop += event.deltaY;
        event.preventDefault();
        event.stopPropagation();
      };
      this.optScrollEl.addEventListener("wheel", this.boundDomWheel, { passive: false });
    }
    const setSelect = (id, v) => { val(id).value = v; };
    const setRange = (id, v, suffix = "%") => {
      val(id).value = String(v);
      const txt = val(`${id}Val`);
      if (txt) txt.textContent = `${v}${suffix}`;
    };

    setSelect("difficulty", s.gameplay.difficulty);
    setSelect("textSize", s.accessibility.textSize);
    setSelect("colorblindMode", s.accessibility.colorblindMode);
    setRange("reduceScreenShake", s.accessibility.reduceScreenShake);
    setSelect("reducedMotion", s.accessibility.reducedMotion ? "on" : "off");
    setSelect("flashReduction", s.accessibility.flashReduction ? "on" : "off");
    setSelect("subtitles", s.accessibility.subtitles ? "on" : "off");
    setSelect("audioCues", s.accessibility.audioCues ? "on" : "off");

    setSelect("fullscreen", s.video.fullscreen ? "on" : "off");
    setRange("resolutionScale", s.video.resolutionScale);
    setSelect("pixelPerfect", s.video.pixelPerfect ? "on" : "off");
    setSelect("vsync", s.video.vsync ? "on" : "off");
    setSelect("fpsCap", s.video.fpsCap);
    setRange("cameraSmoothing", s.video.cameraSmoothing);
    setRange("brightness", s.video.brightness.toFixed(2), "");

    setRange("master", s.audio.master);
    setRange("music", s.audio.music);
    setRange("sfx", s.audio.sfx);
    setRange("ui", s.audio.ui);
    setSelect("dynamicRange", s.audio.dynamicRange);
    setSelect("muteWhenUnfocused", s.audio.muteWhenUnfocused ? "on" : "off");

    setSelect("autoSave", s.convenience.autoSave ? "on" : "off");
    setSelect("checkpointFrequency", s.convenience.checkpointFrequency);
    setSelect("speedrunMode", s.convenience.speedrunMode ? "on" : "off");
    setSelect("updatesEnabled", s.updates.enabled ? "on" : "off");
    setSelect("autoUpdate", s.updates.autoUpdate === false ? "off" : "on");
    val("updateSource").value = s.updates.source || "GitHub Releases";
    val("currentVersion").value = (Platformer.BUILD_VERSION && String(Platformer.BUILD_VERSION).trim()) || s.updates.currentVersion || "1.0.0";

    ["reduceScreenShake", "resolutionScale", "cameraSmoothing", "brightness", "master", "music", "sfx", "ui"].forEach((id) => {
      val(id).addEventListener("input", () => {
        const suffix = id === "brightness" ? "" : "%";
        val(`${id}Val`).textContent = `${val(id).value}${suffix}`;
      });
    });

    wrap.querySelectorAll("[data-bind]").forEach((btn) => {
      btn.addEventListener("click", () => {
        this.awaitingControl = btn.getAttribute("data-bind");
        if (Platformer.Debug) Platformer.Debug.log("OptionsScene.rebind", `Awaiting key for ${this.awaitingControl}`);
        this.rebindHint.setText(`Press a key for ${this.awaitingControl.toUpperCase()}...`);
      });
    });

    const applyAndSave = async () => {
      const c = Platformer.Settings.current;
      c.gameplay.difficulty = val("difficulty").value;

      c.accessibility.textSize = val("textSize").value;
      c.accessibility.colorblindMode = val("colorblindMode").value;
      c.accessibility.reduceScreenShake = Number(val("reduceScreenShake").value);
      c.accessibility.reducedMotion = val("reducedMotion").value === "on";
      c.accessibility.flashReduction = val("flashReduction").value === "on";
      c.accessibility.subtitles = val("subtitles").value === "on";
      c.accessibility.audioCues = val("audioCues").value === "on";

      c.video.fullscreen = val("fullscreen").value === "on";
      c.video.resolutionScale = Number(val("resolutionScale").value);
      c.video.pixelPerfect = val("pixelPerfect").value === "on";
      c.video.vsync = val("vsync").value === "on";
      c.video.fpsCap = val("fpsCap").value;
      c.video.cameraSmoothing = Number(val("cameraSmoothing").value);
      c.video.brightness = Number(val("brightness").value);

      c.audio.master = Number(val("master").value);
      c.audio.music = Number(val("music").value);
      c.audio.sfx = Number(val("sfx").value);
      c.audio.ui = Number(val("ui").value);
      c.audio.dynamicRange = val("dynamicRange").value;
      c.audio.muteWhenUnfocused = val("muteWhenUnfocused").value === "on";

      c.convenience.autoSave = val("autoSave").value === "on";
      c.convenience.checkpointFrequency = val("checkpointFrequency").value;
      c.convenience.speedrunMode = val("speedrunMode").value === "on";

      c.updates.enabled = val("updatesEnabled").value === "on";
      c.updates.autoUpdate = val("autoUpdate").value === "on";
      c.updates.source = "GitHub Releases";
      c.updates.currentVersion = (Platformer.BUILD_VERSION && String(Platformer.BUILD_VERSION).trim()) || "1.0.0";
      c.updates.manifestUrl = "";
      c.updates.downloadUrl = "";

      await Platformer.Settings.save();
      if (Platformer.Debug) Platformer.Debug.log("OptionsScene", "Settings saved.");
      this.applyRuntimeVideoSettings();
    };

    wrap.querySelector("#saveBack").addEventListener("click", async () => {
      await applyAndSave();
      if (Platformer.Debug) Platformer.Debug.log("OptionsScene", "Save + Back pressed.");
      this.goBack();
    });

    wrap.querySelector("#resetDefaults").addEventListener("click", () => {
      Platformer.Settings.reset();
      if (Platformer.Debug) Platformer.Debug.warn("OptionsScene", "Settings reset to defaults.");
      this.scene.restart();
    });

    this.boundKeydown = (event) => {
      if (!this.awaitingControl) return;
      event.preventDefault();
      const key = this.normalizeKey(event);
      Platformer.Settings.current.controls[this.awaitingControl] = key;
      Platformer.Settings.save();
      const btn = wrap.querySelector(`[data-bind="${this.awaitingControl}"]`);
      if (btn) btn.textContent = key;
      if (Platformer.Debug) Platformer.Debug.log("OptionsScene.rebind", `${this.awaitingControl} -> ${key}`);
      this.rebindHint.setText(`${this.awaitingControl.toUpperCase()} bound to ${key}`);
      this.awaitingControl = null;
    };

    window.addEventListener("keydown", this.boundKeydown, true);
    this.events.once("shutdown", () => this.cleanup());
    if (this.returnTo !== "menuOverlay") {
      this.onResize = () => this.layoutOptions();
      this.scale.on("resize", this.onResize);
    } else {
      this.onResize = () => this.layoutOptions();
      this.scale.on("resize", this.onResize);
    }
    this.layoutOptions();

    this.input.keyboard.on("keydown-ESC", async () => {
      if (this.awaitingControl) {
        this.awaitingControl = null;
        if (Platformer.Debug) Platformer.Debug.log("OptionsScene.rebind", "Rebind cancelled with ESC.");
        this.rebindHint.setText("Click a key button to rebind. Press ESC to return.");
        return;
      }
      await applyAndSave();
      if (Platformer.Debug) Platformer.Debug.log("OptionsScene", "ESC save + back.");
      this.goBack();
    });
  }

  createMenuLikeBackdrop() {
    const w = this.scale.width;
    const h = this.scale.height;
    this.bgSky = this.add.rectangle(0, 0, w, h, 0x081336, 0.62).setOrigin(0, 0);
    this.bgMid = this.add.rectangle(0, 0, w, 220, 0x132a56, 0.52).setOrigin(0, 0);
    this.bgGround = this.add.rectangle(0, 0, w, 120, 0x0b6f49, 0.46).setOrigin(0, 0);
    this.bgAccentTop = this.add.rectangle(0, 0, w, Math.round(h * 0.42), 0x1e3a8a, 0.16).setOrigin(0, 0);
    this.bgAccentBottom = this.add.rectangle(0, 0, w, Math.round(h * 0.2), 0x34d399, 0.13).setOrigin(0, 0);

    const orbA = this.add.circle(w * 0.78, h * 0.22, 150, 0x53e0ff, 0.08).setBlendMode(Phaser.BlendModes.ADD);
    const orbB = this.add.circle(w * 0.2, h * 0.3, 110, 0xff71c7, 0.07).setBlendMode(Phaser.BlendModes.ADD);
    this.bgOrbs = [orbA, orbB];

    this.bgLines = [];
    for (let i = 0; i < 10; i += 1) {
      const line = this.add.rectangle(
        Phaser.Math.Between(0, w),
        Phaser.Math.Between(40, h - 80),
        Phaser.Math.Between(70, 150),
        2,
        i % 3 === 0 ? 0xff71c7 : 0x53e0ff,
        0.18
      ).setOrigin(0, 0.5);
      line.moveSpeed = Phaser.Math.FloatBetween(26, 62);
      this.bgLines.push(line);
    }
  }

  layoutBackdrop() {
    if (!this.bgSky) return;
    const w = this.scale.width;
    const h = this.scale.height;
    const cy = h / 2;
    this.bgSky.setSize(w, h).setPosition(0, 0);
    this.bgMid.setSize(w, 220).setPosition(0, cy + 160);
    this.bgGround.setSize(w, 120).setPosition(0, cy + 220);
    this.bgAccentTop.setSize(w, Math.round(h * 0.42)).setPosition(0, 0);
    this.bgAccentBottom.setSize(w, Math.round(h * 0.2)).setPosition(0, h - Math.round(h * 0.24));
  }

  layoutOptions() {
    const w = this.scale.width;
    const h = this.scale.height;
    const cx = w / 2;
    const cy = h / 2;
    this.layoutBackdrop();
    if (this.overlayShade) {
      this.overlayShade.setPosition(cx, cy).setSize(w, h);
    }
    if (this.titleText) this.titleText.setPosition(cx, 48);
    if (this.rebindHint) this.rebindHint.setPosition(cx, 92);

    if (this.domWrap) {
      const panelH = Math.floor(Math.max(320, h * 0.74));
      this.domWrap.style.width = `${Math.floor(Math.min(1180, w * 0.94))}px`;
      this.domWrap.style.maxHeight = `${panelH}px`;
      this.domWrap.style.height = `${panelH}px`;
    }
    if (this.optScrollEl) {
      this.optScrollEl.style.height = "100%";
      this.optScrollEl.style.maxHeight = "100%";
      this.optScrollEl.style.overflowY = "auto";
    }
    const topY = 130;
    const panelH = Math.floor(Math.max(320, h * 0.74));
    const domY = Math.min(cy + 28, topY + (panelH / 2));
    if (this.dom) {
      this.dom.setPosition(cx, domY);
      if (typeof this.dom.updateSize === "function") this.dom.updateSize();
    }

    if (this.backBtn) this.backBtn.setPosition(14, 44);
    if (this.backBtnText) this.backBtnText.setPosition(36, 44);
  }

  goBack() {
    if (this.returnTo === "menuOverlay") {
      const menuScene = this.scene.get("MenuScene");
      if (menuScene && typeof menuScene.setMenuInteractive === "function") {
        if (typeof menuScene.setMenuUiVisible === "function") menuScene.setMenuUiVisible(true);
        menuScene.setMenuInteractive(true);
      }
      if (Platformer.Debug) Platformer.Debug.log("OptionsScene", "Returning to live main menu overlay.");
      this.scene.stop();
      return;
    }
    if (this.returnTo === "pause") {
      if (Platformer.Debug) Platformer.Debug.log("OptionsScene", "Returning to pause menu.");
      this.scene.stop();
      this.game.events.emit("options-closed-to-pause");
      return;
    }
    if (Platformer.Debug) Platformer.Debug.log("OptionsScene", "Returning to main menu.");
    this.scene.start("MenuScene");
  }

  normalizeKey(event) {
    const k = (event.key || "").toUpperCase();
    if (k === " ") return "SPACE";
    if (k === "ESCAPE") return "ESC";
    if (k === "ARROWLEFT") return "LEFT";
    if (k === "ARROWRIGHT") return "RIGHT";
    if (k === "ARROWUP") return "UP";
    if (k === "ARROWDOWN") return "DOWN";
    if (k === "CONTROL") return "CTRL";
    return k;
  }

  applyRuntimeVideoSettings() {
    const s = Platformer.Settings.current.video;
    if (window.pywebview && window.pywebview.api && typeof window.pywebview.api.set_fullscreen === "function") {
      window.pywebview.api.set_fullscreen(!!s.fullscreen)
        .then((res) => {
          if (res && res.ok) {
            if (Platformer.Debug) Platformer.Debug.log("Options.fullscreen", `native fullscreen=${res.fullscreen}`);
          } else if (Platformer.Debug) {
            Platformer.Debug.warn("Options.fullscreen", (res && res.message) || "native fullscreen call failed");
          }
        })
        .catch((err) => {
          if (Platformer.Debug) Platformer.Debug.warn("Options.fullscreen", `native fullscreen error: ${err && err.message ? err.message : err}`);
        });
      return;
    }

    if (s.fullscreen && !this.scale.isFullscreen) {
      this.scale.startFullscreen();
      if (Platformer.Debug) Platformer.Debug.log("Options.fullscreen", "browser fullscreen start requested");
    }
    if (!s.fullscreen && this.scale.isFullscreen) {
      this.scale.stopFullscreen();
      if (Platformer.Debug) Platformer.Debug.log("Options.fullscreen", "browser fullscreen stop requested");
    }
  }

  shutdown() {
    this.cleanup();
  }

  cleanup() {
    if (this.returnTo === "menuOverlay") {
      const menuScene = this.scene.get("MenuScene");
      if (menuScene) {
        if (typeof menuScene.setMenuUiVisible === "function") menuScene.setMenuUiVisible(true);
        if (typeof menuScene.setMenuInteractive === "function") menuScene.setMenuInteractive(true);
      }
    }
    if (this.onResize) {
      this.scale.off("resize", this.onResize);
      this.onResize = null;
    }
    if (this.optScrollEl && this.boundDomWheel) {
      this.optScrollEl.removeEventListener("wheel", this.boundDomWheel);
    }
    this.boundDomWheel = null;
    this.optScrollEl = null;
    if (this.boundKeydown) {
      window.removeEventListener("keydown", this.boundKeydown, true);
      this.boundKeydown = null;
    }
  }

  update(time, delta) {
    const dt = Math.max(0.001, delta / 1000);
    const w = this.scale.width;
    this.bgLines.forEach((line) => {
      if (!line || !line.active) return;
      line.x -= line.moveSpeed * dt;
      if (line.x < -line.width - 10) line.x = w + Phaser.Math.Between(10, 80);
    });
    const t = time * 0.001;
    if (this.bgOrbs && this.bgOrbs.length === 2) {
      this.bgOrbs[0].x = this.scale.width * 0.78 + Math.cos(t * 0.6) * 16;
      this.bgOrbs[1].x = this.scale.width * 0.2 + Math.sin(t * 0.75) * 18;
    }
  }
};
  /* <<< scenes/options-scene.js */

  /* >>> scenes/game-scene.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.GameScene = class extends Phaser.Scene {
  constructor() {
    super("GameScene");
    this.solids = null;
    this.oneWays = null;
    this.hazards = null;
    this.coins = null;
    this.enemies = null;
    this.checkpoints = null;
    this.player = null;
    this.cursors = null;
    this.keys = null;
    this.respawnPoint = new Phaser.Math.Vector2(64, 64);
    this.lastOnGroundTime = 0;
    this.lastJumpPressedTime = -9999;
    this.isJumpHeld = false;
    this.jumpsUsed = 0;
    this.lastDamageTime = -9999;
    this.isDead = false;
    this.spawnPoint = new Phaser.Math.Vector2(64, 64);
    this.mapRows = [];
    this.mapWidth = 0;
    this.mapHeight = 0;
    this.levelComplete = false;
    this.parallax = [];
    this.lastEnemyEdgeCheckTime = 0;
    this.playerHealthBarBg = null;
    this.playerHealthBarFill = null;
    this.hazardProjectiles = null;
    this.hazardShooters = [];
    this.lastHazardShotAt = 0;
    this.projectileIntervalMs = 1200;
    this.projectileSpeed = 220;
    this.levelTimeRemainingMs = 90000;
    this.lastTickTime = 0;
    this.lastTimerSecond = -1;
    this.threatActive = false;
    this.idleAnimWarned = false;
    this.useImportedCharacter = false;
    this.diagLastAt = 0;
    this.diagCooldowns = {};
    this.facingDir = 1;
    this.isDashing = false;
    this.dashEndsAt = 0;
    this.lastDashAt = -9999;
    this.attackActiveUntil = 0;
    this.lastAttackAt = -9999;
    this.wasGroundedLastFrame = false;
    this.airbornePeakSpeedY = 0;
    this.coinRewardState = {};
    this.shieldCharges = 0;
    this.lastAuxHudAt = 0;
  }

  init(data) {
    const settings = Platformer.Settings.current;
    const difficulty = settings.gameplay.difficulty;
    const startLives = difficulty === "easy" ? 3 : (difficulty === "hard" ? 1 : 2);
    const timerSeconds = difficulty === "easy" ? 120 : (difficulty === "hard" ? 70 : 90);
    const carryState = !!(data && data.carryState);

    this.currentLevel = data.level || 1;
    this.registry.set("level", this.currentLevel);
    if (!carryState) {
      this.registry.set("health", 3);
      this.registry.set("lives", startLives);
    } else {
      this.registry.set("health", Math.max(1, this.registry.get("health") || 3));
      this.registry.set("lives", Math.max(1, this.registry.get("lives") || startLives));
    }
    this.registry.set("coins", 0);
    this.registry.set("timeLeft", timerSeconds);
    this.registry.set("threat", "CALM");
    this.registry.set("dashCd", 0);
    this.registry.set("shield", 0);
    this.isDead = false;
    this.levelComplete = false;
    this.levelTimeRemainingMs = timerSeconds * 1000;
    this.lastTickTime = 0;
    this.lastTimerSecond = -1;
    this.lastHazardShotAt = 0;
    this.threatActive = false;
    this.facingDir = 1;
    this.isDashing = false;
    this.dashEndsAt = 0;
    this.lastDashAt = -9999;
    this.attackActiveUntil = 0;
    this.lastAttackAt = -9999;
    this.wasGroundedLastFrame = false;
    this.airbornePeakSpeedY = 0;
    this.coinRewardState = {};
    this.shieldCharges = 0;
    this.lastAuxHudAt = 0;
  }

  create() {
    const { PLAYER, TILE } = Platformer.Config;
    const settings = Platformer.Settings.current;
    const difficulty = settings.gameplay.difficulty;
    const checkpointMode = settings.convenience.checkpointFrequency;

    this.mapRows = Platformer.createLevelData(this.currentLevel || 1);
    this.mapHeight = this.mapRows.length;
    this.mapWidth = this.mapRows[0].length;
    this.normalizeTurretTiles();
    this.normalizeEnemyTiles();

    this.physics.world.gravity.y = PLAYER.gravity;
    this.physics.world.setBounds(0, 0, this.mapWidth * TILE, this.mapHeight * TILE + 180);

    this.createTokyoBackdrop();

    this.solids = this.physics.add.staticGroup();
    this.oneWays = this.physics.add.staticGroup();
    this.hazards = this.physics.add.staticGroup();
    this.coins = this.physics.add.staticGroup();
    this.checkpoints = this.physics.add.staticGroup();
    this.enemies = this.physics.add.group({ allowGravity: true, immovable: false });
    this.enemyPatrolSpeed = difficulty === "hard" ? 95 : (difficulty === "easy" ? 48 : 60);
    this.hazardDamage = difficulty === "hard" ? 2 : 1;
    this.hazardCooldownScale = difficulty === "easy" ? 1.35 : (difficulty === "hard" ? 0.8 : 1);
    this.projectileIntervalMs = difficulty === "hard" ? 850 : (difficulty === "easy" ? 1500 : 1100);
    this.projectileSpeed = difficulty === "hard" ? 270 : (difficulty === "easy" ? 180 : 230);
    this.maxCheckpointCount = checkpointMode === "sparse" ? 1 : (checkpointMode === "frequent" ? 999 : (difficulty === "hard" ? 1 : 2));
    this.spawnCheckpointOnStart = checkpointMode === "frequent" || difficulty === "easy";
    this.hazardProjectiles = this.physics.add.group({ allowGravity: false, immovable: true });
    let checkpointCount = 0;

    for (let y = 0; y < this.mapHeight; y += 1) {
      for (let x = 0; x < this.mapWidth; x += 1) {
        const tile = this.mapRows[y][x];
        const px = x * TILE;
        const py = y * TILE;

        if (tile === "#") {
          const block = this.solids.create(px + TILE / 2, py + TILE / 2, "ground");
          block.refreshBody();
        }

        if (tile === "=") {
          const platform = this.oneWays.create(px + TILE / 2, py + 10, "oneway");
          platform.refreshBody();
        }

        if (tile === "^") {
          const spike = this.hazards.create(px + TILE / 2, py + TILE / 2, "hazard");
          spike.setDisplaySize(TILE, TILE);
          spike.refreshBody();
        }

        if (tile === "C") {
          const coin = this.coins.create(px + TILE / 2, py + TILE / 2, "coin");
          coin.refreshBody();
        }

        if (tile === "E" || tile === "F" || tile === "G" || tile === "H") {
          const enemyType = tile;
          const textureByType = { E: "enemy-e", F: "enemy-f", G: "enemy-g", H: "enemy-h" };
          const speedByType = { E: this.enemyPatrolSpeed, F: this.enemyPatrolSpeed * 0.9, G: this.enemyPatrolSpeed * 1.2, H: this.enemyPatrolSpeed * 0.75 };
          const enemy = this.enemies.create(px + TILE / 2, py + TILE / 2, textureByType[enemyType] || "enemy");
          const patrol = this.computeEnemyPatrolBounds(x, y);
          enemy.body.setSize(24, 24);
          enemy.setBounce(0, 0);
          enemy.setCollideWorldBounds(true);
          enemy.setVelocityX(-speedByType[enemyType]);
          enemy.setData("patrolSpeed", speedByType[enemyType]);
          enemy.setData("direction", -1);
          enemy.setData("turnCooldownUntil", 0);
          enemy.setData("patrolMinX", patrol.minX);
          enemy.setData("patrolMaxX", patrol.maxX);
          enemy.setData("useBoundedPatrol", patrol.maxX - patrol.minX >= TILE * 2);
          enemy.setData("enemyType", enemyType);
          enemy.setData("nextJumpAt", this.time.now + 800 + x * 3);
          enemy.setData("hp", enemyType === "H" ? 2 : 1);
          enemy.setData("lastX", enemy.x);
          enemy.setData("stuckSince", this.time.now);
          enemy.setData("aiState", "patrol");
          enemy.setData("stateUntil", 0);
          enemy.setData("attackCooldownUntil", this.time.now + 700 + (x % 5) * 90);
        }

        if (tile === "K") {
          if (checkpointCount >= this.maxCheckpointCount) {
            continue;
          }
          const checkpoint = this.checkpoints.create(px + TILE / 2, py + TILE / 2, "checkpoint");
          checkpoint.setData("activeCheckpoint", false);
          checkpoint.refreshBody();
          checkpointCount += 1;
        }

        if (tile === "S") {
          this.spawnPoint.set(px + TILE / 2, py + TILE / 2);
        }
      }
    }

    this.player = this.physics.add.sprite(this.spawnPoint.x, this.spawnPoint.y, "player-idle-1");
    if (this.textures.exists("player-idle-sheet")) {
      this.player.setTexture("player-idle-sheet", 0);
      this.useImportedCharacter = true;
      if (Platformer.Debug) Platformer.Debug.log("GameScene.playerIdle", "Using imported player-idle-sheet.");
    } else if (Platformer.Debug) {
      Platformer.Debug.warn("GameScene.playerIdle", "player-idle-sheet missing, using fallback idle textures.");
    }
    if (this.useImportedCharacter) {
      this.player.setDisplaySize(56, 56);
      this.player.body.setSize(22, 44, true);
    } else {
      this.player.setDisplaySize(28, 38);
      this.player.body.setSize(20, 34);
    }
    this.player.setCollideWorldBounds(true);
    // Allow dash velocity to exceed normal run cap.
    this.player.setMaxVelocity(Math.max(PLAYER.maxSpeed, PLAYER.dashSpeed + 60), 700);
    this.player.setDragX(PLAYER.drag);

    this.respawnPoint.copy(this.spawnPoint);
    if (this.spawnCheckpointOnStart) {
      const extraStartCheckpoint = this.checkpoints.create(this.spawnPoint.x + 24, this.spawnPoint.y - 20, "checkpoint");
      extraStartCheckpoint.setData("activeCheckpoint", true);
      extraStartCheckpoint.setTint(0x22c55e);
      extraStartCheckpoint.refreshBody();
    }

    this.physics.add.collider(this.player, this.solids);
    this.physics.add.collider(this.enemies, this.solids);
    this.physics.add.collider(this.enemies, this.oneWays, null, this.enemyOneWayProcess, this);
    this.physics.add.collider(this.player, this.oneWays, null, this.oneWayProcess, this);

    this.physics.add.collider(this.player, this.hazards);
    this.physics.add.collider(this.hazardProjectiles, this.solids, (projectile) => projectile.destroy(), null, this);
    this.physics.add.collider(this.hazardProjectiles, this.oneWays, (projectile) => projectile.destroy(), null, this);
    this.physics.add.overlap(this.player, this.coins, (_, coin) => this.collectCoin(coin), null, this);
    this.physics.add.overlap(this.player, this.checkpoints, (_, cp) => this.activateCheckpoint(cp), null, this);
    this.physics.add.overlap(this.player, this.enemies, (_, enemy) => this.handleEnemyContact(enemy), null, this);
    this.physics.add.overlap(this.player, this.hazardProjectiles, (_, projectile) => {
      projectile.destroy();
      this.applyDamage(1);
    }, null, this);

    this.cameras.main.setBounds(0, 0, this.mapWidth * TILE, this.mapHeight * TILE);
    const smooth = Phaser.Math.Clamp(settings.video.cameraSmoothing / 100, 0, 1);
    this.cameras.main.startFollow(this.player, true, smooth, smooth);
    this.cameras.main.setDeadzone(180, 120);
    this.cameras.main.setBackgroundColor("#0b1026");
    this.updateCameraFraming();
    this.scale.on("resize", this.updateCameraFraming, this);
    this.applyVideoSettings();
    this.createPlayerHealthBar();
    this.registry.set("shield", this.shieldCharges);

    this.cursors = this.input.keyboard.createCursorKeys();
    this.keys = this.input.keyboard.addKeys(this.buildControlKeyMap());
    this.setupGameMusic();
    this.setupHazardShooters();
    this.initRuntimeDiagnostics();
    this.onRestartLevel = () => {
      if (Platformer.Debug) Platformer.Debug.warn("GameScene", "restart-level event received; restarting current level.");
      this.scene.restart({ level: this.currentLevel || 1 });
    };
    this.game.events.on("restart-level", this.onRestartLevel);

    this.events.emit("hud-update");
  }

  initRuntimeDiagnostics() {
    if (!Platformer.Debug) return;
    Platformer.Debug.log(
      "GameScene.diag",
      `Level ${this.currentLevel} booted. map=${this.mapWidth}x${this.mapHeight} enemies=${this.enemies ? this.enemies.countActive(true) : 0} turrets=${this.hazards ? this.hazards.countActive(true) : 0}`
    );
  }

  diagWarn(key, message, cooldownMs = 1600) {
    if (!Platformer.Debug) return;
    const now = this.time ? this.time.now : Date.now();
    const last = this.diagCooldowns[key] || 0;
    if (now - last < cooldownMs) return;
    this.diagCooldowns[key] = now;
    Platformer.Debug.warn(`GameScene.diag.${key}`, message);
  }

  runRuntimeDiagnostics(now) {
    if (!Platformer.Debug) return;
    if (!this.player || !this.player.body) {
      this.diagWarn("player_missing", "Player body missing during update.", 3000);
      return;
    }

    const worldW = this.mapWidth * Platformer.Config.TILE;
    const worldH = this.mapHeight * Platformer.Config.TILE + 200;
    const { x, y } = this.player;
    if (!Number.isFinite(x) || !Number.isFinite(y)) {
      this.diagWarn("player_nan", `Invalid player position x=${x} y=${y}`, 0);
    }
    if (x < -140 || x > worldW + 140 || y < -200 || y > worldH + 260) {
      this.diagWarn("player_oob", `Player out of expected bounds x=${Math.round(x)} y=${Math.round(y)} world=${worldW}x${worldH}`);
    }

    const health = this.registry.get("health");
    const lives = this.registry.get("lives");
    const coins = this.registry.get("coins");
    if (!Number.isFinite(health) || health < -1 || health > 3) this.diagWarn("health_invalid", `health=${health}`);
    if (!Number.isFinite(lives) || lives < -1 || lives > 9) this.diagWarn("lives_invalid", `lives=${lives}`);
    if (!Number.isFinite(coins) || coins < 0 || coins > 9999) this.diagWarn("coins_invalid", `coins=${coins}`);

    let groundedEnemies = 0;
    let stuckEnemies = 0;
    this.enemies.children.each((enemy) => {
      if (!enemy || !enemy.active || !enemy.body) return;
      const ex = enemy.x;
      const ey = enemy.y;
      if (!Number.isFinite(ex) || !Number.isFinite(ey)) {
        this.diagWarn("enemy_nan", `enemy invalid pos x=${ex} y=${ey}`, 0);
        return;
      }
      if (ex < -80 || ex > worldW + 80 || ey > worldH + 200) {
        this.diagWarn("enemy_oob", `enemy out of bounds x=${Math.round(ex)} y=${Math.round(ey)}`);
      }
      if (enemy.body.blocked.down || enemy.body.touching.down) groundedEnemies += 1;
      const speedX = Math.abs(enemy.body.velocity.x || 0);
      if ((enemy.body.blocked.down || enemy.body.touching.down) && speedX < 8) stuckEnemies += 1;
    });

    if (this.enemies.countActive(true) > 0 && groundedEnemies === 0) {
      this.diagWarn("enemies_airborne", "All enemies airborne; check spawn/support tiles.", 2200);
    }
    if (stuckEnemies >= 2) {
      this.diagWarn("enemies_stalling", `${stuckEnemies} enemies currently stalled on ground.`, 1800);
    }

    this.hazards.children.each((hazard) => {
      if (!hazard || !hazard.active) return;
      const belowY = hazard.y + Platformer.Config.TILE * 0.55;
      if (!this.hasSupportAtWorld(hazard.x, belowY)) {
        this.diagWarn("turret_unsupported", `Turret at (${Math.round(hazard.x)},${Math.round(hazard.y)}) has no support below.`);
      }
    });

    if (this.hazardProjectiles && this.hazardShooters.length > 0 && now > 4500 && this.lastHazardShotAt <= 0) {
      this.diagWarn("no_projectile_fire", "Turrets present but no projectile has fired yet.", 5000);
    }
  }

  setupGameMusic() {
    const audioSettings = Platformer.Settings.current.audio;
    const volume = (audioSettings.master / 100) * (audioSettings.music / 100);

    if (Platformer.menuMusicHtml) {
      Platformer.menuMusicHtml.pause();
      Platformer.menuMusicHtml.currentTime = 0;
      Platformer.menuMusicHtml = null;
    }
    this.sound.stopByKey("menu-bgm");

    const startPhaserMusic = () => {
      let music = Platformer.gameMusic;
      if (!music) {
        music = this.sound.get("game-bgm");
        if (!music) {
          try {
            music = this.sound.add("game-bgm", { loop: true, volume });
          } catch (_e) {
            this.setupHtmlGameMusicFallback(volume, audioSettings);
            return;
          }
        }
        Platformer.gameMusic = music;
      }

      music.setLoop(true);
      music.setVolume(volume);
      const tryPlay = () => {
        if (!music || music.isPlaying) return;
        try {
          music.play();
        } catch (_e) {
          // Autoplay gating may block until first user input.
        }
      };
      this.input.once("pointerdown", tryPlay);
      this.input.keyboard.once("keydown", tryPlay);
      tryPlay();
    };

    if (this.cache.audio.exists("game-bgm")) {
      startPhaserMusic();
      return;
    }

    this.load.audio("game-bgm", "assets/Slaughter to Prevail - K (mp3cut.net).mp3");
    this.load.once("complete", startPhaserMusic);
    this.load.once("loaderror", () => this.setupHtmlGameMusicFallback(volume, audioSettings));
    this.load.start();
  }

  setupHtmlGameMusicFallback(volume, audioSettings) {
    try {
      if (!Platformer.gameMusicHtml) {
        Platformer.gameMusicHtml = new Audio("assets/Slaughter to Prevail - K (mp3cut.net).mp3");
      }
      const music = Platformer.gameMusicHtml;
      music.loop = true;
      music.volume = Phaser.Math.Clamp(volume, 0, 1);

      const tryPlay = () => {
        if (audioSettings.muteWhenUnfocused && document.hidden) return;
        music.play().catch(() => {});
      };

      this.input.once("pointerdown", tryPlay);
      this.input.keyboard.once("keydown", tryPlay);
      tryPlay();
    } catch (_e) {
      // Keep game functional if audio fails.
    }
  }

  createPlayerHealthBar() {
    this.playerHealthBarBg = this.add.rectangle(this.player.x, this.player.y - 34, 38, 7, 0x111827, 0.92)
      .setStrokeStyle(1, 0xe2e8f0, 0.85)
      .setDepth(55);
    this.playerHealthBarFill = this.add.rectangle(this.player.x - 18, this.player.y - 34, 34, 5, 0x22c55e, 1)
      .setOrigin(0, 0.5)
      .setDepth(56);
    this.updatePlayerHealthBar();
  }

  updatePlayerHealthBar() {
    if (!this.player || !this.playerHealthBarBg || !this.playerHealthBarFill) {
      return;
    }

    const health = Phaser.Math.Clamp(this.registry.get("health"), 0, 3);
    const ratio = health / 3;
    const fillWidth = Math.max(0, 34 * ratio);
    const color = ratio > 0.66 ? 0x22c55e : (ratio > 0.33 ? 0xf59e0b : 0xef4444);

    this.playerHealthBarBg.setPosition(this.player.x, this.player.y - 34);
    this.playerHealthBarFill.setPosition(this.player.x - 18, this.player.y - 34);
    this.playerHealthBarFill.width = fillWidth;
    this.playerHealthBarFill.setFillStyle(color, 1);
    this.playerHealthBarFill.setVisible(fillWidth > 0);
  }

  setupHazardShooters() {
    this.hazardShooters = [];
    let i = 0;
    this.hazards.children.each((hazard) => {
      // All turrets are active; stagger initial fire times for readability.
      hazard.setData("nextShotAt", this.time.now + i * 140);
      this.hazardShooters.push(hazard);
      i += 1;
    });
  }

  spawnHazardProjectiles(now) {
    if (!this.hazardShooters.length) {
      return;
    }

    let fired = 0;
    const maxShotsPerTick = 2;
    for (let i = 0; i < this.hazardShooters.length; i += 1) {
      if (fired >= maxShotsPerTick) {
        break;
      }

      const shooter = this.hazardShooters[i];
      if (!shooter || !shooter.active) {
        continue;
      }

      const nextShotAt = shooter.getData("nextShotAt") || 0;
      if (now < nextShotAt) {
        continue;
      }

      const inRangeX = Math.abs(shooter.x - this.player.x) < 540;
      const inRangeY = Math.abs(shooter.y - this.player.y) < 260;
      if (!inRangeX || !inRangeY) {
        continue;
      }

      const projectile = this.hazardProjectiles.create(shooter.x, shooter.y - 8, "hazard-projectile");
      projectile.setDepth(70);
      projectile.body.setSize(10, 10);
      projectile.body.setAllowGravity(false);
      projectile.setCollideWorldBounds(false);

      const dir = this.player.x >= shooter.x ? 1 : -1;
      const yAim = Phaser.Math.Clamp(this.player.y - shooter.y, -120, 90) * 0.35;
      projectile.setVelocity(dir * this.projectileSpeed, yAim);

      const stagger = (Math.floor(shooter.x / Platformer.Config.TILE) % 3) * 90;
      shooter.setData("nextShotAt", now + this.projectileIntervalMs + stagger);
      fired += 1;
      this.lastHazardShotAt = now;
    }
  }

  updateProjectiles() {
    const maxY = this.mapHeight * Platformer.Config.TILE + 200;
    const minX = -120;
    const maxX = this.mapWidth * Platformer.Config.TILE + 120;
    this.hazardProjectiles.children.each((p) => {
      if (!p.active) return;
      if (p.x < minX || p.x > maxX || p.y > maxY) {
        p.destroy();
      }
    });
  }

  updateLevelTimer(now) {
    if (!this.lastTickTime) {
      this.lastTickTime = now;
      return;
    }

    const dt = now - this.lastTickTime;
    this.lastTickTime = now;
    this.levelTimeRemainingMs = Math.max(0, this.levelTimeRemainingMs - dt);
    const secondsLeft = Math.ceil(this.levelTimeRemainingMs / 1000);
    if (secondsLeft !== this.lastTimerSecond) {
      this.lastTimerSecond = secondsLeft;
      this.registry.set("timeLeft", secondsLeft);
    }

    if (this.levelTimeRemainingMs <= 0 && !this.isDead) {
      this.isDead = true;
      this.game.events.emit("game-over");
      this.scene.pause();
    }
  }

  createTokyoBackdrop() {
    const { TILE } = Platformer.Config;
    const worldW = this.mapWidth * TILE;

    const skyTop = this.add.rectangle(worldW / 2, 120, worldW, 240, 0x111827).setDepth(-120).setScrollFactor(0);
    const skyMid = this.add.rectangle(worldW / 2, 260, worldW, 280, 0x1e1b4b).setDepth(-119).setScrollFactor(0);
    const skyGlow = this.add.rectangle(worldW / 2, 210, worldW, 180, 0x312e81, 0.35).setDepth(-118).setScrollFactor(0);
    this.parallax.push(skyTop, skyMid, skyGlow);

    const moon = this.add.circle(760, 88, 34, 0xfef3c7, 0.9).setDepth(-117).setScrollFactor(0.04);
    const moonGlow = this.add.circle(760, 88, 52, 0xfef9c3, 0.18).setDepth(-118).setScrollFactor(0.04);
    this.parallax.push(moon, moonGlow);

    const farHeights = [110, 120, 100, 130, 95, 126, 106, 116];
    for (let i = 0; i < 40; i += 1) {
      const w = 90;
      const h = farHeights[i % farHeights.length];
      const x = i * 88;
      const y = 320 - h / 2;
      const b = this.add.rectangle(x, y, w, h, 0x0f172a).setOrigin(0, 0.5).setDepth(-90).setScrollFactor(0.2);
      this.parallax.push(b);

      for (let wx = 0; wx < 4; wx += 1) {
        const color = (wx + i) % 2 === 0 ? 0x22d3ee : 0xf472b6;
        const win = this.add.rectangle(x + 12 + wx * 18, y - h / 2 + 18 + ((i + wx) % 5) * 14, 9, 6, color, 0.8)
          .setDepth(-89)
          .setScrollFactor(0.2);
        this.parallax.push(win);
      }
    }

    const midHeights = [140, 170, 150, 188, 132, 168];
    for (let i = 0; i < 26; i += 1) {
      const w = 122;
      const h = midHeights[i % midHeights.length];
      const x = i * 118;
      const y = 390 - h / 2;
      const b = this.add.rectangle(x, y, w, h, 0x020617).setOrigin(0, 0.5).setDepth(-70).setScrollFactor(0.45);
      this.parallax.push(b);

      if (i % 4 === 1) {
        const sign = this.add.rectangle(x + 70, y - h / 2 + 34, 58, 18, 0xdb2777, 0.9)
          .setDepth(-69)
          .setScrollFactor(0.45);
        this.parallax.push(sign);
      }
    }

    for (let i = 0; i < 24; i += 1) {
      const line = this.add.rectangle(i * 170, 120 + (i % 5) * 72, 120, 4, 0xffffff, 0.28)
        .setAngle(-16)
        .setOrigin(0, 0.5)
        .setDepth(-60)
        .setScrollFactor(0.12);
      this.parallax.push(line);
    }
  }

  oneWayProcess(player, platform) {
    const pBody = player.body;
    const platBody = platform.body;
    const wasAbove = pBody.bottom <= platBody.top + 6;
    const isFalling = pBody.velocity.y >= 0;
    return wasAbove && isFalling;
  }

  keyCodeFromName(name, fallback) {
    if (!name) return fallback;
    const upper = String(name).toUpperCase();
    const direct = Phaser.Input.Keyboard.KeyCodes[upper];
    if (typeof direct === "number") return direct;
    if (upper.length === 1) {
      const letter = Phaser.Input.Keyboard.KeyCodes[upper];
      if (typeof letter === "number") return letter;
    }
    return fallback;
  }

  buildControlKeyMap() {
    const c = Platformer.Settings.current.controls;
    return {
      left: this.keyCodeFromName(c.left, Phaser.Input.Keyboard.KeyCodes.A),
      right: this.keyCodeFromName(c.right, Phaser.Input.Keyboard.KeyCodes.D),
      jump: this.keyCodeFromName(c.jump, Phaser.Input.Keyboard.KeyCodes.W),
      dash: this.keyCodeFromName(c.dash, Phaser.Input.Keyboard.KeyCodes.SHIFT),
      attack: this.keyCodeFromName(c.attack, Phaser.Input.Keyboard.KeyCodes.J),
      interact: this.keyCodeFromName(c.interact, Phaser.Input.Keyboard.KeyCodes.E),
      pause: this.keyCodeFromName(c.pause, Phaser.Input.Keyboard.KeyCodes.ESC),
      demoWin: Phaser.Input.Keyboard.KeyCodes.F2,
    };
  }

  applyVideoSettings() {
    const s = Platformer.Settings.current;
    const brightness = Phaser.Math.Clamp(s.video.brightness, 0.8, 1.2);
    const shade = brightness >= 1 ? 0xffffff : 0x000000;
    const alpha = Math.abs(1 - brightness) * 0.45;
    this.brightnessOverlay = this.add.rectangle(
      this.mapWidth * Platformer.Config.TILE / 2,
      this.mapHeight * Platformer.Config.TILE / 2,
      this.mapWidth * Platformer.Config.TILE + 800,
      this.mapHeight * Platformer.Config.TILE + 800,
      shade,
      alpha
    ).setScrollFactor(0).setDepth(200);
  }

  updateCameraFraming() {
    if (!this.cameras || !this.cameras.main) {
      return;
    }
    const s = Platformer.Settings.current;
    const baseZoom = this.scale.height / Platformer.Config.GAME_HEIGHT;
    const resScale = Phaser.Math.Clamp(s.video.resolutionScale / 100, 0.5, 1);
    const zoom = Phaser.Math.Clamp(baseZoom * resScale, 0.75, 3);
    this.cameras.main.setZoom(zoom);
  }

  normalizeTurretTiles() {
    const grid = this.mapRows.map((row) => row.split(""));
    const inBounds = (x, y) => x >= 0 && x < this.mapWidth && y >= 0 && y < this.mapHeight;
    const isSupport = (x, y) => {
      if (!inBounds(x, y)) return false;
      const ch = grid[y][x];
      return ch === "#" || ch === "=";
    };
    const isWalkableSlot = (x, y) => {
      if (!inBounds(x, y)) return false;
      const ch = grid[y][x];
      return ch === "." || ch === "^";
    };
    const findSpawnX = () => {
      for (let yy = 0; yy < this.mapHeight; yy += 1) {
        for (let xx = 0; xx < this.mapWidth; xx += 1) {
          if (grid[yy][xx] === "S") return xx;
        }
      }
      return 0;
    };
    const spawnX = findSpawnX();

    const turrets = [];
    for (let y = 0; y < this.mapHeight; y += 1) {
      for (let x = 0; x < this.mapWidth; x += 1) {
        if (grid[y][x] === "^") {
          turrets.push({ x, y });
          grid[y][x] = ".";
        }
      }
    }

    const isSafeFromSpawn = (x) => Math.abs(x - spawnX) >= 8;
    const tryPlace = (x, y) => {
      if (isWalkableSlot(x, y) && isSupport(x, y + 1)) {
        if (!isSafeFromSpawn(x)) {
          return false;
        }
        grid[y][x] = "^";
        return true;
      }
      return false;
    };

    turrets.forEach(({ x, y }) => {
      let placed = false;
      const preferredY = Phaser.Math.Clamp(y, 0, this.mapHeight - 2);

      // Keep authored lane first for better level readability.
      placed = tryPlace(x, preferredY);

      // Then search nearby vertically only.
      if (!placed) {
        for (let d = 1; d <= 2 && !placed; d += 1) {
          const up = preferredY - d;
          const down = preferredY + d;
          if (up >= 0) placed = tryPlace(x, up);
          if (!placed && down <= this.mapHeight - 2) placed = tryPlace(x, down);
        }
      }
    });

    this.mapRows = grid.map((row) => row.join(""));
  }

  normalizeEnemyTiles() {
    const enemyChars = new Set(["E", "F", "G", "H"]);
    const grid = this.mapRows.map((row) => row.split(""));
    const inBounds = (x, y) => x >= 0 && x < this.mapWidth && y >= 0 && y < this.mapHeight;
    const chAt = (x, y) => (inBounds(x, y) ? grid[y][x] : ".");
    const isSupport = (x, y) => {
      const ch = chAt(x, y);
      return ch === "#" || ch === "=";
    };
    const isEnemySpotOpen = (x, y) => chAt(x, y) === ".";
    const isHazardAt = (x, y) => chAt(x, y) === "^";
    const hasHeadroom = (x, y) => y <= 0 || chAt(x, y - 1) === ".";
    const canStandAt = (x, y) =>
      inBounds(x, y)
      && y < this.mapHeight - 1
      && isEnemySpotOpen(x, y)
      && isSupport(x, y + 1)
      && !isHazardAt(x, y)
      && hasHeadroom(x, y);
    const patrolSpanAt = (x, y) => {
      if (!canStandAt(x, y)) {
        return 0;
      }

      let left = x;
      let right = x;
      while (canStandAt(left - 1, y)) left -= 1;
      while (canStandAt(right + 1, y)) right += 1;
      return right - left + 1;
    };

    let spawnX = 0;
    for (let y = 0; y < this.mapHeight; y += 1) {
      for (let x = 0; x < this.mapWidth; x += 1) {
        if (grid[y][x] === "S") {
          spawnX = x;
        }
      }
    }

    const turrets = [];
    const enemies = [];
    for (let y = 0; y < this.mapHeight; y += 1) {
      for (let x = 0; x < this.mapWidth; x += 1) {
        const ch = grid[y][x];
        if (ch === "^") turrets.push({ x, y });
        if (enemyChars.has(ch)) {
          enemies.push({ x, y, type: ch });
          grid[y][x] = ".";
        }
      }
    }

    const isSafeFromTurrets = (x, y) => !turrets.some((t) => Math.abs(t.x - x) <= 5 && Math.abs(t.y - y) <= 2);
    const isSafeFromSpawn = (x) => Math.abs(x - spawnX) >= 10;
    const placedEnemies = [];
    const isSafeFromOtherEnemies = (x, y) => !placedEnemies.some((e) => Math.abs(e.x - x) <= 4 && Math.abs(e.y - y) <= 2);
    const hasPatrolRoom = (x, y) => {
      const span = patrolSpanAt(x, y);
      if (span < 6) return false;
      return canStandAt(x - 1, y) || canStandAt(x + 1, y);
    };
    const canPlaceEnemy = (x, y) =>
      canStandAt(x, y)
      && hasPatrolRoom(x, y)
      && isSafeFromTurrets(x, y)
      && isSafeFromSpawn(x)
      && isSafeFromOtherEnemies(x, y);

    enemies.forEach((enemy) => {
      let placed = false;
      const tryOrder = [0, -1, 1];
      for (const dy of tryOrder) {
        const yy = enemy.y + dy;
        for (let dx = 0; dx <= 6; dx += 1) {
          const xs = dx === 0 ? [enemy.x] : [enemy.x - dx, enemy.x + dx];
          for (const xx of xs) {
            if (canPlaceEnemy(xx, yy)) {
              grid[yy][xx] = enemy.type;
              placedEnemies.push({ x: xx, y: yy });
              placed = true;
              break;
            }
          }
          if (placed) break;
        }
        if (placed) break;
      }

      if (!placed) {
        for (let y = 0; y < this.mapHeight - 1; y += 1) {
          for (let x = 0; x < this.mapWidth; x += 1) {
            if (canPlaceEnemy(x, y)) {
              grid[y][x] = enemy.type;
              placedEnemies.push({ x, y });
              placed = true;
              break;
            }
          }
          if (placed) break;
        }
      }
    });

    this.mapRows = grid.map((row) => row.join(""));
  }

  enemyOneWayProcess(enemy, platform) {
    const eBody = enemy.body;
    const pBody = platform.body;
    return eBody.bottom <= pBody.top + 4 && eBody.velocity.y >= 0;
  }

  tileCharAtWorld(worldX, worldY) {
    const { TILE } = Platformer.Config;
    const tx = Math.floor(worldX / TILE);
    const ty = Math.floor(worldY / TILE);
    return this.tileCharAt(tx, ty);
  }

  tileCharAt(tileX, tileY) {
    if (tileX < 0 || tileY < 0 || tileY >= this.mapHeight || tileX >= this.mapWidth) {
      return ".";
    }
    return this.mapRows[tileY][tileX];
  }

  hasSupportAtWorld(worldX, worldY) {
    const ch = this.tileCharAtWorld(worldX, worldY);
    return ch === "#" || ch === "=";
  }

  isHazardAtWorld(worldX, worldY) {
    return this.tileCharAtWorld(worldX, worldY) === "^";
  }

  isSupportTile(tileX, tileY) {
    const ch = this.tileCharAt(tileX, tileY);
    return ch === "#" || ch === "=";
  }

  isHazardTile(tileX, tileY) {
    return this.tileCharAt(tileX, tileY) === "^";
  }

  computeEnemyPatrolBounds(tileX, tileY) {
    const { TILE } = Platformer.Config;
    const supportY = tileY + 1;
    let left = tileX;
    let right = tileX;

    while (this.isSupportTile(left - 1, supportY) && !this.isHazardTile(left - 1, tileY)) {
      left -= 1;
    }
    while (this.isSupportTile(right + 1, supportY) && !this.isHazardTile(right + 1, tileY)) {
      right += 1;
    }

    return {
      minX: left * TILE + TILE / 2,
      maxX: right * TILE + TILE / 2,
    };
  }

  updateEnemyPatrol(enemy, now) {
    if (!enemy.active) return;

    let speed = enemy.getData("patrolSpeed");
    let dir = enemy.getData("direction");
    if (!dir) dir = enemy.body.velocity.x >= 0 ? 1 : -1;
    const minX = enemy.getData("patrolMinX");
    const maxX = enemy.getData("patrolMaxX");
    const useBounded = !!enemy.getData("useBoundedPatrol");
    const turnCooldownUntil = enemy.getData("turnCooldownUntil") || 0;
    const grounded = enemy.body.blocked.down || enemy.body.touching.down;
    const enemyType = enemy.getData("enemyType") || "E";
    const closeX = Math.abs(enemy.x - this.player.x) < (enemyType === "G" ? 260 : 190);
    const closeY = Math.abs(enemy.y - this.player.y) < 70;
    const aggressive = closeX && closeY;
    let aiState = enemy.getData("aiState") || "patrol";
    let stateUntil = enemy.getData("stateUntil") || 0;
    let attackCooldownUntil = enemy.getData("attackCooldownUntil") || 0;

    if (aggressive) {
      dir = this.player.x >= enemy.x ? 1 : -1;
      const mult = enemyType === "G" ? 2.3 : (enemyType === "H" ? 1.55 : 1.8);
      speed *= mult;
      enemy.setTint(0xf87171);
    } else {
      enemy.clearTint();
    }

    if ((enemyType === "G" || enemyType === "H") && aggressive && grounded) {
      if (aiState === "patrol" && now >= attackCooldownUntil) {
        aiState = "windup";
        stateUntil = now + (enemyType === "G" ? 210 : 280);
      } else if (aiState === "windup" && now >= stateUntil) {
        aiState = "lunge";
        stateUntil = now + (enemyType === "G" ? 280 : 220);
        dir = this.player.x >= enemy.x ? 1 : -1;
      } else if (aiState === "lunge" && now >= stateUntil) {
        aiState = "recover";
        stateUntil = now + 240;
        attackCooldownUntil = now + (enemyType === "G" ? 900 : 1200);
      } else if (aiState === "recover" && now >= stateUntil) {
        aiState = "patrol";
      }
    } else if (!aggressive && aiState !== "patrol") {
      aiState = "patrol";
    }

    if (aiState === "windup") {
      speed = 0;
      enemy.setTint(0xfacc15);
    } else if (aiState === "lunge") {
      const burst = enemyType === "G" ? 3.2 : 2.5;
      speed *= burst;
      enemy.setTint(0xfb7185);
    }

    if (enemyType === "F" && grounded) {
      const nextJumpAt = enemy.getData("nextJumpAt") || 0;
      if (now >= nextJumpAt) {
        enemy.setVelocityY(-260);
        enemy.setData("nextJumpAt", now + 1150);
      }
    }

    const hitLeft = enemy.body.blocked.left || enemy.body.touching.left;
    const hitRight = enemy.body.blocked.right || enemy.body.touching.right;

    if (hitLeft) {
      dir = 1;
      enemy.x += 1.5;
    }
    if (hitRight) {
      dir = -1;
      enemy.x -= 1.5;
    }

    if (useBounded) {
      if (enemy.x <= minX + 2) {
        dir = 1;
      } else if (enemy.x >= maxX - 2) {
        dir = -1;
      }
    }

    if (grounded) {
      const aheadX = enemy.x + dir * (enemy.body.width / 2 + 8);
      const footY = enemy.body.bottom + 6;
      const noGroundAhead = !this.hasSupportAtWorld(aheadX, footY);
      const hazardAhead = this.isHazardAtWorld(aheadX, footY - 10);
      if ((!useBounded && noGroundAhead) || hazardAhead) {
        if (now >= turnCooldownUntil) {
          dir *= -1;
          enemy.setData("turnCooldownUntil", now + 160);
          enemy.x += dir * 4;
        }
      }
    }

    if (!grounded && !useBounded) {
      const fallbackAheadX = enemy.x + dir * (enemy.body.width / 2 + 5);
      const fallbackFootY = enemy.body.bottom + 10;
      if (!this.hasSupportAtWorld(fallbackAheadX, fallbackFootY) && now >= turnCooldownUntil) {
        dir *= -1;
        enemy.setData("turnCooldownUntil", now + 160);
      }
    }

    enemy.setData("direction", dir);
    enemy.setVelocityX(dir * speed);
    enemy.setData("isAggressive", aggressive);
    enemy.setData("aiState", aiState);
    enemy.setData("stateUntil", stateUntil);
    enemy.setData("attackCooldownUntil", attackCooldownUntil);

    // Stuck recovery: if enemy is grounded and not advancing, hop out of cracks.
    const lastX = enemy.getData("lastX");
    let stuckSince = enemy.getData("stuckSince") || now;
    const moved = Math.abs(enemy.x - lastX) > 2;
    if (moved) {
      stuckSince = now;
    }

    if (grounded && !moved && Math.abs(enemy.body.velocity.x) < 14) {
      if (now - stuckSince > 320) {
        const jumpY = enemyType === "H" ? -210 : -260;
        enemy.setVelocityY(jumpY);
        dir *= -1;
        enemy.setData("direction", dir);
        enemy.setVelocityX(dir * speed);
        stuckSince = now;
      }
    }

    enemy.setData("lastX", enemy.x);
    enemy.setData("stuckSince", stuckSince);
  }

  showToast(message, color = 0xfef3c7) {
    this.game.events.emit("toast-message", { text: message, color });
    if (Platformer.Debug) Platformer.Debug.log("GameScene.toast", message);
  }

  applyCoinMilestoneReward(totalCoins) {
    if (this.coinRewardState[totalCoins]) return;

    if (totalCoins === 3) {
      const before = this.registry.get("health") || 0;
      const after = Math.min(3, before + 1);
      if (after > before) {
        this.registry.set("health", after);
        this.showToast("Reward: +1 Health", 0x86efac);
      } else {
        this.showToast("Reward: Health already full", 0xbbf7d0);
      }
      this.coinRewardState[totalCoins] = true;
      this.events.emit("hud-update");
      this.updatePlayerHealthBar();
      return;
    }

    if (totalCoins === 6) {
      this.levelTimeRemainingMs += 12000;
      const secondsLeft = Math.ceil(this.levelTimeRemainingMs / 1000);
      this.registry.set("timeLeft", secondsLeft);
      this.showToast("Reward: +12s Time", 0x93c5fd);
      this.coinRewardState[totalCoins] = true;
      this.events.emit("hud-update");
      return;
    }

    if (totalCoins === 9) {
      this.shieldCharges += 1;
      this.registry.set("shield", this.shieldCharges);
      this.showToast("Reward: Shield x1", 0xc4b5fd);
      this.coinRewardState[totalCoins] = true;
      this.events.emit("hud-update");
    }
  }

  tryStartDash(now, moveLeft, moveRight) {
    const { PLAYER } = Platformer.Config;
    const grounded = this.player.body.blocked.down || this.player.body.touching.down;
    const canDash = now - this.lastDashAt >= PLAYER.dashCooldownMs;
    if (!canDash || this.isDashing) return false;

    let dir = this.facingDir || 1;
    if (moveLeft && !moveRight) dir = -1;
    if (moveRight && !moveLeft) dir = 1;

    this.isDashing = true;
    this.lastDashAt = now;
    this.dashEndsAt = now + PLAYER.dashDurationMs;
    this.player.setDragX(0);
    this.player.setAccelerationX(0);
    this.player.setVelocityX(dir * PLAYER.dashSpeed);
    if (!grounded && this.player.body.velocity.y > 30) {
      this.player.setVelocityY(30);
    }
    this.player.setTint(0x93c5fd);
    this.registry.set("dashCd", Math.ceil(PLAYER.dashCooldownMs / 1000));
    Platformer.beeper.dash();
    return true;
  }

  stopDash() {
    if (!this.isDashing) return;
    this.isDashing = false;
    this.player.setDragX(Platformer.Config.PLAYER.drag);
    this.player.clearTint();
  }

  tryAttack(now) {
    const { PLAYER } = Platformer.Config;
    if (now - this.lastAttackAt < PLAYER.attackCooldownMs) return;

    this.lastAttackAt = now;
    this.attackActiveUntil = now + 120;
    this.player.setTint(0xfde68a);
    Platformer.beeper.attack();

    let hits = 0;
    this.enemies.children.each((enemy) => {
      if (!enemy || !enemy.active) return;
      const dx = enemy.x - this.player.x;
      const dy = Math.abs(enemy.y - this.player.y);
      const inFront = this.facingDir > 0 ? dx >= -6 : dx <= 6;
      const inRange = Math.abs(dx) <= PLAYER.attackRange && dy <= 28;
      if (!inFront || !inRange) return;

      const hp = enemy.getData("hp") || 1;
      if (hp <= 1) {
        enemy.disableBody(true, true);
      } else {
        enemy.setData("hp", hp - 1);
        enemy.setTint(0xfca5a5);
      }
      hits += 1;
    });

    if (hits > 0) {
      this.showToast(`Hit x${hits}`, 0xfef08a);
    }
  }

  updateLandingFeedback() {
    const grounded = this.player.body.blocked.down || this.player.body.touching.down;
    const currentDownSpeed = Math.max(0, this.player.body.velocity.y);
    if (!grounded) {
      this.airbornePeakSpeedY = Math.max(this.airbornePeakSpeedY, currentDownSpeed);
    } else if (!this.wasGroundedLastFrame) {
      const impact = this.airbornePeakSpeedY;
      if (impact > 200) {
        const power = Phaser.Math.Clamp(impact / 700, 0.08, 0.24);
        const reduce = Platformer.Settings.current.accessibility.reduceScreenShake / 100;
        this.cameras.main.shake(80, power * 0.015 * reduce, true);
        Platformer.beeper.land();
      }
      this.airbornePeakSpeedY = 0;
    }
    this.wasGroundedLastFrame = grounded;
  }

  updateAuxHud(now) {
    if (now - this.lastAuxHudAt < 120) return;
    this.lastAuxHudAt = now;

    const dashLeft = Math.max(0, (Platformer.Config.PLAYER.dashCooldownMs - (now - this.lastDashAt)) / 1000);
    this.registry.set("dashCd", dashLeft);
    this.registry.set("shield", this.shieldCharges);
  }

  collectCoin(coin) {
    coin.disableBody(true, true);
    const updatedCoins = this.registry.get("coins") + 1;
    this.registry.set("coins", updatedCoins);
    Platformer.beeper.coin();
    this.applyCoinMilestoneReward(updatedCoins);
    this.events.emit("hud-update");

    if (updatedCoins >= Platformer.Config.WIN_COIN_TARGET && !this.levelComplete) {
      this.completeLevel();
    }
  }

  activateCheckpoint(checkpoint) {
    if (checkpoint.getData("activeCheckpoint")) {
      return;
    }

    this.checkpoints.children.each((cp) => {
      cp.clearTint();
      cp.setData("activeCheckpoint", false);
    });

    checkpoint.setTint(0x22c55e);
    checkpoint.setData("activeCheckpoint", true);
    this.respawnPoint.set(checkpoint.x, checkpoint.y - 20);
  }

  onHazardHit() {
    this.applyDamage(this.hazardDamage);
  }

  handleEnemyContact(enemy) {
    const { PLAYER } = Platformer.Config;

    if (!enemy.active || this.isDead) {
      return;
    }

    if (this.isDashing) {
      const hp = enemy.getData("hp") || 1;
      if (hp <= 1) {
        enemy.disableBody(true, true);
      } else {
        enemy.setData("hp", hp - 1);
      }
      this.player.setVelocityY(-PLAYER.jumpVelocity * 0.3);
      this.showToast("Dash Break!", 0x93c5fd);
      return;
    }

    const playerBottom = this.player.body.bottom;
    const enemyTop = enemy.body.top;
    const isStomp = this.player.body.velocity.y > 40 && playerBottom <= enemyTop + 10;

    if (isStomp) {
      const hp = enemy.getData("hp") || 1;
      if (hp <= 1) {
        enemy.disableBody(true, true);
      } else {
        enemy.setData("hp", hp - 1);
        enemy.setTint(0xfca5a5);
      }
      this.player.setVelocityY(-PLAYER.jumpVelocity * 0.55);
      Platformer.beeper.stomp();
      return;
    }

    const enemyType = enemy.getData("enemyType") || "E";
    const aiState = enemy.getData("aiState") || "patrol";
    const contactDamage = (enemyType === "H" || aiState === "lunge") ? 2 : 1;
    this.applyDamage(contactDamage);
  }

  applyDamage(amount = 1) {
    const { PLAYER } = Platformer.Config;
    const settings = Platformer.Settings.current;

    const now = this.time.now;
    const invuln = Math.round(PLAYER.hurtInvulnMs * this.hazardCooldownScale);
    if (now - this.lastDamageTime < invuln || this.isDead) {
      return;
    }

    if (this.shieldCharges > 0) {
      this.shieldCharges -= 1;
      this.registry.set("shield", this.shieldCharges);
      this.lastDamageTime = now;
      this.player.setTintFill(0xc4b5fd);
      this.time.delayedCall(90, () => {
        if (this.player && this.player.active) this.player.clearTint();
      });
      this.showToast("Shield blocked damage", 0xc4b5fd);
      return;
    }

    this.lastDamageTime = now;
    const newHealth = this.registry.get("health") - amount;
    this.registry.set("health", newHealth);
    this.events.emit("hud-update");
    this.updatePlayerHealthBar();
    Platformer.beeper.damage();

    if (newHealth <= 0) {
      const remainingLives = this.registry.get("lives") - 1;
      this.registry.set("lives", remainingLives);

      if (remainingLives <= 0) {
        this.isDead = true;
        this.game.events.emit("game-over");
        this.scene.pause();
        return;
      }

      this.registry.set("health", 3);
      this.respawn();
    } else {
      this.player.setVelocity(-this.player.body.velocity.x * 0.35, -220);
      if (settings.accessibility.reduceScreenShake > 0) {
        this.cameras.main.shake(
          90,
          0.0018 * (settings.accessibility.reduceScreenShake / 100),
          true
        );
      }
    }
  }

  respawn() {
    const a11y = Platformer.Settings.current.accessibility;
    this.player.setPosition(this.respawnPoint.x, this.respawnPoint.y);
    this.player.setVelocity(0, 0);
    this.player.setAccelerationX(0);
    this.player.clearTint();
    this.jumpsUsed = 0;
    this.isJumpHeld = false;
    this.isDashing = false;
    this.attackActiveUntil = 0;
    if (!a11y.flashReduction) {
      this.cameras.main.flash(120, 255, 255, 255);
    }
    this.updatePlayerHealthBar();
    this.events.emit("hud-update");
  }

  completeLevel() {
    const a11y = Platformer.Settings.current.accessibility;
    const maxLevels = 4;
    this.levelComplete = true;
    this.player.setAccelerationX(0);
    this.player.setVelocity(0, -140);
    this.player.setTexture("player-run-1");
    this.player.setTint(0xfef08a);
    this.physics.world.pause();
    this.cameras.main.zoomTo(a11y.reducedMotion ? 1.02 : 1.15, a11y.reducedMotion ? 220 : 550, "Quad.easeOut", true);
    if (!a11y.flashReduction) {
      this.cameras.main.flash(200, 255, 255, 255);
    }
    if (this.currentLevel < maxLevels) {
      const nextLevel = this.currentLevel + 1;
      this.game.events.emit("level-transition", { from: this.currentLevel, to: nextLevel });
      this.time.delayedCall(a11y.reducedMotion ? 450 : 900, () => {
        this.scene.restart({ level: nextLevel, carryState: true });
      });
    } else {
      this.game.events.emit("level-complete", {
        level: this.registry.get("level"),
        coins: this.registry.get("coins"),
        targetCoins: Platformer.Config.WIN_COIN_TARGET,
      });
    }
  }

  update() {
    const { PLAYER, WIN_COIN_TARGET } = Platformer.Config;

    if (!this.player || this.isDead || this.levelComplete) {
      return;
    }

    const now = this.time.now;
    if (now - this.diagLastAt >= 450) {
      this.diagLastAt = now;
      this.runRuntimeDiagnostics(now);
    }
    this.updateLevelTimer(now);
    this.spawnHazardProjectiles(now);
    this.updateProjectiles();
    this.updatePlayerHealthBar();
    const moveLeft = this.keys.left.isDown || this.cursors.left.isDown;
    const moveRight = this.keys.right.isDown || this.cursors.right.isDown;
    const jumpPressed = Phaser.Input.Keyboard.JustDown(this.cursors.up)
      || Phaser.Input.Keyboard.JustDown(this.cursors.space)
      || Phaser.Input.Keyboard.JustDown(this.keys.jump);
    const dashPressed = Phaser.Input.Keyboard.JustDown(this.keys.dash);
    const attackPressed = Phaser.Input.Keyboard.JustDown(this.keys.attack);
    const demoWinPressed = Phaser.Input.Keyboard.JustDown(this.keys.demoWin);
    const jumpHeld = this.cursors.up.isDown || this.cursors.space.isDown || this.keys.jump.isDown;
    const grounded = this.player.body.blocked.down || this.player.body.touching.down;

    if (demoWinPressed && !this.levelComplete) {
      this.registry.set("coins", WIN_COIN_TARGET);
      this.events.emit("hud-update");
      this.completeLevel();
      return;
    }

    if (grounded) {
      this.lastOnGroundTime = now;
      this.jumpsUsed = 0;
    }

    if (jumpPressed) {
      this.lastJumpPressedTime = now;
    }

    const canUseCoyote = now - this.lastOnGroundTime <= PLAYER.coyoteTimeMs;
    const hasBufferedJump = now - this.lastJumpPressedTime <= PLAYER.jumpBufferMs;

    if (!this.isDashing && canUseCoyote && hasBufferedJump) {
      this.player.setVelocityY(-PLAYER.jumpVelocity);
      this.jumpsUsed = 1;
      this.lastOnGroundTime = -9999;
      this.lastJumpPressedTime = -9999;
      this.isJumpHeld = true;
      Platformer.beeper.jump();
    } else if (!this.isDashing && jumpPressed && this.jumpsUsed < PLAYER.maxJumps) {
      this.player.setVelocityY(-PLAYER.jumpVelocity);
      this.jumpsUsed += 1;
      this.lastJumpPressedTime = -9999;
      this.isJumpHeld = true;
      Platformer.beeper.jump();
    }

    if (!this.isDashing && !jumpHeld && this.isJumpHeld && this.player.body.velocity.y < -120) {
      this.player.setVelocityY(this.player.body.velocity.y * 0.5);
      this.isJumpHeld = false;
    }

    if (dashPressed) {
      this.tryStartDash(now, moveLeft, moveRight);
    }
    if (attackPressed) {
      this.tryAttack(now);
    }

    if (this.isDashing) {
      const dashDir = this.player.body.velocity.x >= 0 ? 1 : -1;
      this.player.setVelocityX(dashDir * PLAYER.dashSpeed);
      this.player.setAccelerationX(0);
      if (now >= this.dashEndsAt) {
        this.stopDash();
      }
    } else if (moveLeft && !moveRight) {
      this.player.setAccelerationX(-PLAYER.acceleration);
      this.player.setFlipX(false);
      this.facingDir = -1;
    } else if (moveRight && !moveLeft) {
      this.player.setAccelerationX(PLAYER.acceleration);
      this.player.setFlipX(true);
      this.facingDir = 1;
    } else {
      this.player.setAccelerationX(0);
    }
    if (!this.isDashing && now > this.attackActiveUntil) {
      this.player.clearTint();
    }

    if (this.useImportedCharacter) {
      if (!grounded) {
        if (this.player.anims && this.player.anims.isPlaying) {
          this.player.anims.stop();
        }
        if (this.player.texture && this.player.texture.key === "player-idle-sheet") {
          this.player.setFrame(2);
        }
      } else if (this.anims.exists("playerIdleAnim")) {
        if (!this.player.anims.isPlaying || this.player.anims.getName() !== "playerIdleAnim") {
          this.player.setTexture("player-idle-sheet", 0);
          this.player.play("playerIdleAnim");
        }
      } else {
        if (!this.idleAnimWarned && Platformer.Debug) {
          Platformer.Debug.warn("GameScene.playerIdle", "playerIdleAnim not found; fallback idle in use.");
          this.idleAnimWarned = true;
        }
        this.player.setTexture((Math.floor(now / 360) % 2 === 0) ? "player-idle-1" : "player-idle-2");
      }
    } else if (this.player.body.velocity.y < -25 || !this.player.body.blocked.down) {
      if (this.player.anims && this.player.anims.isPlaying) {
        this.player.anims.stop();
      }
      this.player.setTexture("player-jump");
    } else if (Math.abs(this.player.body.velocity.x) > 35) {
      if (this.player.anims && this.player.anims.isPlaying) {
        this.player.anims.stop();
      }
      this.player.setTexture((Math.floor(now / 100) % 2 === 0) ? "player-run-1" : "player-run-2");
    } else {
      this.player.setTexture((Math.floor(now / 360) % 2 === 0) ? "player-idle-1" : "player-idle-2");
    }

    let anyAggressive = false;
    this.enemies.children.each((enemy) => {
      this.updateEnemyPatrol(enemy, now);
      if (enemy.getData("isAggressive")) {
        anyAggressive = true;
      }
    });
    const projectileThreat = this.hazardProjectiles && this.hazardProjectiles.countActive(true) > 0;
    const threat = anyAggressive || projectileThreat;
    if (threat !== this.threatActive) {
      this.threatActive = threat;
      this.registry.set("threat", threat ? "DANGER" : "CALM");
    }
    this.updateLandingFeedback();
    this.updateAuxHud(now);

    if (this.player.y > this.mapHeight * Platformer.Config.TILE + 140) {
      this.applyDamage();
      if (!this.isDead) {
        this.respawn();
      }
    }
  }

  shutdown() {
    if (this.onRestartLevel) {
      this.game.events.off("restart-level", this.onRestartLevel);
      this.onRestartLevel = null;
    }
    this.scale.off("resize", this.updateCameraFraming, this);
  }
};
  /* <<< scenes/game-scene.js */

  /* >>> scenes/ui-scene.js */
// [bundle] namespace init removed; using local Platformer namespace.

Platformer.UIScene = class extends Phaser.Scene {
  constructor() {
    super("UIScene");
    this.hudText = null;
    this.pauseText = null;
    this.gameOverText = null;
    this.victoryText = null;
    this.victorySubText = null;
    this.victoryBars = [];
    this.victorySpeedLines = [];
    this.victoryCharacter = null;
    this.transitionText = null;
    this.toastText = null;
    this.toastTween = null;
    this.pausePanel = null;
    this.pauseButtons = [];
    this.pauseMusic = null;
    this.pauseMusicHtml = null;
    this.resumePhaserGameMusic = false;
    this.resumeHtmlGameMusic = false;
    this.onRegistryChanged = null;
    this.gamePaused = false;
    this.gameOver = false;
    this.levelComplete = false;
    this.onPauseKey = null;
    this.onRestartKey = null;
    this.onEnterKey = null;
    this.onGameOver = null;
    this.onLevelComplete = null;
    this.onLevelTransition = null;
    this.onOptionsClosed = null;
    this.onToastMessage = null;
    this.pauseKeyEventName = null;
  }

  create() {
    const textScale = Platformer.Settings.textScale();
    const pauseKey = Platformer.Settings.current.controls.pause || "ESC";
    this.pauseKeyEventName = `keydown-${pauseKey}`;

    this.hudText = this.add.text(16, 14, "", {
      fontFamily: "Consolas",
      fontSize: `${Math.round(20 * textScale)}px`,
      color: "#f8fafc",
      stroke: "#111827",
      strokeThickness: 4,
    }).setScrollFactor(0);

    this.pauseText = this.add.text(this.scale.width / 2, this.scale.height / 2, "PAUSED", {
      fontFamily: "Verdana",
      fontSize: `${Math.round(56 * textScale)}px`,
      color: "#fcd34d",
      stroke: "#1f2937",
      strokeThickness: 6,
    }).setOrigin(0.5).setScrollFactor(0).setVisible(false);
    this.buildPauseMenu(textScale);

    this.gameOverText = this.add.text(this.scale.width / 2, this.scale.height / 2,
      "GAME OVER\nPress R to Restart", {
        fontFamily: "Verdana",
        fontSize: `${Math.round(44 * textScale)}px`,
        color: "#fca5a5",
        align: "center",
        stroke: "#1f2937",
        strokeThickness: 6,
      }
    ).setOrigin(0.5).setScrollFactor(0).setVisible(false);

    this.victoryText = this.add.text(this.scale.width / 2, this.scale.height / 2 - 24,
      "MISSION CLEAR!", {
        fontFamily: "Impact, Haettenschweiler, Arial Narrow Bold, sans-serif",
        fontSize: `${Math.round(74 * textScale)}px`,
        color: "#fde047",
        stroke: "#7f1d1d",
        strokeThickness: 12,
        shadow: { offsetX: 0, offsetY: 0, color: "#000000", blur: 10, fill: true },
      }
    ).setOrigin(0.5).setScrollFactor(0).setVisible(false).setAlpha(0);

    this.victorySubText = this.add.text(this.scale.width / 2, this.scale.height / 2 + 52,
      "Coins Secured. Press ENTER for Menu", {
        fontFamily: "Consolas",
        fontSize: `${Math.round(26 * textScale)}px`,
        color: "#f8fafc",
        stroke: "#111827",
        strokeThickness: 6,
      }
    ).setOrigin(0.5).setScrollFactor(0).setVisible(false).setAlpha(0);

    this.transitionText = this.add.text(this.scale.width / 2, this.scale.height / 2,
      "", {
        fontFamily: "Verdana",
        fontSize: `${Math.round(46 * textScale)}px`,
        color: "#fef08a",
        stroke: "#1f2937",
        strokeThickness: 7,
        align: "center",
      }
    ).setOrigin(0.5).setScrollFactor(0).setVisible(false).setDepth(120);

    this.toastText = this.add.text(this.scale.width / 2, 74, "", {
      fontFamily: "Consolas",
      fontSize: `${Math.round(24 * textScale)}px`,
      color: "#fef3c7",
      stroke: "#111827",
      strokeThickness: 5,
      align: "center",
    }).setOrigin(0.5).setScrollFactor(0).setVisible(false).setDepth(130);

    this.createVictoryFX();
    this.updateHud();

    this.onRegistryChanged = () => this.updateHud();
    this.registry.events.on("changedata", this.onRegistryChanged);

    this.onGameOver = () => {
      this.gameOver = true;
      if (Platformer.Debug) Platformer.Debug.warn("UIScene", "Game over shown.");
      this.gameOverText.setVisible(true);
      this.hidePauseMenu();
    };
    this.game.events.on("game-over", this.onGameOver);

    this.onLevelComplete = () => {
      this.levelComplete = true;
      if (Platformer.Debug) Platformer.Debug.log("UIScene", "Level complete overlay shown.");
      this.hidePauseMenu();
      this.showVictorySequence();
    };
    this.game.events.on("level-complete", this.onLevelComplete);

    this.onLevelTransition = (payload) => {
      this.hidePauseMenu();
      this.showLevelTransition(payload);
    };
    this.game.events.on("level-transition", this.onLevelTransition);

    this.onOptionsClosed = () => {
      if (!this.gameOver && !this.levelComplete && this.scene.isPaused("GameScene")) {
        this.showPauseMenu();
      }
    };
    this.game.events.on("options-closed-to-pause", this.onOptionsClosed);

    this.onToastMessage = (payload) => this.showToast(payload);
    this.game.events.on("toast-message", this.onToastMessage);

    this.onPauseKey = () => {
      if (this.scene.isActive("OptionsScene")) return;
      if (this.gameOver || this.levelComplete) return;
      this.togglePauseMenu();
    };
    this.input.keyboard.on(this.pauseKeyEventName, this.onPauseKey);

    this.onRestartKey = () => {
      if (!this.gameOver) return;
      this.gameOver = false;
      this.gamePaused = false;
      this.gameOverText.setVisible(false);
      this.hidePauseMenu();
      this.game.events.emit("restart-level");
    };
    this.input.keyboard.on("keydown-R", this.onRestartKey);

    this.onEnterKey = () => {
      if (!this.levelComplete) return;
      this.levelComplete = false;
      this.resetOverlayStates();
      this.scene.stop("GameScene");
      this.scene.stop();
      this.scene.start("MenuScene");
    };
    this.input.keyboard.on("keydown-ENTER", this.onEnterKey);
  }

  buildPauseMenu(textScale) {
    const cx = this.scale.width / 2;
    const cy = this.scale.height / 2;

    this.pausePanel = this.add.rectangle(cx, cy, 560, 340, 0x020617, 0.86)
      .setStrokeStyle(2, 0x94a3b8, 0.8)
      .setScrollFactor(0)
      .setVisible(false)
      .setDepth(100);

    this.pauseText.setDepth(101);
    this.pauseText.setY(cy - 118);

    const createBtn = (y, label, onClick) => {
      const box = this.add.rectangle(cx, y, 280, 50, 0x1d4ed8, 0.96)
        .setStrokeStyle(2, 0x93c5fd, 0.9)
        .setDepth(101)
        .setScrollFactor(0)
        .setVisible(false)
        .setInteractive({ useHandCursor: true });
      const text = this.add.text(cx, y, label, {
        fontFamily: "Consolas",
        fontSize: `${Math.round(28 * textScale)}px`,
        color: "#f8fafc",
      }).setOrigin(0.5).setDepth(102).setScrollFactor(0).setVisible(false);

      box.on("pointerover", () => box.setFillStyle(0x2563eb, 0.98));
      box.on("pointerout", () => box.setFillStyle(0x1d4ed8, 0.96));
      box.on("pointerdown", onClick);

      this.pauseButtons.push({ box, text });
    };

    createBtn(cy - 30, "Resume", () => this.resumeFromPause());
    createBtn(cy + 35, "Options", () => {
      this.hidePauseMenu();
      this.scene.launch("OptionsScene", { returnTo: "pause" });
    });
    createBtn(cy + 100, "Return to Menu", () => {
      if (Platformer.Debug) Platformer.Debug.warn("UIScene.pause", "Return to Menu clicked.");
      this.stopPauseMusic();
      this.hidePauseMenu();
      this.scene.stop("GameScene");
      if (this.scene.isActive("OptionsScene")) this.scene.stop("OptionsScene");
      this.scene.stop();
      this.scene.start("MenuScene");
    });
  }

  showPauseMenu() {
    if (Platformer.Debug) Platformer.Debug.log("UIScene.pause", "Pause menu opened.");
    this.pauseGameplayMusic();
    this.playPauseMusic();
    this.pausePanel.setVisible(true);
    this.pauseText.setVisible(true);
    this.pauseButtons.forEach((b) => {
      b.box.setVisible(true);
      b.text.setVisible(true);
    });
    this.gamePaused = true;
  }

  hidePauseMenu() {
    if (this.pausePanel) this.pausePanel.setVisible(false);
    this.pauseText.setVisible(false);
    this.pauseButtons.forEach((b) => {
      b.box.setVisible(false);
      b.text.setVisible(false);
    });
    this.gamePaused = false;
  }

  togglePauseMenu() {
    if (this.scene.isPaused("GameScene")) {
      this.resumeFromPause();
    } else {
      this.scene.pause("GameScene");
      this.showPauseMenu();
    }
  }

  resumeFromPause() {
    if (Platformer.Debug) Platformer.Debug.log("UIScene.pause", "Resuming gameplay from pause.");
    this.stopPauseMusic();
    this.resumeGameplayMusic();
    this.scene.resume("GameScene");
    this.hidePauseMenu();
  }

  pauseGameplayMusic() {
    if (Platformer.gameMusic && Platformer.gameMusic.isPlaying) {
      try {
        Platformer.gameMusic.pause();
        this.resumePhaserGameMusic = true;
      } catch (_e) {
        // Ignore; best effort.
      }
    }

    if (Platformer.gameMusicHtml && !Platformer.gameMusicHtml.paused) {
      try {
        Platformer.gameMusicHtml.pause();
        this.resumeHtmlGameMusic = true;
      } catch (_e) {
        // Ignore; best effort.
      }
    }
  }

  resumeGameplayMusic() {
    if (this.resumePhaserGameMusic && Platformer.gameMusic) {
      try {
        Platformer.gameMusic.resume();
      } catch (_e) {
        // Ignore; best effort.
      }
    }

    if (this.resumeHtmlGameMusic && Platformer.gameMusicHtml) {
      Platformer.gameMusicHtml.play().catch(() => {});
    }

    this.resumePhaserGameMusic = false;
    this.resumeHtmlGameMusic = false;
  }

  playPauseMusic() {
    const audioSettings = Platformer.Settings.current.audio;
    const volume = Phaser.Math.Clamp((audioSettings.master / 100) * (audioSettings.music / 100), 0, 1);

    if (this.cache.audio.exists("pause-bgm")) {
      if (!this.pauseMusic) {
        this.pauseMusic = this.sound.get("pause-bgm");
        if (!this.pauseMusic) {
          try {
            this.pauseMusic = this.sound.add("pause-bgm", { loop: true, volume });
          } catch (_e) {
            this.pauseMusic = null;
          }
        }
      }
      if (this.pauseMusic) {
        this.pauseMusic.setLoop(true);
        this.pauseMusic.setVolume(volume);
        if (!this.pauseMusic.isPlaying) {
          try {
            this.pauseMusic.play();
          } catch (_e) {
            // Autoplay gating: user already pressed ESC, so retry on next input if needed.
          }
        }
        return;
      }
    }

    // HTML audio fallback.
    if (!this.pauseMusicHtml) {
      try {
        this.pauseMusicHtml = new Audio("assets/Elevator Music - So Chill (mp3cut.net).mp3");
        Platformer.pauseMusicHtml = this.pauseMusicHtml;
        this.pauseMusicHtml.loop = true;
      } catch (_e) {
        this.pauseMusicHtml = null;
      }
    }
    if (this.pauseMusicHtml) {
      this.pauseMusicHtml.volume = volume;
      this.pauseMusicHtml.play().catch(() => {});
    }
  }

  stopPauseMusic() {
    if (this.pauseMusic && this.pauseMusic.isPlaying) {
      this.pauseMusic.stop();
    }
    if (this.pauseMusicHtml) {
      this.pauseMusicHtml.pause();
      this.pauseMusicHtml.currentTime = 0;
      Platformer.pauseMusicHtml = null;
    }
  }

  updateHud() {
    if (!this.hudText || !this.hudText.active) {
      return;
    }
    if (!this.sys || !this.sys.settings || !this.sys.settings.active) {
      return;
    }

    const lives = this.registry.get("lives");
    const health = this.registry.get("health");
    const coins = this.registry.get("coins");
    const level = this.registry.get("level");
    const timeLeft = this.registry.get("timeLeft");
    const threat = this.registry.get("threat");
    const dashCd = Number(this.registry.get("dashCd") || 0);
    const shield = Math.max(0, Number(this.registry.get("shield") || 0));
    const { WIN_COIN_TARGET } = Platformer.Config;
    const dashTxt = dashCd <= 0.06 ? "READY" : `${dashCd.toFixed(1)}s`;

    try {
      this.hudText.setText(
        `Level: ${level}   Lives: ${Math.max(0, lives)}   Health: ${Math.max(0, health)}   Coins: ${coins}/${WIN_COIN_TARGET}   Time: ${Math.max(0, timeLeft || 0)}   Threat: ${threat || "CALM"}   Dash: ${dashTxt}   Shield: ${shield}`
      );
    } catch (err) {
      const msg = err && err.stack ? err.stack : String(err);
      if (Platformer.Debug && Platformer.Debug.error) {
        Platformer.Debug.error("UIScene.updateHud", msg);
      }
    }
  }

  showToast(payload) {
    if (!payload || !this.toastText) return;
    const text = String(payload.text || "").trim();
    if (!text) return;
    const color = payload.color || 0xfef3c7;
    this.toastText.setText(text);
    this.toastText.setColor(`#${color.toString(16).padStart(6, "0")}`);
    this.toastText.setAlpha(1);
    this.toastText.setVisible(true);
    if (this.toastTween) {
      this.toastTween.stop();
      this.toastTween = null;
    }
    this.toastTween = this.tweens.add({
      targets: this.toastText,
      y: 58,
      alpha: 0,
      duration: 900,
      ease: "Quad.easeOut",
      onComplete: () => {
        if (this.toastText) {
          this.toastText.setVisible(false);
          this.toastText.setY(74);
        }
      },
    });
  }

  createVictoryFX() {
    const topBar = this.add.rectangle(this.scale.width / 2, -45, this.scale.width, 90, 0x020617, 0.92)
      .setScrollFactor(0).setVisible(false);
    const bottomBar = this.add.rectangle(this.scale.width / 2, this.scale.height + 45, this.scale.width, 90, 0x020617, 0.92)
      .setScrollFactor(0).setVisible(false);
    this.victoryBars = [topBar, bottomBar];

    const lineColor = 0xffffff;
    for (let i = 0; i < 16; i += 1) {
      const y = 40 + i * 30;
      const line = this.add.rectangle(-220, y, 190, 4, lineColor, 0.22)
        .setAngle(-16)
        .setScrollFactor(0)
        .setVisible(false);
      this.victorySpeedLines.push(line);
    }

    this.victoryCharacter = this.buildVictoryCharacter(this.scale.width - 210, this.scale.height - 210);
    this.victoryCharacter.setVisible(false).setAlpha(0).setScale(0.8);
  }

  buildVictoryCharacter(x, y) {
    const style = [
      "width:236px",
      "height:236px",
      "border:4px solid #fde047",
      "background:rgba(15,23,42,0.86)",
      "display:flex",
      "align-items:center",
      "justify-content:center",
      "overflow:hidden",
      "box-sizing:border-box",
    ].join(";");

    const dom = this.add.dom(x, y, "div", style, "").setScrollFactor(0);
    const img = document.createElement("img");
    img.src = "./assets/kawaii-anime-girl.gif";
    img.alt = "Victory Girl";
    img.style.width = "220px";
    img.style.height = "220px";
    img.style.objectFit = "cover";
    img.onerror = () => {
      dom.node.innerHTML = "<span style='font-family:Consolas;color:#f8fafc;font-size:32px'>VICTORY</span>";
    };
    dom.node.appendChild(img);

    return dom;
  }

  showVictorySequence() {
    if (this.victoryCharacter) {
      this.victoryCharacter.destroy();
    }
    this.victoryCharacter = this.buildVictoryCharacter(this.scale.width - 210, this.scale.height - 210);
    this.victoryCharacter.setVisible(false).setAlpha(0).setScale(0.8);

    this.pauseText.setVisible(false);
    this.gameOverText.setVisible(false);
    this.victoryBars.forEach((bar) => bar.setVisible(true));
    this.victorySpeedLines.forEach((line) => line.setVisible(true));
    this.victoryText.setVisible(true);
    this.victorySubText.setVisible(true);
    this.victoryCharacter.setVisible(true);

    this.tweens.add({
      targets: this.victoryBars[0],
      y: 40,
      duration: 320,
      ease: "Cubic.easeOut",
    });
    this.tweens.add({
      targets: this.victoryBars[1],
      y: this.scale.height - 40,
      duration: 320,
      ease: "Cubic.easeOut",
    });

    this.victorySpeedLines.forEach((line, idx) => {
      line.x = -220 - idx * 36;
      this.tweens.add({
        targets: line,
        x: this.scale.width + 220,
        duration: 360 + idx * 22,
        ease: "Linear",
        repeat: -1,
        delay: idx * 20,
      });
    });

    this.tweens.add({
      targets: this.victoryText,
      alpha: 1,
      scaleX: { from: 1.65, to: 1 },
      scaleY: { from: 0.35, to: 1 },
      angle: { from: -8, to: 0 },
      duration: 280,
      ease: "Back.easeOut",
    });

    this.tweens.add({
      targets: this.victorySubText,
      alpha: 1,
      y: this.victorySubText.y + 10,
      duration: 240,
      delay: 180,
      ease: "Quad.easeOut",
    });

    this.tweens.add({
      targets: this.victoryText,
      scale: 1.05,
      yoyo: true,
      duration: 620,
      repeat: -1,
      ease: "Sine.easeInOut",
    });

    this.tweens.add({
      targets: this.victoryCharacter,
      alpha: 1,
      scale: 1,
      x: this.scale.width - 196,
      duration: 300,
      ease: "Back.easeOut",
    });

    this.tweens.add({
      targets: this.victoryCharacter,
      y: this.victoryCharacter.y - 8,
      yoyo: true,
      repeat: -1,
      duration: 900,
      ease: "Sine.easeInOut",
    });
  }

  showLevelTransition(payload) {
    const from = payload && payload.from ? payload.from : "?";
    const to = payload && payload.to ? payload.to : "?";
    this.transitionText
      .setText(`LEVEL ${from} CLEAR\\nNEXT: LEVEL ${to}`)
      .setVisible(true)
      .setAlpha(0)
      .setScale(1.1);

    this.tweens.add({
      targets: this.transitionText,
      alpha: 1,
      scale: 1,
      duration: 220,
      yoyo: true,
      hold: 350,
      onComplete: () => this.transitionText.setVisible(false),
    });
  }

  resetOverlayStates() {
    this.gameOverText.setVisible(false);
    this.pauseText.setVisible(false);
    this.hidePauseMenu();
    this.stopPauseMusic();
    this.victoryText.setVisible(false).setAlpha(0).setScale(1).setAngle(0);
    if (this.transitionText) {
      this.transitionText.setVisible(false).setAlpha(0).setScale(1);
    }
    this.victorySubText.setVisible(false).setAlpha(0).setY(this.scale.height / 2 + 52);
    this.victoryBars[0].setVisible(false).setY(-45);
    this.victoryBars[1].setVisible(false).setY(this.scale.height + 45);
    this.victorySpeedLines.forEach((line) => line.setVisible(false));

    if (this.victoryCharacter) {
      this.victoryCharacter.setVisible(false).setAlpha(0).setScale(0.8);
      this.victoryCharacter.setPosition(this.scale.width - 210, this.scale.height - 210);
    }

    this.tweens.killAll();
  }

  shutdown() {
    this.stopPauseMusic();
    this.resumePhaserGameMusic = false;
    this.resumeHtmlGameMusic = false;
    if (this.toastTween) {
      this.toastTween.stop();
      this.toastTween = null;
    }
    if (this.onRegistryChanged) {
      this.registry.events.off("changedata", this.onRegistryChanged);
      this.onRegistryChanged = null;
    }
    if (this.onGameOver) this.game.events.off("game-over", this.onGameOver);
    if (this.onLevelComplete) this.game.events.off("level-complete", this.onLevelComplete);
    if (this.onLevelTransition) this.game.events.off("level-transition", this.onLevelTransition);
    if (this.onOptionsClosed) this.game.events.off("options-closed-to-pause", this.onOptionsClosed);
    if (this.onToastMessage) this.game.events.off("toast-message", this.onToastMessage);
    if (this.onPauseKey && this.pauseKeyEventName) this.input.keyboard.off(this.pauseKeyEventName, this.onPauseKey);
    if (this.onRestartKey) this.input.keyboard.off("keydown-R", this.onRestartKey);
    if (this.onEnterKey) this.input.keyboard.off("keydown-ENTER", this.onEnterKey);
    this.onPauseKey = null;
    this.onRestartKey = null;
    this.onEnterKey = null;
    this.onGameOver = null;
    this.onLevelComplete = null;
    this.onLevelTransition = null;
    this.onOptionsClosed = null;
    this.onToastMessage = null;
    this.pauseKeyEventName = null;
  }
};
  /* <<< scenes/ui-scene.js */

  /* >>> main.js */
// [bundle] namespace init removed; using local Platformer namespace.

(async () => {
  if (!Platformer.BUILD_VERSION || typeof Platformer.BUILD_VERSION !== "string") {
    document.body.innerHTML = "<div style='font-family:Consolas,monospace;padding:24px;color:#fee2e2;background:#1f2937'>Build metadata missing. Rebuild the game package.</div>";
    throw new Error("BUILD_VERSION missing.");
  }
  await Platformer.Settings.bootstrap();
  const { PLAYER } = Platformer.Config;
  const settings = Platformer.Settings.current;
  const fpsTarget = settings.video.fpsCap === "unlimited" ? 0 : Number(settings.video.fpsCap);
  const isFileProtocol = window.location.protocol === "file:";
  const isDesktopHost = !!(window.pywebview && window.pywebview.api);
  const dpr = Math.max(1, Math.min(2, Math.round((window.devicePixelRatio || 1) * 100) / 100));
  const getViewportSize = () => {
    const root = document.getElementById("game-root");
    const rootW = root && root.clientWidth ? root.clientWidth : 0;
    const rootH = root && root.clientHeight ? root.clientHeight : 0;
    const docW = document.documentElement && document.documentElement.clientWidth ? document.documentElement.clientWidth : 0;
    const docH = document.documentElement && document.documentElement.clientHeight ? document.documentElement.clientHeight : 0;
    const w = Math.max(rootW, docW, 640);
    const h = Math.max(rootH, docH, 360);
    return { w, h };
  };
  const initial = getViewportSize();
  Platformer.Debug.init();
  if (Platformer.BUILD_VERSION) {
    Platformer.Debug.log("Build", `version=${Platformer.BUILD_VERSION} time=${Platformer.BUILD_TIME_UTC || "n/a"}`);
  }
  if (isFileProtocol && !isDesktopHost) Platformer.Debug.log("Runtime", "file:// mode detected.");
  if (isDesktopHost) Platformer.Debug.log("Runtime", "Desktop host mode detected.");

  const SafeBootScene = Platformer.wrapSceneSafety(Platformer.BootScene, "BootScene");
  const SafeMenuScene = Platformer.wrapSceneSafety(Platformer.MenuScene, "MenuScene");
  const SafeIntroScene = Platformer.wrapSceneSafety(Platformer.IntroScene, "IntroScene");
  const SafeOptionsScene = Platformer.wrapSceneSafety(Platformer.OptionsScene, "OptionsScene");
  const SafeGameScene = Platformer.wrapSceneSafety(Platformer.GameScene, "GameScene");
  const SafeUIScene = Platformer.wrapSceneSafety(Platformer.UIScene, "UIScene");

  const config = {
    type: Phaser.AUTO,
    width: initial.w,
    height: initial.h,
    parent: "game-root",
    pixelArt: settings.video.pixelPerfect,
    resolution: dpr,
    scale: {
      mode: Phaser.Scale.RESIZE,
      width: initial.w,
      height: initial.h,
      zoom: 1,
    },
    backgroundColor: "#7dd3fc",
    autoRound: true,
    render: {
      antialias: false,
      antialiasGL: false,
      pixelArt: true,
      roundPixels: true,
      powerPreference: "high-performance",
    },
    physics: {
      default: "arcade",
      arcade: {
        gravity: { y: PLAYER.gravity },
        debug: false,
      },
    },
    fps: {
      target: fpsTarget || 60,
      forceSetTimeOut: !settings.video.vsync,
    },
    dom: {
      createContainer: true,
    },
    scene: [
      SafeBootScene,
      SafeMenuScene,
      SafeIntroScene,
      SafeOptionsScene,
      SafeGameScene,
      SafeUIScene,
    ],
  };

  const game = new Phaser.Game(config);
  window.AnimePlatformerGame = {
    play() { if (game && game.scene) game.scene.resume("GameScene"); },
    pause() { if (game && game.scene) game.scene.pause("GameScene"); },
    settings() { return Platformer.Settings.current; },
  };
  Platformer.Debug.attachGameMonitors(game);
  let lastW = initial.w;
  let lastH = initial.h;

  const applySize = (wRaw, hRaw, source = "window") => {
    const vp = getViewportSize();
    const w = Math.max(640, Number(wRaw) || vp.w);
    const h = Math.max(360, Number(hRaw) || vp.h);
    if (w === lastW && h === lastH) return;
    lastW = w;
    lastH = h;
    Platformer.Debug.log("ResizeSync", `${source} -> ${w}x${h}`);

    if (game && game.scale) {
      game.scale.resize(w, h);
      if (typeof game.scale.refresh === "function") {
        game.scale.refresh();
      }
      if (game.input && game.input.manager && typeof game.input.manager.resize === "function") {
        game.input.manager.resize(w, h);
      }
    }
  };
  const syncGameSize = () => {
    const vp = getViewportSize();
    applySize(vp.w, vp.h, "viewport");
  };

  window.addEventListener("resize", syncGameSize);
  window.addEventListener("orientationchange", syncGameSize);
  window.addEventListener("online", () => {
    const scene = game && game.scene ? game.scene.getScene("MenuScene") : null;
    if (scene && typeof scene.autoCheckUpdatesForBottomLeft === "function") {
      scene.autoCheckUpdatesForBottomLeft();
    }
  });
  // Keep a lightweight heartbeat for wrappers that occasionally miss resize events.
  setInterval(syncGameSize, 500);

  if (settings.video.fullscreen) {
    game.events.once("ready", () => {
      if (!game.scale.isFullscreen) {
        game.scale.startFullscreen();
      }
    });
  }
})();


  /* <<< main.js */

})(window);
//# sourceMappingURL=app.bundle.js.map
